(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{397:function(module,exports,__webpack_require__){eval("// https://github.com/tc39/proposal-object-values-entries\nvar $export = __webpack_require__(12);\nvar $values = __webpack_require__(398)(false);\n\n$export($export.S, 'Object', {\n  values: function values(it) {\n    return $values(it);\n  }\n});\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk3LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lczcub2JqZWN0LnZhbHVlcy5qcz84NjE1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLW9iamVjdC12YWx1ZXMtZW50cmllc1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciAkdmFsdWVzID0gcmVxdWlyZSgnLi9fb2JqZWN0LXRvLWFycmF5JykoZmFsc2UpO1xuXG4kZXhwb3J0KCRleHBvcnQuUywgJ09iamVjdCcsIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoaXQpIHtcbiAgICByZXR1cm4gJHZhbHVlcyhpdCk7XG4gIH1cbn0pO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///397\n")},398:function(module,exports,__webpack_require__){eval("var DESCRIPTORS = __webpack_require__(28);\nvar getKeys = __webpack_require__(73);\nvar toIObject = __webpack_require__(48);\nvar isEnum = __webpack_require__(170).f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || isEnum.call(O, key)) {\n        result.push(isEntries ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk4LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9fb2JqZWN0LXRvLWFycmF5LmpzPzUwNGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgaXNFbnVtID0gcmVxdWlyZSgnLi9fb2JqZWN0LXBpZScpLmY7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpc0VudHJpZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICAgIHZhciBPID0gdG9JT2JqZWN0KGl0KTtcbiAgICB2YXIga2V5cyA9IGdldEtleXMoTyk7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaSkge1xuICAgICAga2V5ID0ga2V5c1tpKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBpc0VudW0uY2FsbChPLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGlzRW50cmllcyA/IFtrZXksIE9ba2V5XV0gOiBPW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///398\n")},399:function(module,exports,__webpack_require__){eval("(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 141);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Utility for F2\n * @author dxq613 @gmail.com\n * @author sima.zhang1990@gmail.com\n */\nvar DomUtil = __webpack_require__(47);\n\nvar Util = {\n  upperFirst: __webpack_require__(48),\n  lowerFirst: __webpack_require__(49),\n  isString: __webpack_require__(50),\n  isNumber: __webpack_require__(51),\n  isBoolean: __webpack_require__(52),\n  isFunction: __webpack_require__(53),\n  isDate: __webpack_require__(54),\n  isArray: __webpack_require__(20),\n  isNil: __webpack_require__(30),\n  isObject: __webpack_require__(31),\n  isPlainObject: __webpack_require__(32),\n  deepMix: __webpack_require__(56),\n  mix: __webpack_require__(57),\n  each: __webpack_require__(33),\n  uniq: __webpack_require__(58),\n  isObjectValueEqual: function isObjectValueEqual(a, b) {\n    // for vue.js\n    a = Object.assign({}, a);\n    b = Object.assign({}, b);\n    var aProps = Object.getOwnPropertyNames(a);\n    var bProps = Object.getOwnPropertyNames(b);\n\n    if (aProps.length !== bProps.length) {\n      return false;\n    }\n\n    for (var i = 0, len = aProps.length; i < len; i++) {\n      var propName = aProps[i];\n\n      if (a[propName] !== b[propName]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  wrapBehavior: function wrapBehavior(obj, action) {\n    if (obj['_wrap_' + action]) {\n      return obj['_wrap_' + action];\n    }\n\n    var method = function method(e) {\n      obj[action](e);\n    };\n\n    obj['_wrap_' + action] = method;\n    return method;\n  },\n  getWrapBehavior: function getWrapBehavior(obj, action) {\n    return obj['_wrap_' + action];\n  },\n  parsePadding: function parsePadding(padding) {\n    var top;\n    var right;\n    var bottom;\n    var left;\n\n    if (Util.isNumber(padding) || Util.isString(padding)) {\n      top = bottom = left = right = padding;\n    } else if (Util.isArray(padding)) {\n      top = padding[0];\n      right = !Util.isNil(padding[1]) ? padding[1] : padding[0];\n      bottom = !Util.isNil(padding[2]) ? padding[2] : padding[0];\n      left = !Util.isNil(padding[3]) ? padding[3] : right;\n    }\n\n    return [top, right, bottom, left];\n  },\n  directionEnabled: function directionEnabled(mode, dir) {\n    if (mode === undefined) {\n      return true;\n    } else if (typeof mode === 'string') {\n      return mode.indexOf(dir) !== -1;\n    }\n\n    return false;\n  }\n};\nUtil.Array = {\n  merge: function merge(dataArray) {\n    var rst = [];\n\n    for (var i = 0, len = dataArray.length; i < len; i++) {\n      rst = rst.concat(dataArray[i]);\n    }\n\n    return rst;\n  },\n  values: function values(data, name) {\n    var rst = [];\n    var tmpMap = {};\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var obj = data[i];\n      var value = obj[name];\n\n      if (!Util.isNil(value)) {\n        if (!Util.isArray(value)) {\n          if (!tmpMap[value]) {\n            rst.push(value);\n            tmpMap[value] = true;\n          }\n        } else {\n          Util.each(value, function (val) {\n            if (!tmpMap[val]) {\n              rst.push(val);\n              tmpMap[val] = true;\n            }\n          });\n        }\n      }\n    }\n\n    return rst;\n  },\n  firstValue: function firstValue(data, name) {\n    var rst = null;\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var obj = data[i];\n      var value = obj[name];\n\n      if (!Util.isNil(value)) {\n        if (Util.isArray(value)) {\n          rst = value[0];\n        } else {\n          rst = value;\n        }\n\n        break;\n      }\n    }\n\n    return rst;\n  },\n  group: function group(data, fields, appendConditions) {\n    if (appendConditions === void 0) {\n      appendConditions = {};\n    }\n\n    if (!fields) {\n      return [data];\n    }\n\n    var groups = Util.Array.groupToMap(data, fields);\n    var array = [];\n\n    if (fields.length === 1 && appendConditions[fields[0]]) {\n      var values = appendConditions[fields[0]];\n      Util.each(values, function (value) {\n        value = '_' + value;\n        array.push(groups[value]);\n      });\n    } else {\n      for (var i in groups) {\n        array.push(groups[i]);\n      }\n    }\n\n    return array;\n  },\n  groupToMap: function groupToMap(data, fields) {\n    if (!fields) {\n      return {\n        0: data\n      };\n    }\n\n    var callback = function callback(row) {\n      var unique = '_';\n\n      for (var i = 0, l = fields.length; i < l; i++) {\n        unique += row[fields[i]] && row[fields[i]].toString();\n      }\n\n      return unique;\n    };\n\n    var groups = {};\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var row = data[i];\n      var key = callback(row);\n\n      if (groups[key]) {\n        groups[key].push(row);\n      } else {\n        groups[key] = [row];\n      }\n    }\n\n    return groups;\n  },\n  remove: function remove(arr, obj) {\n    if (!arr) {\n      return;\n    }\n\n    var index = arr.indexOf(obj);\n\n    if (index !== -1) {\n      arr.splice(index, 1);\n    }\n  },\n  getRange: function getRange(values) {\n    if (!values.length) {\n      return {\n        min: 0,\n        max: 0\n      };\n    }\n\n    var max = Math.max.apply(null, values);\n    var min = Math.min.apply(null, values);\n    return {\n      min: min,\n      max: max\n    };\n  }\n};\nUtil.mix(Util, DomUtil);\nmodule.exports = Util;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Theme = __webpack_require__(46);\n\nvar Util = __webpack_require__(0);\n\nvar Global = {\n  version: '3.4.0',\n  scales: {},\n  widthRatio: {\n    column: 1 / 2,\n    rose: 0.999999,\n    multiplePie: 3 / 4\n  },\n  lineDash: [4, 4]\n};\n\nGlobal.setTheme = function (theme) {\n  Util.deepMix(this, theme);\n};\n\nGlobal.setTheme(Theme);\nmodule.exports = Global;\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Element = __webpack_require__(27);\n\nvar Shape =\n/*#__PURE__*/\nfunction (_Element) {\n  _inheritsLoose(Shape, _Element);\n\n  function Shape() {\n    return _Element.apply(this, arguments) || this;\n  }\n\n  var _proto = Shape.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    this._attrs = {\n      zIndex: 0,\n      visible: true,\n      destroyed: false,\n      isShape: true,\n      attrs: {}\n    };\n  };\n\n  _proto.getType = function getType() {\n    return this._attrs.type;\n  };\n\n  _proto.drawInner = function drawInner(context) {\n    var self = this;\n    var attrs = self.get('attrs');\n    self.createPath(context);\n    var originOpacity = context.globalAlpha;\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n        context.fill();\n        context.globalAlpha = originOpacity;\n      } else {\n        context.fill();\n      }\n    }\n\n    if (self.hasStroke()) {\n      var lineWidth = attrs.lineWidth;\n\n      if (lineWidth > 0) {\n        var strokeOpacity = attrs.strokeOpacity;\n\n        if (!Util.isNil(strokeOpacity) && strokeOpacity !== 1) {\n          context.globalAlpha = strokeOpacity;\n        }\n\n        context.stroke();\n      }\n    }\n  };\n\n  _proto.getBBox = function getBBox() {\n    var bbox = this._attrs.bbox;\n\n    if (!bbox) {\n      bbox = this.calculateBox();\n\n      if (bbox) {\n        bbox.x = bbox.minX;\n        bbox.y = bbox.minY;\n        bbox.width = bbox.maxX - bbox.minX;\n        bbox.height = bbox.maxY - bbox.minY;\n      }\n\n      this._attrs.bbox = bbox;\n    }\n\n    return bbox;\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    return null;\n  };\n\n  _proto.createPath = function createPath() {};\n\n  return Shape;\n}(Element);\n\nmodule.exports = Shape;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/**\n * 2 Dimensional Vector\n * @module vector2\n */\nmodule.exports = {\n  /**\n   * Creates a new, empty vector2\n   *\n   * @return {vector2} a new 2D vector\n   */\n  create: function create() {\n    return [0, 0];\n  },\n\n  /**\n   * Calculates the length of a vector2\n   *\n   * @param {vector2} v vector to calculate length of\n   * @return {Number} length of v\n   */\n  length: function length(v) {\n    var x = v[0];\n    var y = v[1];\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\n   * Normalize a vector2\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v vector to normalize\n   * @return {vector2} out\n   */\n  normalize: function normalize(out, v) {\n    var len = this.length(v);\n\n    if (len === 0) {\n      out[0] = 0;\n      out[1] = 0;\n    } else {\n      out[0] = v[0] / len;\n      out[1] = v[1] / len;\n    }\n\n    return out;\n  },\n\n  /**\n   * Adds two vector2's\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {vector2} out\n   */\n  add: function add(out, v1, v2) {\n    out[0] = v1[0] + v2[0];\n    out[1] = v1[1] + v2[1];\n    return out;\n  },\n\n  /**\n   * Subtracts vector v2 from vector v1\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {vector2} out\n   */\n  sub: function sub(out, v1, v2) {\n    out[0] = v1[0] - v2[0];\n    out[1] = v1[1] - v2[1];\n    return out;\n  },\n\n  /**\n   * Scales a vector2 by a scalar number\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v the vector to scale\n   * @param {Number} s amount to scale the vector by\n   * @return {vector2} out\n   */\n  scale: function scale(out, v, s) {\n    out[0] = v[0] * s;\n    out[1] = v[1] * s;\n    return out;\n  },\n\n  /**\n   * Calculates the dot product of two vector2's\n   *\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {Number} dot product of v1 and v2\n   */\n  dot: function dot(v1, v2) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n  },\n\n  /**\n   * Calculates the direction of two vector2's\n   *\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {Boolean} the direction of v1 and v2\n   */\n  direction: function direction(v1, v2) {\n    return v1[0] * v2[1] - v2[0] * v1[1];\n  },\n\n  /**\n   * Calculates the angle of two vector2's\n   *\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {Number} angle of v1 and v2\n   */\n  angle: function angle(v1, v2) {\n    var theta = this.dot(v1, v2) / (this.length(v1) * this.length(v2));\n    return Math.acos(theta);\n  },\n\n  /**\n   * Calculates the angle of two vector2's with direction\n   *\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @param {Boolean} direction the direction of two vector2's\n   * @return {Number} angle of v1 and v2\n   */\n  angleTo: function angleTo(v1, v2, direction) {\n    var angle = this.angle(v1, v2);\n    var angleLargeThanPI = this.direction(v1, v2) >= 0;\n\n    if (direction) {\n      if (angleLargeThanPI) {\n        return Math.PI * 2 - angle;\n      }\n\n      return angle;\n    }\n\n    if (angleLargeThanPI) {\n      return angle;\n    }\n\n    return Math.PI * 2 - angle;\n  },\n\n  /**\n   * whether a vector2 is zero vector\n   *\n   * @param  {vector2} v vector to calculate\n   * @return {Boolean}   is or not a zero vector\n   */\n  zero: function zero(v) {\n    return v[0] === 0 && v[1] === 0;\n  },\n\n  /**\n   * Calculates the euclidian distance between two vector2's\n   *\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {Number} distance between a and b\n   */\n  distance: function distance(v1, v2) {\n    var x = v2[0] - v1[0];\n    var y = v2[1] - v1[1];\n    return Math.sqrt(x * x + y * y);\n  },\n\n  /**\n   * Creates a new vector2 initialized with values from an existing vector\n   *\n   * @param {vector2} v vector to clone\n   * @return {Array} a new 2D vector\n   */\n  clone: function clone(v) {\n    return [v[0], v[1]];\n  },\n\n  /**\n   * Return the minimum of two vector2's\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {vector2} out\n   */\n  min: function min(out, v1, v2) {\n    out[0] = Math.min(v1[0], v2[0]);\n    out[1] = Math.min(v1[1], v2[1]);\n    return out;\n  },\n\n  /**\n   * Return the maximum of two vector2's\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v1 the first operand\n   * @param {vector2} v2 the second operand\n   * @return {vector2} out\n   */\n  max: function max(out, v1, v2) {\n    out[0] = Math.max(v1[0], v2[0]);\n    out[1] = Math.max(v1[1], v2[1]);\n    return out;\n  },\n\n  /**\n   * Transforms the vector2 with a mat2d\n   *\n   * @param {vector2} out the receiving vector\n   * @param {vector2} v the vector to transform\n   * @param {mat2d} m matrix to transform with\n   * @return {vector2} out\n   */\n  transformMat2d: function transformMat2d(out, v, m) {\n    var x = v[0];\n    var y = v[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n  }\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(25);\n\nvar isArray = __webpack_require__(13);\n\nvar each = function each(elements, func) {\n  if (!elements) {\n    return;\n  }\n\n  var rst = void 0;\n\n  if (isArray(elements)) {\n    for (var i = 0, len = elements.length; i < len; i++) {\n      rst = func(elements[i], i);\n\n      if (rst === false) {\n        break;\n      }\n    }\n  } else if (isObject(elements)) {\n    for (var k in elements) {\n      if (elements.hasOwnProperty(k)) {\n        rst = func(elements[k], k);\n\n        if (rst === false) {\n          break;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = each;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar G = {\n  Canvas: __webpack_require__(79),\n  Group: __webpack_require__(36),\n  Shape: __webpack_require__(2),\n  Matrix: __webpack_require__(24),\n  Vector2: __webpack_require__(3)\n};\n\n__webpack_require__(81);\n\n__webpack_require__(82);\n\n__webpack_require__(83);\n\n__webpack_require__(84);\n\n__webpack_require__(85);\n\n__webpack_require__(86);\n\n__webpack_require__(87);\n\n__webpack_require__(88);\n\n__webpack_require__(89);\n\nmodule.exports = G;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Base = __webpack_require__(34);\n\nvar GROUP_ATTRS = ['color', 'size', 'shape'];\nvar FIELD_ORIGIN = '_origin';\nvar FIELD_ORIGIN_Y = '_originY';\n\nvar Global = __webpack_require__(1);\n\nvar Attr = __webpack_require__(64);\n\nvar GeometryShape = __webpack_require__(8);\n\nvar Adjust = __webpack_require__(23);\n\nfunction parseFields(field) {\n  if (Util.isArray(field)) {\n    return field;\n  }\n\n  if (Util.isString(field)) {\n    return field.split('*');\n  }\n\n  return [field];\n}\n/**\n * The parent class for Geometry\n * @class Geom\n */\n\n\nvar Geom =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Geom, _Base);\n\n  function Geom() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Geom.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * geometry type\n       * @type {String}\n       */\n      type: null,\n\n      /**\n       * the data of geometry\n       * @type {Array}\n       */\n      data: null,\n\n      /**\n       * the attrs of geo,etry\n       * @type {Object}\n       */\n      attrs: {},\n      scales: {},\n\n      /**\n       * group for storing the shapes\n       * @type {Canvas}\n       */\n      container: null,\n\n      /**\n       * style options\n       * @type {Object}\n       */\n      styleOptions: null,\n      chart: null,\n      shapeType: '',\n\n      /**\n       * wether to generate key points for each shape\n       * @protected\n       * @type {Boolean}\n       */\n      generatePoints: false,\n      attrOptions: {},\n      sortable: false,\n      startOnZero: true,\n      visible: true,\n      connectNulls: false\n    };\n  };\n\n  _proto.init = function init() {\n    var self = this;\n\n    self._initAttrs();\n\n    var dataArray = self._processData();\n\n    if (self.get('adjust')) {\n      self._adjustData(dataArray);\n    }\n\n    self.set('dataArray', dataArray);\n  };\n\n  _proto._getGroupScales = function _getGroupScales() {\n    var self = this;\n    var scales = [];\n    Util.each(GROUP_ATTRS, function (attrName) {\n      var attr = self.getAttr(attrName);\n\n      if (attr) {\n        var attrScales = attr.scales;\n        Util.each(attrScales, function (scale) {\n          if (scale && scale.isCategory && scales.indexOf(scale) === -1) {\n            scales.push(scale);\n          }\n        });\n      }\n    });\n    return scales;\n  };\n\n  _proto._groupData = function _groupData(data) {\n    var self = this;\n    var colDefs = self.get('colDefs');\n\n    var groupScales = self._getGroupScales();\n\n    if (groupScales.length) {\n      var appendConditions = {};\n      var names = [];\n      Util.each(groupScales, function (scale) {\n        var field = scale.field;\n        names.push(field);\n\n        if (colDefs && colDefs[field] && colDefs[field].values) {\n          // users have defined\n          appendConditions[scale.field] = colDefs[field].values;\n        }\n      });\n      return Util.Array.group(data, names, appendConditions);\n    }\n\n    return [data];\n  };\n\n  _proto._setAttrOptions = function _setAttrOptions(attrName, attrCfg) {\n    var options = this.get('attrOptions');\n    options[attrName] = attrCfg;\n  };\n\n  _proto._createAttrOption = function _createAttrOption(attrName, field, cfg, defaultValues) {\n    var attrCfg = {};\n    attrCfg.field = field;\n\n    if (cfg) {\n      if (Util.isFunction(cfg)) {\n        attrCfg.callback = cfg;\n      } else {\n        attrCfg.values = cfg;\n      }\n    } else {\n      attrCfg.values = defaultValues;\n    }\n\n    this._setAttrOptions(attrName, attrCfg);\n  };\n\n  _proto._initAttrs = function _initAttrs() {\n    var self = this;\n    var attrs = self.get('attrs');\n    var attrOptions = self.get('attrOptions');\n    var coord = self.get('coord');\n\n    for (var type in attrOptions) {\n      if (attrOptions.hasOwnProperty(type)) {\n        var option = attrOptions[type];\n        var className = Util.upperFirst(type);\n        var fields = parseFields(option.field);\n\n        if (type === 'position') {\n          option.coord = coord;\n        }\n\n        var scales = [];\n\n        for (var i = 0, len = fields.length; i < len; i++) {\n          var field = fields[i];\n\n          var scale = self._createScale(field);\n\n          scales.push(scale);\n        }\n\n        if (type === 'position') {\n          var yScale = scales[1];\n\n          if (coord.type === 'polar' && coord.transposed && self.hasAdjust('stack')) {\n            if (yScale.values.length) {\n              yScale.change({\n                nice: false,\n                min: 0,\n                max: Math.max.apply(null, yScale.values)\n              });\n            }\n          }\n        }\n\n        option.scales = scales;\n        var attr = new Attr[className](option);\n        attrs[type] = attr;\n      }\n    }\n  };\n\n  _proto._createScale = function _createScale(field) {\n    var scales = this.get('scales');\n    var scale = scales[field];\n\n    if (!scale) {\n      scale = this.get('chart').createScale(field);\n      scales[field] = scale;\n    }\n\n    return scale;\n  };\n\n  _proto._processData = function _processData() {\n    var self = this;\n    var data = this.get('data');\n    var dataArray = [];\n\n    var groupedArray = this._groupData(data);\n\n    for (var i = 0, len = groupedArray.length; i < len; i++) {\n      var subData = groupedArray[i];\n\n      var tempData = self._saveOrigin(subData);\n\n      if (this.hasAdjust('dodge')) {\n        self._numberic(tempData);\n      }\n\n      dataArray.push(tempData);\n    }\n\n    return dataArray;\n  };\n\n  _proto._saveOrigin = function _saveOrigin(data) {\n    var rst = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var origin = data[i];\n      var obj = {};\n\n      for (var k in origin) {\n        obj[k] = origin[k];\n      }\n\n      obj[FIELD_ORIGIN] = origin;\n      rst.push(obj);\n    }\n\n    return rst;\n  };\n\n  _proto._numberic = function _numberic(data) {\n    var positionAttr = this.getAttr('position');\n    var scales = positionAttr.scales;\n\n    for (var j = 0, len = data.length; j < len; j++) {\n      var obj = data[j];\n      var count = Math.min(2, scales.length);\n\n      for (var i = 0; i < count; i++) {\n        var scale = scales[i];\n\n        if (scale.isCategory) {\n          var field = scale.field;\n          obj[field] = scale.translate(obj[field]);\n        }\n      }\n    }\n  };\n\n  _proto._adjustData = function _adjustData(dataArray) {\n    var self = this;\n    var adjust = self.get('adjust');\n\n    if (adjust) {\n      var adjustType = Util.upperFirst(adjust.type);\n\n      if (!Adjust[adjustType]) {\n        throw new Error('not support such adjust : ' + adjust);\n      }\n\n      var xScale = self.getXScale();\n      var yScale = self.getYScale();\n      var cfg = Util.mix({\n        xField: xScale.field,\n        yField: yScale.field\n      }, adjust);\n      var adjustObject = new Adjust[adjustType](cfg);\n      adjustObject.processAdjust(dataArray);\n\n      if (adjustType === 'Stack') {\n        self._updateStackRange(yScale.field, yScale, dataArray);\n      }\n    }\n  };\n\n  _proto._updateStackRange = function _updateStackRange(field, scale, dataArray) {\n    var mergeArray = Util.Array.merge(dataArray);\n    var min = scale.min;\n    var max = scale.max;\n\n    for (var i = 0, len = mergeArray.length; i < len; i++) {\n      var obj = mergeArray[i];\n      var tmpMin = Math.min.apply(null, obj[field]);\n      var tmpMax = Math.max.apply(null, obj[field]);\n\n      if (tmpMin < min) {\n        min = tmpMin;\n      }\n\n      if (tmpMax > max) {\n        max = tmpMax;\n      }\n    }\n\n    if (min < scale.min || max > scale.max) {\n      scale.change({\n        min: min,\n        max: max\n      });\n    }\n  };\n\n  _proto._sort = function _sort(mappedArray) {\n    var self = this;\n    var xScale = self.getXScale();\n    var field = xScale.field,\n        type = xScale.type;\n\n    if (type !== 'identity' && xScale.values.length > 1) {\n      Util.each(mappedArray, function (itemArr) {\n        itemArr.sort(function (obj1, obj2) {\n          if (type === 'timeCat') {\n            return xScale._toTimeStamp(obj1[FIELD_ORIGIN][field]) - xScale._toTimeStamp(obj2[FIELD_ORIGIN][field]);\n          }\n\n          return xScale.translate(obj1[FIELD_ORIGIN][field]) - xScale.translate(obj2[FIELD_ORIGIN][field]);\n        });\n      });\n    }\n\n    self.set('hasSorted', true);\n    self.set('dataArray', mappedArray);\n  };\n\n  _proto.paint = function paint() {\n    var self = this;\n    var dataArray = self.get('dataArray');\n    var mappedArray = [];\n    var shapeFactory = self.getShapeFactory();\n    shapeFactory.setCoord(self.get('coord'));\n\n    self._beforeMapping(dataArray);\n\n    for (var i = 0, len = dataArray.length; i < len; i++) {\n      var data = dataArray[i];\n\n      if (data.length) {\n        data = self._mapping(data);\n        mappedArray.push(data);\n        self.draw(data, shapeFactory);\n      }\n    }\n\n    self.set('dataArray', mappedArray);\n  };\n\n  _proto.getShapeFactory = function getShapeFactory() {\n    var shapeFactory = this.get('shapeFactory');\n\n    if (!shapeFactory) {\n      var shapeType = this.get('shapeType');\n      shapeFactory = GeometryShape.getShapeFactory(shapeType);\n      this.set('shapeFactory', shapeFactory);\n    }\n\n    return shapeFactory;\n  };\n\n  _proto._mapping = function _mapping(data) {\n    var self = this;\n    var attrs = self.get('attrs');\n    var yField = self.getYScale().field;\n    var mappedData = [];\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var record = data[i];\n      var newRecord = {};\n      newRecord[FIELD_ORIGIN] = record[FIELD_ORIGIN];\n      newRecord.points = record.points; // 避免\n\n      newRecord[FIELD_ORIGIN_Y] = record[yField];\n\n      for (var k in attrs) {\n        if (attrs.hasOwnProperty(k)) {\n          var attr = attrs[k];\n          var names = attr.names;\n\n          var values = self._getAttrValues(attr, record);\n\n          if (names.length > 1) {\n            for (var j = 0, _len = values.length; j < _len; j++) {\n              var val = values[j];\n              var name = names[j];\n              newRecord[name] = Util.isArray(val) && val.length === 1 ? val[0] : val;\n            }\n          } else {\n            newRecord[names[0]] = values.length === 1 ? values[0] : values;\n          }\n        }\n      }\n\n      mappedData.push(newRecord);\n    }\n\n    return mappedData;\n  };\n\n  _proto._getAttrValues = function _getAttrValues(attr, record) {\n    var scales = attr.scales;\n    var params = [];\n\n    for (var i = 0, len = scales.length; i < len; i++) {\n      var scale = scales[i];\n      var field = scale.field;\n\n      if (scale.type === 'identity') {\n        params.push(scale.value);\n      } else {\n        params.push(record[field]);\n      }\n    }\n\n    var values = attr.mapping.apply(attr, params);\n    return values;\n  };\n\n  _proto.getAttrValue = function getAttrValue(attrName, record) {\n    var attr = this.getAttr(attrName);\n    var rst = null;\n\n    if (attr) {\n      var values = this._getAttrValues(attr, record);\n\n      rst = values[0];\n    }\n\n    return rst;\n  };\n\n  _proto._beforeMapping = function _beforeMapping(dataArray) {\n    var self = this;\n\n    if (self.get('sortable')) {\n      self._sort(dataArray);\n    }\n\n    if (self.get('generatePoints')) {\n      Util.each(dataArray, function (data) {\n        self._generatePoints(data);\n      });\n    }\n  };\n\n  _proto.isInCircle = function isInCircle() {\n    var coord = this.get('coord');\n    return coord && coord.isPolar;\n  };\n\n  _proto.getCallbackCfg = function getCallbackCfg(fields, cfg, origin) {\n    if (!fields) {\n      return cfg;\n    }\n\n    var tmpCfg = {};\n    var params = fields.map(function (field) {\n      return origin[field];\n    });\n    Util.each(cfg, function (v, k) {\n      if (Util.isFunction(v)) {\n        tmpCfg[k] = v.apply(null, params);\n      } else {\n        tmpCfg[k] = v;\n      }\n    });\n    return tmpCfg;\n  };\n\n  _proto.getDrawCfg = function getDrawCfg(obj) {\n    var self = this;\n    var isInCircle = self.isInCircle();\n    var cfg = {\n      origin: obj,\n      x: obj.x,\n      y: obj.y,\n      color: obj.color,\n      size: obj.size,\n      shape: obj.shape,\n      isInCircle: isInCircle,\n      opacity: obj.opacity\n    };\n    var styleOptions = self.get('styleOptions');\n\n    if (styleOptions && styleOptions.style) {\n      cfg.style = self.getCallbackCfg(styleOptions.fields, styleOptions.style, obj[FIELD_ORIGIN]);\n    }\n\n    if (self.get('generatePoints')) {\n      cfg.points = obj.points;\n    }\n\n    if (isInCircle) {\n      cfg.center = self.get('coord').center;\n    }\n\n    return cfg;\n  };\n\n  _proto.draw = function draw(data, shapeFactory) {\n    var self = this;\n    var container = self.get('container');\n    var yScale = self.getYScale();\n    Util.each(data, function (obj, index) {\n      if (yScale && Util.isNil(obj._origin[yScale.field])) {\n        return;\n      }\n\n      obj.index = index;\n      var cfg = self.getDrawCfg(obj);\n      var shape = obj.shape;\n      self.drawShape(shape, obj, cfg, container, shapeFactory);\n    });\n  };\n\n  _proto.drawShape = function drawShape(shape, shapeData, cfg, container, shapeFactory) {\n    var gShape = shapeFactory.drawShape(shape, cfg, container);\n\n    if (gShape) {\n      Util.each([].concat(gShape), function (s) {\n        s.set('origin', shapeData);\n      });\n    }\n  };\n\n  _proto._generatePoints = function _generatePoints(data) {\n    var self = this;\n    var shapeFactory = self.getShapeFactory();\n    var shapeAttr = self.getAttr('shape');\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var obj = data[i];\n      var cfg = self.createShapePointsCfg(obj);\n      var shape = shapeAttr ? self._getAttrValues(shapeAttr, obj) : null;\n      var points = shapeFactory.getShapePoints(shape, cfg);\n      obj.points = points;\n    }\n  }\n  /**\n   * get the info of each shape\n   * @protected\n   * @param  {Object} obj the data item\n   * @return {Object} cfg return the result\n   */\n  ;\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var xScale = this.getXScale();\n    var yScale = this.getYScale();\n\n    var x = this._normalizeValues(obj[xScale.field], xScale);\n\n    var y;\n\n    if (yScale) {\n      y = this._normalizeValues(obj[yScale.field], yScale);\n    } else {\n      y = obj.y ? obj.y : 0.1;\n    }\n\n    return {\n      x: x,\n      y: y,\n      y0: yScale ? yScale.scale(this.getYMinValue()) : undefined\n    };\n  };\n\n  _proto.getYMinValue = function getYMinValue() {\n    var yScale = this.getYScale();\n    var min = yScale.min,\n        max = yScale.max;\n    var value;\n\n    if (this.get('startOnZero')) {\n      if (max <= 0 && min <= 0) {\n        value = max;\n      } else {\n        value = min >= 0 ? min : 0;\n      }\n    } else {\n      value = min;\n    }\n\n    return value;\n  };\n\n  _proto._normalizeValues = function _normalizeValues(values, scale) {\n    var rst = [];\n\n    if (Util.isArray(values)) {\n      for (var i = 0, len = values.length; i < len; i++) {\n        var v = values[i];\n        rst.push(scale.scale(v));\n      }\n    } else {\n      rst = scale.scale(values);\n    }\n\n    return rst;\n  };\n\n  _proto.getAttr = function getAttr(name) {\n    return this.get('attrs')[name];\n  };\n\n  _proto.getXScale = function getXScale() {\n    return this.getAttr('position').scales[0];\n  };\n\n  _proto.getYScale = function getYScale() {\n    return this.getAttr('position').scales[1];\n  };\n\n  _proto.hasAdjust = function hasAdjust(adjust) {\n    return this.get('adjust') && this.get('adjust').type === adjust;\n  };\n\n  _proto._getSnap = function _getSnap(scale, item, arr) {\n    var i = 0;\n    var values;\n    var yField = this.getYScale().field; // 叠加的维度\n\n    if (this.hasAdjust('stack') && scale.field === yField) {\n      values = [];\n      arr.forEach(function (obj) {\n        values.push(obj[FIELD_ORIGIN_Y]);\n      });\n\n      for (var len = values.length; i < len; i++) {\n        if (values[0][0] > item) {\n          break;\n        }\n\n        if (values[values.length - 1][1] <= item) {\n          i = values.length - 1;\n          break;\n        }\n\n        if (values[i][0] <= item && values[i][1] > item) {\n          break;\n        }\n      }\n    } else {\n      values = scale.values;\n      values.sort(function (a, b) {\n        return a - b;\n      });\n\n      for (var _len2 = values.length; i < _len2; i++) {\n        if ((values[0] + values[1]) / 2 > item) {\n          break;\n        }\n\n        if ((values[i - 1] + values[i]) / 2 <= item && (values[i + 1] + values[i]) / 2 > item) {\n          break;\n        }\n\n        if ((values[values.length - 2] + values[values.length - 1]) / 2 <= item) {\n          i = values.length - 1;\n          break;\n        }\n      }\n    }\n\n    var result = values[i];\n    return result;\n  };\n\n  _proto.getSnapRecords = function getSnapRecords(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var xScale = self.getXScale();\n    var yScale = self.getYScale();\n    var xfield = xScale.field;\n    var dataArray = self.get('dataArray');\n\n    if (!this.get('hasSorted')) {\n      this._sort(dataArray);\n    }\n\n    var rst = [];\n    var invertPoint = coord.invertPoint(point);\n    var invertPointX = invertPoint.x;\n\n    if (self.isInCircle() && !coord.transposed && invertPointX > (1 + xScale.rangeMax()) / 2) {\n      invertPointX = xScale.rangeMin();\n    }\n\n    var xValue = xScale.invert(invertPointX);\n\n    if (!xScale.isCategory) {\n      xValue = self._getSnap(xScale, xValue);\n    }\n\n    var tmp = [];\n    dataArray.forEach(function (data) {\n      data.forEach(function (obj) {\n        var originValue = Util.isNil(obj[FIELD_ORIGIN]) ? obj[xfield] : obj[FIELD_ORIGIN][xfield];\n\n        if (self._isEqual(originValue, xValue, xScale)) {\n          tmp.push(obj);\n        }\n      });\n    }); // special for pie chart\n\n    if (this.hasAdjust('stack') && coord.isPolar && coord.transposed && xScale.values.length === 1) {\n      if (invertPointX >= 0 && invertPointX <= 1) {\n        var yValue = yScale.invert(invertPoint.y);\n        yValue = self._getSnap(yScale, yValue, tmp);\n        tmp.forEach(function (obj) {\n          if (Util.isArray(yValue) ? obj[FIELD_ORIGIN_Y].toString() === yValue.toString() : obj[FIELD_ORIGIN_Y] === yValue) {\n            rst.push(obj);\n          }\n        });\n      }\n    } else {\n      rst = tmp;\n    }\n\n    return rst;\n  };\n\n  _proto._isEqual = function _isEqual(originValue, value, scale) {\n    if (scale.type === 'timeCat') {\n      return scale._toTimeStamp(originValue) === value;\n    }\n\n    return value === originValue;\n  };\n\n  _proto.position = function position(field) {\n    this._setAttrOptions('position', {\n      field: field\n    });\n\n    return this;\n  };\n\n  _proto.color = function color(field, values) {\n    this._createAttrOption('color', field, values, Global.colors);\n\n    return this;\n  };\n\n  _proto.size = function size(field, values) {\n    this._createAttrOption('size', field, values, Global.sizes);\n\n    return this;\n  };\n\n  _proto.shape = function shape(field, values) {\n    var type = this.get('type');\n    var shapes = Global.shapes[type] || [];\n\n    this._createAttrOption('shape', field, values, shapes);\n\n    return this;\n  };\n\n  _proto.style = function style(field, cfg) {\n    var styleOptions = this.get('styleOptions');\n\n    if (!styleOptions) {\n      styleOptions = {};\n      this.set('styleOptions', styleOptions);\n    }\n\n    if (Util.isObject(field)) {\n      cfg = field;\n      field = null;\n    }\n\n    var fields;\n\n    if (field) {\n      fields = parseFields(field);\n    }\n\n    styleOptions.fields = fields;\n    styleOptions.style = cfg;\n    return this;\n  };\n\n  _proto.adjust = function adjust(type) {\n    if (Util.isString(type)) {\n      type = {\n        type: type\n      };\n    }\n\n    this.set('adjust', type);\n    return this;\n  };\n\n  _proto.animate = function animate(cfg) {\n    this.set('animateCfg', cfg);\n    return this;\n  };\n\n  _proto.reset = function reset() {\n    this.set('attrOptions', {});\n    this.set('adjust', null);\n    this.clearInner();\n  };\n\n  _proto.clearInner = function clearInner() {\n    var container = this.get('container');\n\n    if (container) {\n      container.clear();\n      container.setMatrix([1, 0, 0, 1, 0, 0]);\n    }\n\n    container && container.clear();\n    this.set('attrs', {});\n    this.set('groupScales', null);\n    this.set('xDistance', null);\n    this.set('_width', null);\n  };\n\n  _proto.clear = function clear() {\n    this.clearInner();\n    this.set('scales', {});\n  };\n\n  _proto.destroy = function destroy() {\n    this.clear();\n\n    _Base.prototype.destroy.call(this);\n  };\n\n  _proto._display = function _display(visible) {\n    this.set('visible', visible);\n    var container = this.get('container');\n    var canvas = container.get('canvas');\n    container.set('visible', visible);\n    canvas.draw();\n  };\n\n  _proto.show = function show() {\n    this._display(true);\n  };\n\n  _proto.hide = function hide() {\n    this._display(false);\n  };\n\n  return Geom;\n}(Base);\n\nmodule.exports = Geom;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nvar isType = function isType(value, type) {\n  return toString.call(value) === '[object ' + type + ']';\n};\n\nmodule.exports = isType;\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(1);\n\nvar Shape = {};\nvar ShapeBase = {\n  _coord: null,\n\n  /**\n   * draw the shape\n   * @param {Object} cfg options\n   * @param {Object} container container to store the shapes\n   */\n  draw: function draw(cfg, container) {\n    if (this.drawShape) {\n      this.drawShape(cfg, container);\n    }\n  },\n\n  /**\n   * set the coordinate instance\n   * @param {Coord} coord coordinate instance\n   */\n  setCoord: function setCoord(coord) {\n    this._coord = coord;\n  },\n\n  /**\n   * convert the normalized value to the canvas position\n   * @param  {point} point the point to convert\n   * @return {point} point return the result\n   */\n  parsePoint: function parsePoint(point) {\n    var coord = this._coord;\n\n    if (coord.isPolar) {\n      if (point.x === 1) point.x = 0.9999999;\n      if (point.y === 1) point.y = 0.9999999;\n    }\n\n    return coord.convertPoint(point);\n  },\n\n  /**\n   * convert the normalized value to the canvas position\n   * @param  {points} points the array that store the points\n   * @return {points} points return the result\n   */\n  parsePoints: function parsePoints(points) {\n    if (!points) return false;\n    var self = this;\n    var rst = [];\n    points.forEach(function (point) {\n      rst.push(self.parsePoint(point));\n    });\n    return rst;\n  }\n};\nvar ShapeFactoryBase = {\n  defaultShapeType: null,\n  setCoord: function setCoord(coord) {\n    this._coord = coord;\n  },\n  getShape: function getShape(type) {\n    var self = this;\n\n    if (Util.isArray(type)) {\n      type = type[0];\n    }\n\n    var shape = self[type] || self[self.defaultShapeType];\n    shape._coord = self._coord;\n    return shape;\n  },\n  getShapePoints: function getShapePoints(type, cfg) {\n    var shape = this.getShape(type);\n    var fn = shape.getPoints || shape.getShapePoints || this.getDefaultPoints;\n    var points = fn(cfg);\n    return points;\n  },\n  getDefaultPoints: function getDefaultPoints()\n  /* cfg */\n  {\n    return [];\n  },\n  drawShape: function drawShape(type, cfg, container) {\n    var shape = this.getShape(type);\n\n    if (!cfg.color) {\n      cfg.color = Global.colors[0];\n    }\n\n    return shape.draw(cfg, container);\n  }\n};\n\nShape.registerFactory = function (factoryName, cfg) {\n  var className = Util.upperFirst(factoryName);\n  var geomObj = Util.mix({}, ShapeFactoryBase, cfg);\n  Shape[className] = geomObj;\n  geomObj.name = factoryName;\n  return geomObj;\n};\n\nShape.registerShape = function (factoryName, shapeType, cfg) {\n  var className = Util.upperFirst(factoryName);\n  var factory = Shape[className];\n  var shapeObj = Util.mix({}, ShapeBase, cfg);\n  factory[shapeType] = shapeObj;\n  return shapeObj;\n};\n\nShape.registShape = Shape.registerShape;\n\nShape.getShapeFactory = function (factoryName) {\n  var self = this;\n  factoryName = factoryName || 'point';\n  var className = Util.upperFirst(factoryName);\n  return self[className];\n};\n\nmodule.exports = Shape;\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports) {\n\n// isFinite,\nvar isNil = function isNil(value) {\n  /**\n   * isNil(null) => true\n   * isNil() => true\n   */\n  return value === null || value === undefined;\n};\n\nmodule.exports = isNil;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Vector2 = __webpack_require__(3);\n\nvar start = Vector2.create();\nvar end = Vector2.create();\nvar extremity = Vector2.create();\n\nfunction getCubicBezierXYatT(startPt, controlPt1, controlPt2, endPt, T) {\n  var x = CubicN(T, startPt.x, controlPt1.x, controlPt2.x, endPt.x);\n  var y = CubicN(T, startPt.y, controlPt1.y, controlPt2.y, endPt.y);\n  return {\n    x: x,\n    y: y\n  };\n} // cubic helper formula at T distance\n\n\nfunction CubicN(T, a, b, c, d) {\n  var t2 = T * T;\n  var t3 = t2 * T;\n  return a + (-a * 3 + T * (3 * a - a * T)) * T + (3 * b + T * (-6 * b + b * 3 * T)) * T + (c * 3 - c * 3 * T) * t2 + d * t3;\n}\n\nfunction cubicBezierBounds(c) {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n  var s = {\n    x: c[0],\n    y: c[1]\n  };\n  var c1 = {\n    x: c[2],\n    y: c[3]\n  };\n  var c2 = {\n    x: c[4],\n    y: c[5]\n  };\n  var e = {\n    x: c[6],\n    y: c[7]\n  };\n\n  for (var t = 0; t < 100; t++) {\n    var pt = getCubicBezierXYatT(s, c1, c2, e, t / 100);\n\n    if (pt.x < minX) {\n      minX = pt.x;\n    }\n\n    if (pt.x > maxX) {\n      maxX = pt.x;\n    }\n\n    if (pt.y < minY) {\n      minY = pt.y;\n    }\n\n    if (pt.y > maxY) {\n      maxY = pt.y;\n    }\n  }\n\n  return {\n    minX: minX,\n    minY: minY,\n    maxX: maxX,\n    maxY: maxY\n  };\n}\n\nmodule.exports = {\n  getBBoxFromPoints: function getBBoxFromPoints(points, lineWidth) {\n    if (points.length === 0) {\n      return;\n    }\n\n    var p = points[0];\n    var left = p.x;\n    var right = p.x;\n    var top = p.y;\n    var bottom = p.y;\n    var len = points.length;\n\n    for (var i = 1; i < len; i++) {\n      p = points[i];\n      left = Math.min(left, p.x);\n      right = Math.max(right, p.x);\n      top = Math.min(top, p.y);\n      bottom = Math.max(bottom, p.y);\n    }\n\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: left - lineWidth,\n      minY: top - lineWidth,\n      maxX: right + lineWidth,\n      maxY: bottom + lineWidth\n    };\n  },\n  getBBoxFromLine: function getBBoxFromLine(x0, y0, x1, y1, lineWidth) {\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: Math.min(x0, x1) - lineWidth,\n      minY: Math.min(y0, y1) - lineWidth,\n      maxX: Math.max(x0, x1) + lineWidth,\n      maxY: Math.max(y0, y1) + lineWidth\n    };\n  },\n  getBBoxFromArc: function getBBoxFromArc(x, y, r, startAngle, endAngle, anticlockwise) {\n    var diff = Math.abs(startAngle - endAngle);\n\n    if (diff % (Math.PI * 2) < 1e-4 && diff > 1e-4) {\n      // Is a circle\n      return {\n        minX: x - r,\n        minY: y - r,\n        maxX: x + r,\n        maxY: y + r\n      };\n    }\n\n    start[0] = Math.cos(startAngle) * r + x;\n    start[1] = Math.sin(startAngle) * r + y;\n    end[0] = Math.cos(endAngle) * r + x;\n    end[1] = Math.sin(endAngle) * r + y;\n    var min = [0, 0];\n    var max = [0, 0];\n    Vector2.min(min, start, end);\n    Vector2.max(max, start, end); // Thresh to [0, Math.PI * 2]\n\n    startAngle = startAngle % (Math.PI * 2);\n\n    if (startAngle < 0) {\n      startAngle = startAngle + Math.PI * 2;\n    }\n\n    endAngle = endAngle % (Math.PI * 2);\n\n    if (endAngle < 0) {\n      endAngle = endAngle + Math.PI * 2;\n    }\n\n    if (startAngle > endAngle && !anticlockwise) {\n      endAngle += Math.PI * 2;\n    } else if (startAngle < endAngle && anticlockwise) {\n      startAngle += Math.PI * 2;\n    }\n\n    if (anticlockwise) {\n      var tmp = endAngle;\n      endAngle = startAngle;\n      startAngle = tmp;\n    }\n\n    for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {\n      if (angle > startAngle) {\n        extremity[0] = Math.cos(angle) * r + x;\n        extremity[1] = Math.sin(angle) * r + y;\n        Vector2.min(min, extremity, min);\n        Vector2.max(max, extremity, max);\n      }\n    }\n\n    return {\n      minX: min[0],\n      minY: min[1],\n      maxX: max[0],\n      maxY: max[1]\n    };\n  },\n  getBBoxFromBezierGroup: function getBBoxFromBezierGroup(points, lineWidth) {\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var bbox = cubicBezierBounds(points[i]);\n\n      if (bbox.minX < minX) {\n        minX = bbox.minX;\n      }\n\n      if (bbox.maxX > maxX) {\n        maxX = bbox.maxX;\n      }\n\n      if (bbox.minY < minY) {\n        minY = bbox.minY;\n      }\n\n      if (bbox.maxY > maxY) {\n        maxY = bbox.maxY;\n      }\n    }\n\n    lineWidth = lineWidth / 2 || 0;\n    return {\n      minX: minX - lineWidth,\n      minY: minY - lineWidth,\n      maxX: maxX + lineWidth,\n      maxY: maxY + lineWidth\n    };\n  }\n};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar KEYWORDS_PERCENT = {\n  min: 0,\n  median: 0.5,\n  max: 1\n};\n\nvar GuideBase =\n/*#__PURE__*/\nfunction () {\n  var _proto = GuideBase.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {};\n\n  function GuideBase(cfg) {\n    this._initDefaultCfg();\n\n    Util.deepMix(this, cfg);\n  }\n\n  _proto._getNormalizedValue = function _getNormalizedValue(val, scale) {\n    var rst;\n\n    if (Util.isNil(KEYWORDS_PERCENT[val])) {\n      rst = scale.scale(val);\n    } else {\n      rst = KEYWORDS_PERCENT[val];\n    }\n\n    return rst;\n  };\n\n  _proto.parsePercentPoint = function parsePercentPoint(coord, position) {\n    var xPercent = parseFloat(position[0]) / 100;\n    var yPercent = parseFloat(position[1]) / 100;\n    var start = coord.start;\n    var end = coord.end;\n    var width = Math.abs(start.x - end.x);\n    var height = Math.abs(start.y - end.y);\n    var x = width * xPercent + Math.min(start.x, end.x);\n    var y = height * yPercent + Math.min(start.y, end.y);\n    return {\n      x: x,\n      y: y\n    };\n  };\n\n  _proto.parsePoint = function parsePoint(coord, position) {\n    var self = this;\n    var xScale = self.xScale;\n    var yScales = self.yScales;\n\n    if (Util.isFunction(position)) {\n      position = position(xScale, yScales); // position 必须是对象\n    } // 如果数据格式是 ['50%', '50%'] 的格式\n\n\n    if (Util.isString(position[0]) && position[0].indexOf('%') !== -1) {\n      return this.parsePercentPoint(coord, position);\n    }\n\n    var x = self._getNormalizedValue(position[0], xScale);\n\n    var y = self._getNormalizedValue(position[1], yScales[0]);\n\n    var point = coord.convertPoint({\n      x: x,\n      y: y\n    });\n\n    if (self.limitInPlot) {\n      // limit in chart plotRange\n      if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\n        return point;\n      }\n\n      return null;\n    }\n\n    return point;\n  }\n  /**\n   * render the guide component\n   * @param  {Coord} coord  coordinate instance\n   * @param  {Canvas.Group} group the container\n   */\n  ;\n\n  _proto.render = function render()\n  /* coord,group */\n  {};\n\n  _proto.repaint = function repaint() {\n    this.remove();\n    var coord = this.coord,\n        container = this.container,\n        canvas = this.canvas;\n\n    if (container && !container.isDestroyed()) {\n      this.render(coord, container);\n      canvas.draw();\n    }\n  };\n\n  _proto.remove = function remove() {\n    var element = this.element;\n    element && element.remove(true);\n  };\n\n  _proto.changeVisible = function changeVisible(visible) {\n    var self = this;\n    self.visible = visible;\n    var element = self.element;\n    if (!element) return;\n\n    if (element.set) {\n      element.set('visible', visible);\n    } else {\n      element.style.display = visible ? '' : 'none';\n    }\n  };\n\n  return GuideBase;\n}();\n\nmodule.exports = GuideBase;\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mix = __webpack_require__(22);\n\nvar each = __webpack_require__(4);\n\nvar isObject = __webpack_require__(25);\n\nvar isNil = __webpack_require__(9);\n\nvar Scale =\n/*#__PURE__*/\nfunction () {\n  var _proto = Scale.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'base';\n    /**\n     * 格式化函数,输出文本或者tick时的格式化函数\n     * @type {Function}\n     */\n\n    this.formatter = null;\n    /**\n     * 输出的值域\n     * @type {Array}\n     */\n\n    this.range = [0, 1];\n    /**\n     * 度量的标记\n     * @type {Array}\n     */\n\n    this.ticks = null;\n    /**\n     * 参与度量计算的值，可选项\n     * @type {Array}\n     */\n\n    this.values = [];\n  };\n\n  function Scale(cfg) {\n    this._initDefaultCfg();\n\n    mix(this, cfg);\n    this.init();\n  }\n  /**\n   * 度量初始化\n   * @protected\n   */\n\n\n  _proto.init = function init() {}\n  /**\n   * 获取该度量的ticks,返回的是多个对象，\n   *   - text: tick 的文本\n   *   - value: 对应的度量转换后的值\n   * <code>\n   *   [\n   *     {text: 0,value:0}\n   *     {text: 1,value:0.2}\n   *     {text: 2,value:0.4}\n   *     {text: 3,value:0.6}\n   *     {text: 4,value:0.8}\n   *     {text: 5,value:1}\n   *   ]\n   * </code>\n   * @param {Number} count 输出tick的个数的近似值，默认是 10\n   * @return {Array} 返回 ticks 数组\n   */\n  ;\n\n  _proto.getTicks = function getTicks() {\n    var self = this;\n    var ticks = self.ticks;\n    var rst = [];\n    each(ticks, function (tick) {\n      var obj;\n\n      if (isObject(tick)) {\n        obj = tick;\n      } else {\n        obj = {\n          text: self.getText(tick),\n          tickValue: tick,\n          value: self.scale(tick)\n        };\n      }\n\n      rst.push(obj);\n    });\n    return rst;\n  }\n  /**\n   * 获取格式化后的文本\n   * @param  {*} value 输入的数据\n   * @param  {*} key 字段的 key\n   * @return {String} 格式化的文本\n   */\n  ;\n\n  _proto.getText = function getText(value, key) {\n    var formatter = this.formatter;\n    value = formatter ? formatter(value, key) : value;\n\n    if (isNil(value) || !value.toString) {\n      value = '';\n    }\n\n    return value.toString();\n  }\n  /**\n   * 输出的值域最小值\n   * @protected\n   * @return {Number} 返回最小的值\n   */\n  ;\n\n  _proto.rangeMin = function rangeMin() {\n    return this.range[0];\n  }\n  /**\n   * 输出的值域最大值\n   * @protected\n   * @return {Number} 返回最大的值\n   */\n  ;\n\n  _proto.rangeMax = function rangeMax() {\n    var range = this.range;\n    return range[range.length - 1];\n  }\n  /**\n   * 度量转换后的结果，翻转回输入域\n   * @param  {Number} value 需要翻转的数值\n   * @return {*} 度量的输入值\n   */\n  ;\n\n  _proto.invert = function invert(value) {\n    return value;\n  }\n  /**\n   * 将传入的值从非数值转换成数值格式，如分类字符串、时间字符串等\n   * @param  {*} value 传入的值\n   * @return {Number} 转换的值\n   */\n  ;\n\n  _proto.translate = function translate(value) {\n    return value;\n  }\n  /**\n   * 进行度量转换\n   * @param  {*} value 输入值\n   * @return {Number} 输出值，在设定的输出值域之间，默认[0,1]\n   */\n  ;\n\n  _proto.scale = function scale(value) {\n    return value;\n  }\n  /**\n   * 克隆一个新的scale,拥有跟当前scale相同的输入域、输出域等\n   * @return {Scale} 克隆的度量\n   */\n  ;\n\n  _proto.clone = function clone() {\n    var self = this;\n    var constr = self.constructor;\n    var cfg = {};\n    each(self, function (v, k) {\n      cfg[k] = self[k];\n    });\n    return new constr(cfg);\n  }\n  /**\n   * 更改度量的属性信息\n   * @param  {Object} info 属性信息\n   * @chainable\n   * @return {Scale} 返回自身的引用\n   */\n  ;\n\n  _proto.change = function change(info) {\n    this.ticks = null;\n    mix(this, info);\n    this.init();\n    return this;\n  };\n\n  return Scale;\n}();\n\nmodule.exports = Scale;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(16);\n\nvar isArray = Array.isArray ? Array.isArray : function (value) {\n  return isType(value, 'Array');\n};\nmodule.exports = isArray;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview the Attribute base class\n */\nvar isString = __webpack_require__(18);\n\nvar isArray = __webpack_require__(13);\n\nvar isNil = __webpack_require__(9);\n\nvar mix = __webpack_require__(22);\n\nvar each = __webpack_require__(4);\n\nfunction toScaleString(scale, value) {\n  if (isString(value)) {\n    return value;\n  }\n\n  return scale.invert(scale.scale(value));\n}\n/**\n * 所有视觉通道属性的基类\n * @class Attr\n */\n\n\nvar AttributeBase =\n/*#__PURE__*/\nfunction () {\n  function AttributeBase(cfg) {\n    var _this = this;\n    /**\n     * 属性的类型\n     * @type {String}\n     */\n\n\n    this.type = 'base';\n    /**\n     * 属性的名称\n     * @type {String}\n     */\n\n    this.name = null;\n    /**\n     * 回调函数\n     * @type {Function}\n     */\n\n    this.method = null;\n    /**\n     * 备选的值数组\n     * @type {Array}\n     */\n\n    this.values = [];\n    /**\n     * 属性内部的度量\n     * @type {Array}\n     */\n\n    this.scales = [];\n    /**\n     * 是否通过线性取值, 如果未指定，则根据数值的类型判定\n     * @type {Boolean}\n     */\n\n    this.linear = null;\n    /**\n     * 当用户设置的 callback 返回 null 时, 应该返回默认 callback 中的值\n     */\n\n    var mixedCallback = null;\n    var defaultCallback = this.callback;\n\n    if (cfg.callback) {\n      var userCallback = cfg.callback;\n\n      mixedCallback = function mixedCallback() {\n        for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n          params[_key] = arguments[_key];\n        }\n\n        var ret = userCallback.apply(void 0, params);\n\n        if (isNil(ret)) {\n          ret = defaultCallback.apply(_this, params);\n        }\n\n        return ret;\n      };\n    }\n\n    mix(this, cfg);\n\n    if (mixedCallback) {\n      mix(this, {\n        callback: mixedCallback\n      });\n    }\n  } // 获取属性值，将值映射到视觉通道\n\n\n  var _proto = AttributeBase.prototype;\n\n  _proto._getAttrValue = function _getAttrValue(scale, value) {\n    var values = this.values;\n\n    if (scale.isCategory && !this.linear) {\n      var index = scale.translate(value);\n      return values[index % values.length];\n    }\n\n    var percent = scale.scale(value);\n    return this.getLinearValue(percent);\n  };\n  /**\n   * 如果进行线性映射，返回对应的映射值\n   * @protected\n   * @param  {Number} percent 百分比\n   * @return {*}  颜色值、形状、大小等\n   */\n\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var values = this.values;\n    var steps = values.length - 1;\n    var step = Math.floor(steps * percent);\n    var leftPercent = steps * percent - step;\n    var start = values[step];\n    var end = step === steps ? start : values[step + 1];\n    var rstValue = start + (end - start) * leftPercent;\n    return rstValue;\n  };\n  /**\n   * 默认的回调函数\n   * @param {*} value 回调函数的值\n   * @type {Function}\n   * @return {Array} 返回映射后的值\n   */\n\n\n  _proto.callback = function callback(value) {\n    var self = this;\n    var scale = self.scales[0];\n    var rstValue = null;\n\n    if (scale.type === 'identity') {\n      rstValue = scale.value;\n    } else {\n      rstValue = self._getAttrValue(scale, value);\n    }\n\n    return rstValue;\n  };\n  /**\n   * 根据度量获取属性名\n   * @return {Array} dims of this Attribute\n   */\n\n\n  _proto.getNames = function getNames() {\n    var scales = this.scales;\n    var names = this.names;\n    var length = Math.min(scales.length, names.length);\n    var rst = [];\n\n    for (var i = 0; i < length; i++) {\n      rst.push(names[i]);\n    }\n\n    return rst;\n  };\n  /**\n   * 根据度量获取维度名\n   * @return {Array} dims of this Attribute\n   */\n\n\n  _proto.getFields = function getFields() {\n    var scales = this.scales;\n    var rst = [];\n    each(scales, function (scale) {\n      rst.push(scale.field);\n    });\n    return rst;\n  };\n  /**\n   * 根据名称获取度量\n   * @param  {String} name the name of scale\n   * @return {Scale} scale\n   */\n\n\n  _proto.getScale = function getScale(name) {\n    var scales = this.scales;\n    var names = this.names;\n    var index = names.indexOf(name);\n    return scales[index];\n  };\n  /**\n   * 映射数据\n   * @param {*} param1...paramn 多个数值\n   * @return {Array} 映射的值组成的数组\n   */\n\n\n  _proto.mapping = function mapping() {\n    var scales = this.scales;\n    var callback = this.callback;\n\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n\n    var values = params;\n\n    if (callback) {\n      for (var i = 0, len = params.length; i < len; i++) {\n        params[i] = this._toOriginParam(params[i], scales[i]);\n      }\n\n      values = callback.apply(this, params);\n    }\n\n    values = [].concat(values);\n    return values;\n  }; // 原始的参数\n\n\n  _proto._toOriginParam = function _toOriginParam(param, scale) {\n    var rst = param;\n\n    if (!scale.isLinear) {\n      if (isArray(param)) {\n        rst = [];\n\n        for (var i = 0, len = param.length; i < len; i++) {\n          rst.push(toScaleString(scale, param[i]));\n        }\n      } else {\n        rst = toScaleString(scale, param);\n      }\n    }\n\n    return rst;\n  };\n\n  return AttributeBase;\n}();\n\nmodule.exports = AttributeBase;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Base = __webpack_require__(34);\n\nvar Plot = __webpack_require__(61);\n\nvar Util = __webpack_require__(0);\n\nvar Coord = __webpack_require__(62);\n\nvar Geom = __webpack_require__(6);\n\nvar ScaleController = __webpack_require__(70);\n\nvar AxisController = __webpack_require__(76);\n\nvar Global = __webpack_require__(1);\n\nvar _require = __webpack_require__(5),\n    Canvas = _require.Canvas;\n\nvar Helper = __webpack_require__(28);\n\nfunction isFullCircle(coord) {\n  var startAngle = coord.startAngle;\n  var endAngle = coord.endAngle;\n\n  if (!Util.isNil(startAngle) && !Util.isNil(endAngle) && endAngle - startAngle < Math.PI * 2) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction compare(a, b) {\n  return a - b;\n}\n\nfunction _isScaleExist(scales, compareScale) {\n  var flag = false;\n  Util.each(scales, function (scale) {\n    var scaleValues = [].concat(scale.values);\n    var compareScaleValues = [].concat(compareScale.values);\n\n    if (scale.type === compareScale.type && scale.field === compareScale.field && scaleValues.sort(compare).toString() === compareScaleValues.sort(compare).toString()) {\n      flag = true;\n      return;\n    }\n  });\n  return flag;\n}\n\nvar Chart =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Chart, _Base);\n\n  Chart.initPlugins = function initPlugins() {\n    return {\n      _plugins: [],\n      _cacheId: 0,\n      register: function register(plugins) {\n        var p = this._plugins;\n        [].concat(plugins).forEach(function (plugin) {\n          if (p.indexOf(plugin) === -1) {\n            p.push(plugin);\n          }\n        });\n        this._cacheId++;\n      },\n      unregister: function unregister(plugins) {\n        var p = this._plugins;\n        [].concat(plugins).forEach(function (plugin) {\n          var idx = p.indexOf(plugin);\n\n          if (idx !== -1) {\n            p.splice(idx, 1);\n          }\n        });\n        this._cacheId++;\n      },\n      clear: function clear() {\n        this._plugins = [];\n        this._cacheId++;\n      },\n      count: function count() {\n        return this._plugins.length;\n      },\n      getAll: function getAll() {\n        return this._plugins;\n      },\n      notify: function notify(chart, hook, args) {\n        var descriptors = this.descriptors(chart);\n        var ilen = descriptors.length;\n        var i;\n        var descriptor;\n        var plugin;\n        var params;\n        var method;\n\n        for (i = 0; i < ilen; ++i) {\n          descriptor = descriptors[i];\n          plugin = descriptor.plugin;\n          method = plugin[hook];\n\n          if (typeof method === 'function') {\n            params = [chart].concat(args || []);\n\n            if (method.apply(plugin, params) === false) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      },\n      descriptors: function descriptors(chart) {\n        var cache = chart._plugins || (chart._plugins = {});\n\n        if (cache.id === this._cacheId) {\n          return cache.descriptors;\n        }\n\n        var plugins = [];\n        var descriptors = [];\n\n        this._plugins.concat(chart && chart.get('plugins') || []).forEach(function (plugin) {\n          var idx = plugins.indexOf(plugin);\n\n          if (idx !== -1) {\n            return;\n          }\n\n          plugins.push(plugin);\n          descriptors.push({\n            plugin: plugin\n          });\n        });\n\n        cache.descriptors = descriptors;\n        cache.id = this._cacheId;\n        return descriptors;\n      }\n    };\n  };\n\n  var _proto = Chart.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * the id of canvas\n       * @type {String}\n       */\n      id: null,\n\n      /**\n       * padding\n       * @type {Array|Number}\n       */\n      padding: Global.padding,\n\n      /**\n       * data\n       * @type {Array}\n       */\n      data: null,\n\n      /**\n       * scales of chart\n       * @type {Object}\n       */\n      scales: {},\n\n      /**\n       * @private\n       * geometry instances\n       * @type {Array}\n       */\n      geoms: null,\n\n      /**\n       * scale configuration\n       * @type {Object}\n       */\n      colDefs: null,\n      pixelRatio: Global.pixelRatio,\n\n      /**\n       * filter options\n       * @type {Object}\n       */\n      filters: null,\n      appendPadding: Global.appendPadding\n    };\n  };\n\n  _proto._syncYScales = function _syncYScales() {\n    var geoms = this.get('geoms');\n    var syncScales = [];\n    var min = [];\n    var max = [];\n    Util.each(geoms, function (geom) {\n      var yScale = geom.getYScale();\n\n      if (yScale.isLinear) {\n        syncScales.push(yScale);\n        min.push(yScale.min);\n        max.push(yScale.max);\n      }\n    });\n    min = Math.min.apply(null, min);\n    max = Math.max.apply(null, max);\n    Util.each(syncScales, function (scale) {\n      scale.change({\n        min: min\n      });\n      scale.change({\n        max: max\n      });\n    });\n  };\n\n  _proto._getFieldsForLegend = function _getFieldsForLegend() {\n    var fields = [];\n    var geoms = this.get('geoms');\n    Util.each(geoms, function (geom) {\n      var attrOptions = geom.get('attrOptions');\n      var attrCfg = attrOptions.color;\n\n      if (attrCfg && attrCfg.field && Util.isString(attrCfg.field)) {\n        var arr = attrCfg.field.split('*');\n        Util.each(arr, function (item) {\n          if (fields.indexOf(item) === -1) {\n            fields.push(item);\n          }\n        });\n      }\n    });\n    return fields;\n  };\n\n  _proto._createScale = function _createScale(field, data) {\n    var scaleController = this.get('scaleController');\n    return scaleController.createScale(field, data);\n  };\n\n  _proto._adjustScale = function _adjustScale() {\n    var self = this;\n    var coord = self.get('coord');\n    var xScale = self.getXScale();\n    var yScales = self.getYScales();\n    var scales = [];\n    xScale && scales.push(xScale);\n    scales = scales.concat(yScales);\n    var inFullCircle = coord.isPolar && isFullCircle(coord);\n    var scaleController = self.get('scaleController');\n    var colDefs = scaleController.defs;\n    Util.each(scales, function (scale) {\n      if ((scale.isCategory || scale.isIdentity) && scale.values && !(colDefs[scale.field] && colDefs[scale.field].range)) {\n        var count = scale.values.length;\n        var range;\n\n        if (count === 1) {\n          range = [0.5, 1];\n        } else {\n          var widthRatio = 1;\n          var offset = 0;\n\n          if (inFullCircle) {\n            if (!coord.transposed) {\n              range = [0, 1 - 1 / count];\n            } else {\n              widthRatio = Global.widthRatio.multiplePie;\n              offset = 1 / count * widthRatio;\n              range = [offset / 2, 1 - offset / 2];\n            }\n          } else {\n            offset = 1 / count * 1 / 2;\n            range = [offset, 1 - offset];\n          }\n        }\n\n        scale.range = range;\n      }\n    });\n    var geoms = this.get('geoms');\n\n    for (var i = 0; i < geoms.length; i++) {\n      var geom = geoms[i];\n\n      if (geom.get('type') === 'interval') {\n        var yScale = geom.getYScale();\n        var field = yScale.field,\n            min = yScale.min,\n            max = yScale.max,\n            type = yScale.type;\n\n        if (!(colDefs[field] && colDefs[field].min) && type !== 'time') {\n          if (min > 0) {\n            yScale.change({\n              min: 0\n            });\n          } else if (max <= 0) {\n            yScale.change({\n              max: 0\n            });\n          }\n        }\n      }\n    }\n  };\n\n  _proto._removeGeoms = function _removeGeoms() {\n    var geoms = this.get('geoms');\n\n    while (geoms.length > 0) {\n      var geom = geoms.shift();\n      geom.destroy();\n    }\n  };\n\n  _proto._clearGeoms = function _clearGeoms() {\n    var geoms = this.get('geoms');\n\n    for (var i = 0, length = geoms.length; i < length; i++) {\n      var geom = geoms[i];\n      geom.clear();\n    }\n  };\n\n  _proto._clearInner = function _clearInner() {\n    this.set('scales', {});\n    this.set('legendItems', null);\n\n    this._clearGeoms();\n\n    Chart.plugins.notify(this, 'clearInner');\n    this.get('axisController') && this.get('axisController').clear();\n  };\n\n  _proto._execFilter = function _execFilter(data) {\n    var filters = this.get('filters');\n\n    if (filters) {\n      data = data.filter(function (obj) {\n        var rst = true;\n        Util.each(filters, function (fn, k) {\n          if (fn) {\n            rst = fn(obj[k], obj);\n\n            if (!rst) {\n              return false;\n            }\n          }\n        });\n        return rst;\n      });\n    }\n\n    return data;\n  };\n\n  _proto._initGeoms = function _initGeoms(geoms) {\n    var coord = this.get('coord');\n    var data = this.get('filteredData');\n    var colDefs = this.get('colDefs');\n\n    for (var i = 0, length = geoms.length; i < length; i++) {\n      var geom = geoms[i];\n      geom.set('data', data);\n      geom.set('coord', coord);\n      geom.set('colDefs', colDefs);\n      geom.init();\n    }\n  };\n\n  _proto._initCoord = function _initCoord() {\n    var plot = this.get('plotRange');\n    var coordCfg = Util.mix({\n      type: 'cartesian'\n    }, this.get('coordCfg'), {\n      plot: plot\n    });\n    var type = coordCfg.type;\n    var C = Coord[Util.upperFirst(type)];\n    var coord = new C(coordCfg);\n    this.set('coord', coord);\n  };\n\n  _proto._initLayout = function _initLayout() {\n    var padding = this.get('_padding');\n\n    if (!padding) {\n      padding = this.get('margin') || this.get('padding');\n      padding = Util.parsePadding(padding);\n    }\n\n    var top = padding[0] === 'auto' ? 0 : padding[0];\n    var right = padding[1] === 'auto' ? 0 : padding[1];\n    var bottom = padding[2] === 'auto' ? 0 : padding[2];\n    var left = padding[3] === 'auto' ? 0 : padding[3];\n    var width = this.get('width');\n    var height = this.get('height');\n    var plot = new Plot({\n      start: {\n        x: left,\n        y: top\n      },\n      end: {\n        x: width - right,\n        y: height - bottom\n      }\n    });\n    this.set('plotRange', plot);\n    this.set('plot', plot);\n  };\n\n  _proto._initCanvas = function _initCanvas() {\n    var self = this;\n\n    try {\n      var canvas = new Canvas({\n        el: self.get('el') || self.get('id'),\n        context: self.get('context'),\n        pixelRatio: self.get('pixelRatio'),\n        width: self.get('width'),\n        height: self.get('height'),\n        fontFamily: Global.fontFamily\n      });\n      self.set('canvas', canvas);\n      self.set('width', canvas.get('width'));\n      self.set('height', canvas.get('height'));\n    } catch (error) {\n      throw error;\n    }\n\n    Chart.plugins.notify(self, 'afterCanvasInit');\n\n    self._initLayout();\n  };\n\n  _proto._initLayers = function _initLayers() {\n    var canvas = this.get('canvas');\n    this.set('backPlot', canvas.addGroup());\n    this.set('middlePlot', canvas.addGroup({\n      zIndex: 10\n    }));\n    this.set('frontPlot', canvas.addGroup({\n      zIndex: 20\n    }));\n  };\n\n  _proto._init = function _init() {\n    var self = this;\n\n    self._initCanvas();\n\n    self._initLayers();\n\n    self.set('geoms', []);\n    self.set('scaleController', new ScaleController());\n    self.set('axisController', new AxisController({\n      frontPlot: self.get('frontPlot').addGroup({\n        className: 'axisContainer'\n      }),\n      backPlot: self.get('backPlot').addGroup({\n        className: 'axisContainer'\n      }),\n      chart: self\n    }));\n    Chart.plugins.notify(self, 'init');\n  };\n\n  function Chart(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n\n    var self = _assertThisInitialized(_this);\n\n    Util.each(Geom, function (geomConstructor, className) {\n      var methodName = Util.lowerFirst(className);\n\n      self[methodName] = function (cfg) {\n        var geom = new geomConstructor(cfg);\n        self.addGeom(geom);\n        return geom;\n      };\n    });\n\n    self._init();\n\n    return _this;\n  }\n  /**\n   * set data and some scale configuration\n   * @chainable\n   * @param  {Array} data the dataset to visualize\n   * @param  {Object} colDefs the configuration for scales\n   * @return {Chart} return the chart instance\n   */\n\n\n  _proto.source = function source(data, colDefs) {\n    this.set('data', data);\n\n    if (colDefs) {\n      this.scale(colDefs);\n    }\n\n    return this;\n  };\n\n  _proto.scale = function scale(field, cfg) {\n    var colDefs = this.get('colDefs') || {};\n\n    if (Util.isObject(field)) {\n      Util.mix(colDefs, field);\n    } else {\n      colDefs[field] = cfg;\n    }\n\n    this.set('colDefs', colDefs);\n    var scaleController = this.get('scaleController');\n    scaleController.defs = colDefs;\n    return this;\n  }\n  /**\n   * configure the axis\n   * @chainable\n   * @param  {String|Boolean} field the field name of data\n   * @param  {Object} cfg configuration for axis\n   * @return {Chart} return the chart instance\n   */\n  ;\n\n  _proto.axis = function axis(field, cfg) {\n    var axisController = this.get('axisController');\n\n    if (!field) {\n      axisController.axisCfg = null;\n    } else {\n      axisController.axisCfg = axisController.axisCfg || {};\n      axisController.axisCfg[field] = cfg;\n    }\n\n    return this;\n  }\n  /**\n   * configure the coordinate\n   * @chainable\n   * @param  {String} type set the type of coodinate\n   * @param  {Object} cfg configuration for coordinate\n   * @return {Chart} return the chart instance\n   */\n  ;\n\n  _proto.coord = function coord(type, cfg) {\n    var coordCfg;\n\n    if (Util.isObject(type)) {\n      coordCfg = type;\n    } else {\n      coordCfg = cfg || {};\n      coordCfg.type = type || 'cartesian';\n    }\n\n    this.set('coordCfg', coordCfg);\n    return this;\n  };\n\n  _proto.filter = function filter(field, condition) {\n    var filters = this.get('filters') || {};\n    filters[field] = condition;\n    this.set('filters', filters);\n  }\n  /**\n   * render the chart\n   * @chainable\n   * @return {Chart} return the chart instance\n   */\n  ;\n\n  _proto.render = function render() {\n    var canvas = this.get('canvas');\n    var geoms = this.get('geoms');\n    var data = this.get('data') || [];\n\n    var filteredData = this._execFilter(data); // filter data\n\n\n    this.set('filteredData', filteredData);\n\n    this._initCoord(); // initialization coordinate instance\n\n\n    Chart.plugins.notify(this, 'beforeGeomInit');\n\n    this._initGeoms(geoms); // init all geometry instances\n\n\n    this.get('syncY') && this._syncYScales();\n\n    this._adjustScale(); // do some adjust for data\n\n\n    Chart.plugins.notify(this, 'beforeGeomDraw');\n\n    this._renderAxis();\n\n    var middlePlot = this.get('middlePlot');\n\n    if (this.get('limitInPlot') && !middlePlot.attr('clip')) {\n      var coord = this.get('coord');\n      var clip = Helper.getClip(coord);\n      clip.set('canvas', middlePlot.get('canvas'));\n      middlePlot.attr('clip', clip);\n    }\n\n    for (var i = 0, length = geoms.length; i < length; i++) {\n      var geom = geoms[i];\n      geom.paint();\n    }\n\n    Chart.plugins.notify(this, 'afterGeomDraw');\n    canvas.sort();\n    this.get('frontPlot').sort();\n    Chart.plugins.notify(this, 'beforeCanvasDraw');\n    canvas.draw();\n    return this;\n  }\n  /**\n   * clear the chart, include geometris and all the shapes\n   * @chainable\n   * @return {Chart} return the chart\n   */\n  ;\n\n  _proto.clear = function clear() {\n    Chart.plugins.notify(this, 'clear');\n\n    this._removeGeoms();\n\n    this._clearInner();\n\n    this.set('filters', null);\n    this.set('isUpdate', false);\n    this.set('_padding', null);\n    var canvas = this.get('canvas');\n    canvas.draw();\n    return this;\n  };\n\n  _proto.repaint = function repaint() {\n    this.set('isUpdate', true);\n    Chart.plugins.notify(this, 'repaint');\n\n    this._clearInner();\n\n    this.render();\n  };\n\n  _proto.changeData = function changeData(data) {\n    this.set('data', data);\n    Chart.plugins.notify(this, 'changeData');\n    this.set('_padding', null);\n    this.repaint();\n  };\n\n  _proto.changeSize = function changeSize(width, height) {\n    if (width) {\n      this.set('width', width);\n    } else {\n      width = this.get('width');\n    }\n\n    if (height) {\n      this.set('height', height);\n    } else {\n      height = this.get('height');\n    }\n\n    var canvas = this.get('canvas');\n    canvas.changeSize(width, height);\n\n    this._initLayout();\n\n    this.repaint();\n    return this;\n  };\n\n  _proto.destroy = function destroy() {\n    this.clear();\n    var canvas = this.get('canvas');\n    canvas.destroy();\n    Chart.plugins.notify(this, 'afterCanvasDestroyed');\n\n    if (this._interactions) {\n      Util.each(this._interactions, function (interaction) {\n        interaction.destroy();\n      });\n    }\n\n    _Base.prototype.destroy.call(this);\n  }\n  /**\n   * calculate dataset's position on canvas\n   * @param  {Object} record the dataset\n   * @return {Object} return the position\n   */\n  ;\n\n  _proto.getPosition = function getPosition(record) {\n    var self = this;\n    var coord = self.get('coord');\n    var xScale = self.getXScale();\n    var yScale = self.getYScales()[0];\n    var xField = xScale.field;\n    var x = xScale.scale(record[xField]);\n    var yField = yScale.field;\n    var y = yScale.scale(record[yField]);\n    return coord.convertPoint({\n      x: x,\n      y: y\n    });\n  }\n  /**\n   * get the data item of the point\n   * @param  {Object} point canvas position\n   * @return {Object} return the data item\n   */\n  ;\n\n  _proto.getRecord = function getRecord(point) {\n    var self = this;\n    var coord = self.get('coord');\n    var xScale = self.getXScale();\n    var yScale = self.getYScales()[0];\n    var invertPoint = coord.invertPoint(point);\n    var record = {};\n    record[xScale.field] = xScale.invert(invertPoint.x);\n    record[yScale.field] = yScale.invert(invertPoint.y);\n    return record;\n  }\n  /**\n   * get the dataset of the point\n   * @param  {Object} point canvas position\n   * @return {Array} return the dataset\n  **/\n  ;\n\n  _proto.getSnapRecords = function getSnapRecords(point) {\n    var geom = this.get('geoms')[0];\n    var data = [];\n\n    if (geom) {\n      // need to judge\n      data = geom.getSnapRecords(point);\n    }\n\n    return data;\n  }\n  /**\n   * creat scale instances\n   * @param  {String} field field name of data\n   * @return {Scale} return the scale\n   */\n  ;\n\n  _proto.createScale = function createScale(field) {\n    var data = this.get('data');\n    var filteredData = this.get('filteredData');\n\n    if (filteredData.length) {\n      var legendFields = this._getFieldsForLegend();\n\n      if (legendFields.indexOf(field) === -1) {\n        data = filteredData;\n      }\n    }\n\n    var scales = this.get('scales');\n\n    if (!scales[field]) {\n      scales[field] = this._createScale(field, data);\n    }\n\n    return scales[field];\n  }\n  /**\n   * @protected\n   * add geometry instance to geoms\n   * @param {Geom} geom geometry instance\n   */\n  ;\n\n  _proto.addGeom = function addGeom(geom) {\n    var geoms = this.get('geoms');\n    var middlePlot = this.get('middlePlot');\n    geoms.push(geom);\n    geom.set('chart', this);\n    geom.set('container', middlePlot.addGroup());\n  }\n  /**\n   * get the scale of x axis\n   * @return {Scale} return the scale\n   */\n  ;\n\n  _proto.getXScale = function getXScale() {\n    var self = this;\n    var geoms = self.get('geoms');\n    var xScale = geoms[0].getXScale();\n    return xScale;\n  }\n  /**\n   * get the scale of y axis\n   * @return {Array} return the scale\n   */\n  ;\n\n  _proto.getYScales = function getYScales() {\n    var geoms = this.get('geoms');\n    var rst = [];\n    Util.each(geoms, function (geom) {\n      var yScale = geom.getYScale();\n\n      if (rst.indexOf(yScale) === -1) {\n        rst.push(yScale);\n      }\n    });\n    return rst;\n  };\n\n  _proto.getLegendItems = function getLegendItems() {\n    if (this.get('legendItems')) {\n      return this.get('legendItems');\n    }\n\n    var legendItems = {};\n    var scales = [];\n    var geoms = this.get('geoms');\n    Util.each(geoms, function (geom) {\n      var colorAttr = geom.getAttr('color');\n\n      if (colorAttr) {\n        var scale = colorAttr.getScale('color');\n\n        if (scale.type !== 'identity' && !_isScaleExist(scales, scale)) {\n          scales.push(scale);\n          var field = scale.field;\n          var ticks = scale.getTicks();\n          var items = [];\n          Util.each(ticks, function (tick) {\n            var text = tick.text;\n            var name = text;\n            var scaleValue = tick.value;\n            var value = scale.invert(scaleValue);\n            var color = colorAttr.mapping(value).join('') || Global.defaultColor;\n            var marker = {\n              fill: color,\n              radius: 3,\n              symbol: 'circle',\n              stroke: '#fff'\n            };\n            items.push({\n              name: name,\n              // for display\n              dataValue: value,\n              // the origin value\n              checked: true,\n              marker: marker\n            });\n          });\n          legendItems[field] = items;\n        }\n      }\n    });\n    this.set('legendItems', legendItems);\n    return legendItems;\n  } // register the plugins\n  ;\n\n  _proto.registerPlugins = function registerPlugins(plugins) {\n    var self = this;\n    var chartPlugins = self.get('plugins') || [];\n\n    if (!Util.isArray(chartPlugins)) {\n      chartPlugins = [chartPlugins];\n    }\n\n    [].concat(plugins).forEach(function (plugin) {\n      if (chartPlugins.indexOf(plugin) === -1) {\n        plugin.init && plugin.init(self); // init\n\n        chartPlugins.push(plugin);\n      }\n    });\n    Chart.plugins._cacheId++;\n    self.set('plugins', chartPlugins);\n  };\n\n  _proto._renderAxis = function _renderAxis() {\n    var axisController = this.get('axisController');\n    var xScale = this.getXScale();\n    var yScales = this.getYScales();\n    var coord = this.get('coord');\n    Chart.plugins.notify(this, 'beforeRenderAxis');\n    axisController.createAxis(coord, xScale, yScales);\n  };\n\n  _proto._isAutoPadding = function _isAutoPadding() {\n    if (this.get('_padding')) {\n      return false;\n    }\n\n    var padding = this.get('padding');\n\n    if (Util.isArray(padding)) {\n      return padding.indexOf('auto') !== -1;\n    }\n\n    return padding === 'auto';\n  };\n\n  _proto._updateLayout = function _updateLayout(padding) {\n    var width = this.get('width');\n    var height = this.get('height');\n    var start = {\n      x: padding[3],\n      y: padding[0]\n    };\n    var end = {\n      x: width - padding[1],\n      y: height - padding[2]\n    };\n    var plot = this.get('plot');\n    var coord = this.get('coord');\n    plot.reset(start, end);\n    coord.reset(plot);\n  };\n\n  return Chart;\n}(Base);\n\nChart.plugins = Chart.initPlugins();\nmodule.exports = Chart;\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nvar isType = function isType(value, type) {\n  return toString.call(value) === '[object ' + type + ']';\n};\n\nmodule.exports = isType;\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 判断是否数字\n * @return {Boolean} 是否数字\n */\nvar isType = __webpack_require__(16);\n\nvar isNumber = function isNumber(value) {\n  return isType(value, 'Number');\n};\n\nmodule.exports = isNumber;\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(16);\n\nvar isString = function isString(str) {\n  return isType(str, 'String');\n};\n\nmodule.exports = isString;\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview shape util\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar ShapeUtil = {\n  splitPoints: function splitPoints(obj) {\n    var points = [];\n    var x = obj.x;\n    var y = obj.y;\n    y = Util.isArray(y) ? y : [y];\n    y.forEach(function (yItem, index) {\n      var point = {\n        x: Util.isArray(x) ? x[index] : x,\n        y: yItem\n      };\n      points.push(point);\n    });\n    return points;\n  },\n  splitArray: function splitArray(data, yField, connectNulls) {\n    if (!data.length) return [];\n    var arr = [];\n    var tmp = [];\n    var yValue;\n    Util.each(data, function (obj) {\n      yValue = obj._origin ? obj._origin[yField] : obj[yField];\n\n      if (connectNulls) {\n        if (!Util.isNil(yValue)) {\n          tmp.push(obj);\n        }\n      } else {\n        if (Util.isArray(yValue) && Util.isNil(yValue[0]) || Util.isNil(yValue)) {\n          if (tmp.length) {\n            arr.push(tmp);\n            tmp = [];\n          }\n        } else {\n          tmp.push(obj);\n        }\n      }\n    });\n\n    if (tmp.length) {\n      arr.push(tmp);\n    }\n\n    return arr;\n  }\n};\nmodule.exports = ShapeUtil;\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(7);\n\nvar isArray = Array.isArray ? Array.isArray : function (value) {\n  return isType(value, 'Array');\n};\nmodule.exports = isArray;\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Base =\n/*#__PURE__*/\nfunction () {\n  var _proto = Base.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {};\n\n  function Base(cfg) {\n    this._initDefaultCfg();\n\n    Util.mix(this, cfg);\n    var start;\n    var end;\n\n    if (this.plot) {\n      start = this.plot.bl;\n      end = this.plot.tr;\n      this.start = start;\n      this.end = end;\n    } else {\n      start = this.start;\n      end = this.end;\n    }\n\n    this.init(start, end);\n  }\n\n  _proto.init = function init() {};\n\n  _proto.convertPoint = function convertPoint(point) {\n    return point;\n  };\n\n  _proto.invertPoint = function invertPoint(point) {\n    return point;\n  };\n\n  _proto.reset = function reset(plot) {\n    this.plot = plot;\n    var bl = plot.bl,\n        tr = plot.tr;\n    this.start = bl;\n    this.end = tr;\n    this.init(bl, tr);\n  };\n\n  return Base;\n}();\n\nmodule.exports = Base;\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports) {\n\nfunction _mix(dist, obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n      dist[key] = obj[key];\n    }\n  }\n}\n\nvar mix = function mix(dist, src1, src2, src3) {\n  if (src1) _mix(dist, src1);\n  if (src2) _mix(dist, src2);\n  if (src3) _mix(dist, src3);\n  return dist;\n};\n\nmodule.exports = mix;\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar mix = __webpack_require__(22);\n\nvar Adjust =\n/*#__PURE__*/\nfunction () {\n  var _proto = Adjust.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整\n  };\n\n  function Adjust(cfg) {\n    this._initDefaultCfg();\n\n    mix(this, cfg);\n  }\n  /**\n   * @override\n   */\n\n\n  _proto.processAdjust = function processAdjust()\n  /* dataArray */\n  {};\n\n  return Adjust;\n}();\n\nmodule.exports = Adjust;\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\nvar Matrix = {\n  multiply: function multiply(m1, m2) {\n    var m11 = m1[0] * m2[0] + m1[2] * m2[1];\n    var m12 = m1[1] * m2[0] + m1[3] * m2[1];\n    var m21 = m1[0] * m2[2] + m1[2] * m2[3];\n    var m22 = m1[1] * m2[2] + m1[3] * m2[3];\n    var dx = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];\n    var dy = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];\n    return [m11, m12, m21, m22, dx, dy];\n  },\n  scale: function scale(out, m, v) {\n    out[0] = m[0] * v[0];\n    out[1] = m[1] * v[0];\n    out[2] = m[2] * v[1];\n    out[3] = m[3] * v[1];\n    out[4] = m[4];\n    out[5] = m[5];\n    return out;\n  },\n  rotate: function rotate(out, m, radian) {\n    var c = Math.cos(radian);\n    var s = Math.sin(radian);\n    var m11 = m[0] * c + m[2] * s;\n    var m12 = m[1] * c + m[3] * s;\n    var m21 = m[0] * -s + m[2] * c;\n    var m22 = m[1] * -s + m[3] * c;\n    out[0] = m11;\n    out[1] = m12;\n    out[2] = m21;\n    out[3] = m22;\n    out[4] = m[4];\n    out[5] = m[5];\n    return out;\n  },\n  translate: function translate(out, m, v) {\n    out[0] = m[0];\n    out[1] = m[1];\n    out[2] = m[2];\n    out[3] = m[3];\n    out[4] = m[4] + m[0] * v[0] + m[2] * v[1];\n    out[5] = m[5] + m[1] * v[0] + m[3] * v[1];\n    return out;\n  },\n  transform: function transform(m, actions) {\n    var out = [].concat(m);\n\n    for (var i = 0, len = actions.length; i < len; i++) {\n      var action = actions[i];\n\n      switch (action[0]) {\n        case 't':\n          Matrix.translate(out, out, [action[1], action[2]]);\n          break;\n\n        case 's':\n          Matrix.scale(out, out, [action[1], action[2]]);\n          break;\n\n        case 'r':\n          Matrix.rotate(out, out, action[1]);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    return out;\n  }\n};\nmodule.exports = Matrix;\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObject = function isObject(value) {\n  /**\n   * isObject({}) => true\n   * isObject([1, 2, 3]) => true\n   * isObject(Function) => true\n   * isObject(null) => false\n   */\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return value !== null && type === 'object' || type === 'function';\n};\n\nmodule.exports = isObject;\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(1);\n\nvar Vector2 = __webpack_require__(3);\n\nvar Abastract =\n/*#__PURE__*/\nfunction () {\n  var _proto = Abastract.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    /**\n     * ticks\n     * @type {Array}\n     */\n    this.ticks = [];\n    /**\n     * the configuration for tickLine\n     * @type {Object}\n     */\n\n    this.tickLine = {};\n    /**\n     * the direction of ticks, 1 means clockwise\n     * @type {Number}\n     */\n\n    this.offsetFactor = 1;\n    /**\n     * the top container\n     * @type {container}\n     */\n\n    this.frontContainer = null;\n    /**\n     * the back container\n     * @type {[type]}\n     */\n\n    this.backContainer = null;\n    /**\n     * points for draw grid line\n     * @type {Array}\n     */\n\n    this.gridPoints = [];\n  };\n\n  function Abastract(cfg) {\n    this._initDefaultCfg();\n\n    Util.mix(this, cfg);\n    this.draw();\n  }\n\n  _proto.draw = function draw() {\n    var line = this.line,\n        tickLine = this.tickLine,\n        label = this.label,\n        grid = this.grid;\n    grid && this.drawGrid(grid); // draw the grid lines\n\n    tickLine && this.drawTicks(tickLine); // draw the tickLine\n\n    line && this.drawLine(line); // draw axis line\n\n    label && this.drawLabels(); // draw ticks\n  };\n\n  _proto.drawTicks = function drawTicks(tickCfg) {\n    var self = this;\n    var ticks = self.ticks;\n    var length = tickCfg.length;\n    var container = self.getContainer(tickCfg.top);\n    Util.each(ticks, function (tick) {\n      var start = self.getOffsetPoint(tick.value);\n      var end = self.getSidePoint(start, length);\n      var shape = container.addShape('line', {\n        className: 'axis-tick',\n        attrs: Util.mix({\n          x1: start.x,\n          y1: start.y,\n          x2: end.x,\n          y2: end.y\n        }, tickCfg)\n      });\n      shape._id = self._id + '-ticks';\n    });\n  };\n\n  _proto.drawLabels = function drawLabels() {\n    var self = this;\n    var labelOffset = self.labelOffset;\n    var labels = self.labels;\n    Util.each(labels, function (labelShape) {\n      var container = self.getContainer(labelShape.get('top'));\n      var start = self.getOffsetPoint(labelShape.get('value'));\n\n      var _self$getSidePoint = self.getSidePoint(start, labelOffset),\n          x = _self$getSidePoint.x,\n          y = _self$getSidePoint.y;\n\n      labelShape.attr(Util.mix({\n        x: x,\n        y: y\n      }, self.getTextAlignInfo(start, labelOffset), labelShape.get('textStyle')));\n      labelShape._id = self._id + '-' + labelShape.attr('text');\n      container.add(labelShape);\n    });\n  };\n\n  _proto.drawLine = function drawLine() {};\n\n  _proto.drawGrid = function drawGrid(grid) {\n    var self = this;\n    var gridPoints = self.gridPoints,\n        ticks = self.ticks;\n    var gridCfg = grid;\n    var count = gridPoints.length;\n    Util.each(gridPoints, function (subPoints, index) {\n      if (Util.isFunction(grid)) {\n        var tick = ticks[index] || {};\n        var executedGrid = grid(tick.text, index, count);\n        gridCfg = executedGrid ? Util.mix({}, Global._defaultAxis.grid, executedGrid) : null;\n      }\n\n      if (gridCfg) {\n        var type = gridCfg.type; // has two types: 'line' and 'arc'\n\n        var points = subPoints.points;\n        var container = self.getContainer(gridCfg.top);\n        var shape;\n\n        if (type === 'arc') {\n          var center = self.center,\n              startAngle = self.startAngle,\n              endAngle = self.endAngle;\n          var radius = Vector2.length([points[0].x - center.x, points[0].y - center.y]);\n          shape = container.addShape('Arc', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              x: center.x,\n              y: center.y,\n              startAngle: startAngle,\n              endAngle: endAngle,\n              r: radius\n            }, gridCfg)\n          });\n        } else {\n          shape = container.addShape('Polyline', {\n            className: 'axis-grid',\n            attrs: Util.mix({\n              points: points\n            }, gridCfg)\n          });\n        }\n\n        shape._id = subPoints._id;\n      }\n    });\n  };\n\n  _proto.getOffsetPoint = function getOffsetPoint() {};\n\n  _proto.getAxisVector = function getAxisVector() {};\n\n  _proto.getOffsetVector = function getOffsetVector(point, offset) {\n    var self = this;\n    var axisVector = self.getAxisVector(point);\n    var normal = Vector2.normalize([], axisVector);\n    var factor = self.offsetFactor;\n    var verticalVector = [normal[1] * -1 * factor, normal[0] * factor];\n    return Vector2.scale([], verticalVector, offset);\n  };\n\n  _proto.getSidePoint = function getSidePoint(point, offset) {\n    var self = this;\n    var offsetVector = self.getOffsetVector(point, offset);\n    return {\n      x: point.x + offsetVector[0],\n      y: point.y + offsetVector[1]\n    };\n  };\n\n  _proto.getTextAlignInfo = function getTextAlignInfo(point, offset) {\n    var self = this;\n    var offsetVector = self.getOffsetVector(point, offset);\n    var align;\n    var baseLine;\n\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n    }\n\n    if (offsetVector[1] > 0) {\n      baseLine = 'top';\n    } else if (offsetVector[1] < 0) {\n      baseLine = 'bottom';\n    } else {\n      baseLine = 'middle';\n    }\n\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  };\n\n  _proto.getContainer = function getContainer(isTop) {\n    var frontContainer = this.frontContainer,\n        backContainer = this.backContainer;\n    return isTop ? frontContainer : backContainer;\n  };\n\n  return Abastract;\n}();\n\nmodule.exports = Abastract;\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar MatrixUtil = __webpack_require__(24);\n\nvar Vector2 = __webpack_require__(3);\n\nvar StyleUtil = __webpack_require__(80);\n\nfunction isUnchanged(m) {\n  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;\n}\n\nvar ALIAS_ATTRS_MAP = {\n  stroke: 'strokeStyle',\n  fill: 'fillStyle',\n  opacity: 'globalAlpha'\n};\nvar SHAPE_ATTRS = ['fillStyle', 'font', 'globalAlpha', 'lineCap', 'lineWidth', 'lineJoin', 'miterLimit', 'shadowBlur', 'shadowColor', 'shadowOffsetX', 'shadowOffsetY', 'strokeStyle', 'textAlign', 'textBaseline', 'lineDash', 'shadow' // 兼容支付宝小程序\n];\nvar CLIP_SHAPES = ['circle', 'sector', 'polygon', 'rect', 'polyline'];\n\nvar Element =\n/*#__PURE__*/\nfunction () {\n  var _proto = Element.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    this._attrs = {\n      zIndex: 0,\n      visible: true,\n      destroyed: false\n    };\n  };\n\n  function Element(cfg) {\n    this._initProperties();\n\n    Util.mix(this._attrs, cfg);\n    var attrs = this._attrs.attrs;\n\n    if (attrs) {\n      this.initAttrs(attrs);\n    }\n\n    this.initTransform();\n  }\n\n  _proto.get = function get(name) {\n    return this._attrs[name];\n  };\n\n  _proto.set = function set(name, value) {\n    this._attrs[name] = value;\n  };\n\n  _proto.isGroup = function isGroup() {\n    return this.get('isGroup');\n  };\n\n  _proto.isShape = function isShape() {\n    return this.get('isShape');\n  };\n\n  _proto.initAttrs = function initAttrs(attrs) {\n    this.attr(Util.mix(this.getDefaultAttrs(), attrs));\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {};\n  };\n\n  _proto._setAttr = function _setAttr(name, value) {\n    var attrs = this._attrs.attrs;\n\n    if (name === 'clip') {\n      value = this._setAttrClip(value);\n    } else {\n      var alias = ALIAS_ATTRS_MAP[name];\n\n      if (alias) {\n        attrs[alias] = value;\n      }\n    }\n\n    attrs[name] = value;\n  };\n\n  _proto._getAttr = function _getAttr(name) {\n    return this._attrs.attrs[name];\n  } // _afterAttrsSet() {}\n  ;\n\n  _proto._setAttrClip = function _setAttrClip(clip) {\n    if (clip && CLIP_SHAPES.indexOf(clip._attrs.type) > -1) {\n      if (clip.get('canvas') === null) {\n        clip = Object.assign({}, clip);\n      }\n\n      clip.set('parent', this.get('parent'));\n      clip.set('context', this.get('context'));\n      return clip;\n    }\n\n    return null;\n  };\n\n  _proto.attr = function attr(name, value) {\n    var self = this;\n    if (self.get('destroyed')) return null;\n    var argumentsLen = arguments.length;\n\n    if (argumentsLen === 0) {\n      return self._attrs.attrs;\n    }\n\n    if (Util.isObject(name)) {\n      this._attrs.bbox = null;\n\n      for (var k in name) {\n        self._setAttr(k, name[k]);\n      }\n\n      if (self._afterAttrsSet) {\n        self._afterAttrsSet();\n      }\n\n      return self;\n    }\n\n    if (argumentsLen === 2) {\n      this._attrs.bbox = null;\n\n      self._setAttr(name, value);\n\n      if (self._afterAttrsSet) {\n        self._afterAttrsSet();\n      }\n\n      return self;\n    }\n\n    return self._getAttr(name);\n  };\n\n  _proto.getParent = function getParent() {\n    return this.get('parent');\n  };\n\n  _proto.draw = function draw(context) {\n    if (this.get('destroyed')) {\n      return;\n    }\n\n    if (this.get('visible')) {\n      this.setContext(context);\n      this.drawInner(context);\n      this.restoreContext(context);\n    }\n  };\n\n  _proto.setContext = function setContext(context) {\n    var clip = this._attrs.attrs.clip;\n    context.save();\n\n    if (clip) {\n      clip.resetTransform(context);\n      clip.createPath(context);\n      context.clip();\n    }\n\n    this.resetContext(context);\n    this.resetTransform(context);\n  };\n\n  _proto.restoreContext = function restoreContext(context) {\n    context.restore();\n  };\n\n  _proto.resetContext = function resetContext(context) {\n    var elAttrs = this._attrs.attrs;\n\n    if (!this._attrs.isGroup) {\n      for (var k in elAttrs) {\n        if (SHAPE_ATTRS.indexOf(k) > -1) {\n          var v = elAttrs[k];\n\n          if (k === 'fillStyle' || k === 'strokeStyle') {\n            v = StyleUtil.parseStyle(v, this, context);\n          }\n\n          if (k === 'lineDash' && context.setLineDash && Util.isArray(v)) {\n            context.setLineDash(v);\n          } else {\n            context[k] = v;\n          }\n        }\n      }\n    }\n  };\n\n  _proto.hasFill = function hasFill() {\n    return this.get('canFill') && this._attrs.attrs.fillStyle;\n  };\n\n  _proto.hasStroke = function hasStroke() {\n    return this.get('canStroke') && this._attrs.attrs.strokeStyle;\n  };\n\n  _proto.drawInner = function drawInner()\n  /* context */\n  {};\n\n  _proto.show = function show() {\n    this.set('visible', true);\n    return this;\n  };\n\n  _proto.hide = function hide() {\n    this.set('visible', false);\n    return this;\n  };\n\n  _proto.isVisible = function isVisible() {\n    return this.get('visible');\n  };\n\n  _proto._removeFromParent = function _removeFromParent() {\n    var parent = this.get('parent');\n\n    if (parent) {\n      var children = parent.get('children');\n      Util.Array.remove(children, this);\n    }\n\n    return this;\n  };\n\n  _proto.remove = function remove(destroy) {\n    if (destroy) {\n      this.destroy();\n    } else {\n      this._removeFromParent();\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    var destroyed = this.get('destroyed');\n\n    if (destroyed) {\n      return null;\n    }\n\n    this._removeFromParent();\n\n    this._attrs = {};\n    this.set('destroyed', true);\n  };\n\n  _proto.getBBox = function getBBox() {\n    return {\n      minX: 0,\n      maxX: 0,\n      minY: 0,\n      maxY: 0,\n      width: 0,\n      height: 0\n    };\n  };\n\n  _proto.initTransform = function initTransform() {\n    var attrs = this._attrs.attrs || {};\n\n    if (!attrs.matrix) {\n      attrs.matrix = [1, 0, 0, 1, 0, 0];\n    }\n\n    this._attrs.attrs = attrs;\n  };\n\n  _proto.getMatrix = function getMatrix() {\n    return this._attrs.attrs.matrix;\n  };\n\n  _proto.setMatrix = function setMatrix(m) {\n    this._attrs.attrs.matrix = [m[0], m[1], m[2], m[3], m[4], m[5]];\n  };\n\n  _proto.transform = function transform(actions) {\n    var matrix = this._attrs.attrs.matrix;\n    this._attrs.attrs.matrix = MatrixUtil.transform(matrix, actions);\n    return this;\n  };\n\n  _proto.setTransform = function setTransform(actions) {\n    this._attrs.attrs.matrix = [1, 0, 0, 1, 0, 0];\n    return this.transform(actions);\n  };\n\n  _proto.translate = function translate(x, y) {\n    var matrix = this._attrs.attrs.matrix;\n    MatrixUtil.translate(matrix, matrix, [x, y]);\n  };\n\n  _proto.rotate = function rotate(rad) {\n    var matrix = this._attrs.attrs.matrix;\n    MatrixUtil.rotate(matrix, matrix, rad);\n  };\n\n  _proto.scale = function scale(sx, sy) {\n    var matrix = this._attrs.attrs.matrix;\n    MatrixUtil.scale(matrix, matrix, [sx, sy]);\n  };\n\n  _proto.moveTo = function moveTo(x, y) {\n    var cx = this._attrs.x || 0;\n    var cy = this._attrs.y || 0;\n    this.translate(x - cx, y - cy);\n    this.set('x', x);\n    this.set('y', y);\n  };\n\n  _proto.apply = function apply(v) {\n    var m = this._attrs.attrs.matrix;\n    Vector2.transformMat2d(v, v, m);\n    return this;\n  };\n\n  _proto.resetTransform = function resetTransform(context) {\n    var mo = this._attrs.attrs.matrix;\n\n    if (!isUnchanged(mo)) {\n      context.transform(mo[0], mo[1], mo[2], mo[3], mo[4], mo[5]);\n    }\n  };\n\n  _proto.isDestroyed = function isDestroyed() {\n    return this.get('destroyed');\n  };\n\n  return Element;\n}();\n\nmodule.exports = Element;\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _require = __webpack_require__(5),\n    Shape = _require.Shape;\n\nmodule.exports = {\n  getClip: function getClip(coord) {\n    var start = coord.start;\n    var end = coord.end;\n    var width = end.x - start.x;\n    var height = Math.abs(end.y - start.y);\n    var margin = 10;\n    var clip;\n\n    if (coord.isPolar) {\n      var circleRadius = coord.circleRadius,\n          center = coord.center,\n          startAngle = coord.startAngle,\n          endAngle = coord.endAngle;\n      clip = new Shape.Sector({\n        attrs: {\n          x: center.x,\n          y: center.y,\n          r: circleRadius,\n          r0: 0,\n          startAngle: startAngle,\n          endAngle: endAngle\n        }\n      });\n    } else {\n      clip = new Shape.Rect({\n        attrs: {\n          x: start.x,\n          y: end.y - margin,\n          width: width,\n          height: height + 2 * margin\n        }\n      });\n    }\n\n    clip.isClip = true;\n    return clip;\n  },\n  isPointInPlot: function isPointInPlot(point, plot) {\n    var x = point.x,\n        y = point.y;\n    var tl = plot.tl,\n        tr = plot.tr,\n        br = plot.br;\n    return x >= tl.x && x <= tr.x && y >= tl.y && y <= br.y;\n  }\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isNil = __webpack_require__(30);\n\nfunction toString(value) {\n  if (isNil(value)) return '';\n  return value.toString();\n}\n\nmodule.exports = toString;\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports) {\n\n// isFinite,\nvar isNil = function isNil(value) {\n  /**\n   * isNil(null) => true\n   * isNil() => true\n   */\n  return value === null || value === undefined;\n};\n\nmodule.exports = isNil;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObject = function isObject(value) {\n  /**\n   * isObject({}) => true\n   * isObject([1, 2, 3]) => true\n   * isObject(Function) => true\n   * isObject(null) => false\n   */\n  var type = typeof value === 'undefined' ? 'undefined' : _typeof(value);\n  return value !== null && type === 'object' || type === 'function';\n};\n\nmodule.exports = isObject;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObjectLike = __webpack_require__(55);\n\nvar isType = __webpack_require__(7);\n\nvar isPlainObject = function isPlainObject(value) {\n  /**\n   * isObjectLike(new Foo) => false\n   * isObjectLike([1, 2, 3]) => false\n   * isObjectLike({ x: 0, y: 0 }) => true\n   * isObjectLike(Object.create(null)) => true\n   */\n  if (!isObjectLike(value) || !isType(value, 'Object')) {\n    return false;\n  }\n\n  if (Object.getPrototypeOf(value) === null) {\n    return true;\n  }\n\n  var proto = value;\n\n  while (Object.getPrototypeOf(proto) !== null) {\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return Object.getPrototypeOf(value) === proto;\n};\n\nmodule.exports = isPlainObject;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isObject = __webpack_require__(31);\n\nvar isArray = __webpack_require__(20);\n\nvar each = function each(elements, func) {\n  if (!elements) {\n    return;\n  }\n\n  var rst = void 0;\n\n  if (isArray(elements)) {\n    for (var i = 0, len = elements.length; i < len; i++) {\n      rst = func(elements[i], i);\n\n      if (rst === false) {\n        break;\n      }\n    }\n  } else if (isObject(elements)) {\n    for (var k in elements) {\n      if (elements.hasOwnProperty(k)) {\n        rst = func(elements[k], k);\n\n        if (rst === false) {\n          break;\n        }\n      }\n    }\n  }\n};\n\nmodule.exports = each;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Base class of chart and geometry\n * @author dxq613@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Base =\n/*#__PURE__*/\nfunction () {\n  var _proto = Base.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {};\n  };\n\n  function Base(cfg) {\n    var attrs = {};\n    var defaultCfg = this.getDefaultCfg();\n    this._attrs = attrs;\n    Util.mix(attrs, defaultCfg, cfg);\n  }\n\n  _proto.get = function get(name) {\n    return this._attrs[name];\n  };\n\n  _proto.set = function set(name, value) {\n    this._attrs[name] = value;\n  };\n\n  _proto.destroy = function destroy() {\n    this._attrs = {};\n    this.destroyed = true;\n  };\n\n  return Base;\n}();\n\nmodule.exports = Base;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(2);\n\nvar SHAPE_MAP = {};\nvar INDEX = '_INDEX';\n\nfunction getComparer(compare) {\n  return function (left, right) {\n    var result = compare(left, right);\n    return result === 0 ? left[INDEX] - right[INDEX] : result;\n  };\n}\n\nmodule.exports = {\n  getGroupClass: function getGroupClass() {},\n  getChildren: function getChildren() {\n    return this.get('children');\n  },\n  addShape: function addShape(type, cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var canvas = this.get('canvas');\n    var shapeType = SHAPE_MAP[type];\n\n    if (!shapeType) {\n      shapeType = Util.upperFirst(type);\n      SHAPE_MAP[type] = shapeType;\n    }\n\n    cfg.canvas = canvas;\n\n    if (shapeType === 'Text' && canvas && canvas.get('fontFamily')) {\n      cfg.attrs.fontFamily = cfg.attrs.fontFamily || canvas.get('fontFamily');\n    }\n\n    var shape = new Shape[shapeType](cfg);\n    this.add(shape);\n    return shape;\n  },\n  addGroup: function addGroup(cfg) {\n    var canvas = this.get('canvas');\n    var groupClass = this.getGroupClass();\n    cfg = Util.mix({}, cfg);\n    cfg.canvas = canvas;\n    cfg.parent = this;\n    var rst = new groupClass(cfg);\n    this.add(rst);\n    return rst;\n  },\n  contain: function contain(item) {\n    var children = this.get('children');\n    return children.indexOf(item) > -1;\n  },\n  sort: function sort() {\n    var children = this.get('children');\n\n    for (var i = 0, len = children.length; i < len; i++) {\n      var child = children[i];\n      child[INDEX] = i;\n    }\n\n    children.sort(getComparer(function (obj1, obj2) {\n      return obj1.get('zIndex') - obj2.get('zIndex');\n    }));\n    return this;\n  },\n  clear: function clear() {\n    var children = this.get('children');\n\n    while (children.length !== 0) {\n      children[children.length - 1].remove(true);\n    }\n\n    return this;\n  },\n  add: function add(items) {\n    var self = this;\n    var children = self.get('children');\n\n    if (!Util.isArray(items)) {\n      items = [items];\n    }\n\n    for (var i = 0, len = items.length; i < len; i++) {\n      var item = items[i];\n      var parent = item.get('parent');\n\n      if (parent) {\n        var descendants = parent.get('children');\n        Util.Array.remove(descendants, item);\n      }\n\n      self._setEvn(item);\n\n      children.push(item);\n    }\n\n    return self;\n  },\n  _setEvn: function _setEvn(item) {\n    var self = this;\n    item._attrs.parent = self;\n    item._attrs.context = self._attrs.context;\n    item._attrs.canvas = self._attrs.canvas;\n    var clip = item._attrs.attrs.clip;\n\n    if (clip) {\n      clip.set('parent', self);\n      clip.set('context', self.get('context'));\n    }\n\n    if (item._attrs.isGroup) {\n      var children = item._attrs.children;\n\n      for (var i = 0, len = children.length; i < len; i++) {\n        item._setEvn(children[i]);\n      }\n    }\n  }\n};\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Element = __webpack_require__(27);\n\nvar Container = __webpack_require__(35);\n\nvar Vector2 = __webpack_require__(3);\n\nvar Group =\n/*#__PURE__*/\nfunction (_Element) {\n  _inheritsLoose(Group, _Element);\n\n  function Group() {\n    return _Element.apply(this, arguments) || this;\n  }\n\n  var _proto = Group.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    this._attrs = {\n      zIndex: 0,\n      visible: true,\n      destroyed: false,\n      isGroup: true,\n      children: []\n    };\n  };\n\n  _proto.drawInner = function drawInner(context) {\n    var children = this.get('children');\n\n    for (var i = 0, len = children.length; i < len; i++) {\n      var child = children[i];\n      child.draw(context);\n    }\n\n    return this;\n  };\n\n  _proto.getBBox = function getBBox() {\n    var self = this;\n    var minX = Infinity;\n    var maxX = -Infinity;\n    var minY = Infinity;\n    var maxY = -Infinity;\n    var children = self.get('children');\n\n    for (var i = 0, length = children.length; i < length; i++) {\n      var child = children[i];\n\n      if (child.get('visible')) {\n        var box = child.getBBox();\n\n        if (!box) {\n          continue;\n        }\n\n        var leftTop = [box.minX, box.minY];\n        var leftBottom = [box.minX, box.maxY];\n        var rightTop = [box.maxX, box.minY];\n        var rightBottom = [box.maxX, box.maxY];\n        var matrix = child.attr('matrix');\n        Vector2.transformMat2d(leftTop, leftTop, matrix);\n        Vector2.transformMat2d(leftBottom, leftBottom, matrix);\n        Vector2.transformMat2d(rightTop, rightTop, matrix);\n        Vector2.transformMat2d(rightBottom, rightBottom, matrix);\n        minX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], minX);\n        maxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0], maxX);\n        minY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], minY);\n        maxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1], maxY);\n      }\n    }\n\n    return {\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      x: minX,\n      y: minY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.get('destroyed')) {\n      return;\n    }\n\n    this.clear();\n\n    _Element.prototype.destroy.call(this);\n  };\n\n  return Group;\n}(Element);\n\nUtil.mix(Group.prototype, Container, {\n  getGroupClass: function getGroupClass() {\n    return Group;\n  }\n});\nmodule.exports = Group;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(8);\n\nvar ShapeUtil = __webpack_require__(19);\n\nvar Global = __webpack_require__(1); // register line geom\n\n\nvar Line = Shape.registerFactory('line', {\n  defaultShapeType: 'line'\n});\n\nfunction getStyle(cfg) {\n  var style = {\n    strokeStyle: cfg.color\n  };\n\n  if (cfg.size >= 0) {\n    style.lineWidth = cfg.size;\n  }\n\n  Util.mix(style, cfg.style);\n  return Util.mix({}, Global.shape.line, style);\n}\n\nfunction drawLines(cfg, container, style, smooth) {\n  var points = cfg.points;\n\n  if (points.length && Util.isArray(points[0].y)) {\n    var topPoints = [];\n    var bottomPoints = [];\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n      var tmp = ShapeUtil.splitPoints(point);\n      bottomPoints.push(tmp[0]);\n      topPoints.push(tmp[1]);\n    }\n\n    if (cfg.isInCircle) {\n      topPoints.push(topPoints[0]);\n      bottomPoints.push(bottomPoints[0]);\n    }\n\n    if (cfg.isStack) {\n      return container.addShape('Polyline', {\n        className: 'line',\n        attrs: Util.mix({\n          points: topPoints,\n          smooth: smooth\n        }, style)\n      });\n    }\n\n    var topShape = container.addShape('Polyline', {\n      className: 'line',\n      attrs: Util.mix({\n        points: topPoints,\n        smooth: smooth\n      }, style)\n    });\n    var bottomShape = container.addShape('Polyline', {\n      className: 'line',\n      attrs: Util.mix({\n        points: bottomPoints,\n        smooth: smooth\n      }, style)\n    });\n    return [topShape, bottomShape];\n  }\n\n  if (cfg.isInCircle) {\n    points.push(points[0]);\n  }\n\n  return container.addShape('Polyline', {\n    className: 'line',\n    attrs: Util.mix({\n      points: points,\n      smooth: smooth\n    }, style)\n  });\n}\n\nvar SHAPES = ['line', 'smooth', 'dash'];\nUtil.each(SHAPES, function (shapeType) {\n  Shape.registerShape('line', shapeType, {\n    draw: function draw(cfg, container) {\n      var smooth = shapeType === 'smooth';\n      var style = getStyle(cfg);\n\n      if (shapeType === 'dash') {\n        style.lineDash = Global.lineDash;\n      }\n\n      return drawLines(cfg, container, style, smooth);\n    }\n  });\n});\nmodule.exports = Line;\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(12);\n\nvar catAuto = __webpack_require__(39);\n\nvar each = __webpack_require__(4);\n\nvar isNumber = __webpack_require__(17);\n\nvar isString = __webpack_require__(18);\n\nvar Category =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Category, _Base);\n\n  function Category() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Category.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    this.type = 'cat';\n    /**\n     * 是否分类度量\n     * @type {Boolean}\n     */\n\n    this.isCategory = true;\n    this.isRounding = true; // 是否进行取整操作\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.init = function init() {\n    var self = this;\n    var values = self.values;\n    var tickCount = self.tickCount;\n    each(values, function (v, i) {\n      values[i] = v.toString();\n    });\n\n    if (!self.ticks) {\n      var ticks = values;\n\n      if (tickCount) {\n        var temp = catAuto({\n          maxCount: tickCount,\n          data: values,\n          isRounding: self.isRounding\n        });\n        ticks = temp.ticks;\n      }\n\n      this.ticks = ticks;\n    }\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.getText = function getText(value) {\n    if (this.values.indexOf(value) === -1 && isNumber(value)) {\n      value = this.values[Math.round(value)];\n    }\n\n    return _Base.prototype.getText.call(this, value);\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.translate = function translate(value) {\n    var index = this.values.indexOf(value);\n\n    if (index === -1 && isNumber(value)) {\n      index = value;\n    } else if (index === -1) {\n      index = NaN;\n    }\n\n    return index;\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.scale = function scale(value) {\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    var percent;\n\n    if (isString(value) || this.values.indexOf(value) !== -1) {\n      value = this.translate(value);\n    }\n\n    if (this.values.length > 1) {\n      percent = value / (this.values.length - 1);\n    } else {\n      percent = value;\n    }\n\n    return rangeMin + percent * (rangeMax - rangeMin);\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.invert = function invert(value) {\n    if (isString(value)) {\n      // 如果已经是字符串\n      return value;\n    }\n\n    var min = this.rangeMin();\n    var max = this.rangeMax(); // 归一到 范围内\n\n    if (value < min) {\n      value = min;\n    }\n\n    if (value > max) {\n      value = max;\n    }\n\n    var percent = (value - min) / (max - min);\n    var index = Math.round(percent * (this.values.length - 1)) % this.values.length;\n    index = index || 0;\n    return this.values[index];\n  };\n\n  return Category;\n}(Base);\n\nBase.Cat = Category;\nmodule.exports = Category;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 计算分类的的坐标点\n * @author dxq613@gmail.com\n */\nvar each = __webpack_require__(4);\n\nvar MAX_COUNT = 8;\nvar SUB_COUNT = 4; // 控制个数不能过小\n\nfunction getSimpleArray(data) {\n  var arr = [];\n  each(data, function (sub) {\n    arr = arr.concat(sub);\n  });\n  return arr;\n}\n\nfunction getGreatestFactor(count, number) {\n  var i;\n\n  for (i = number; i > 0; i--) {\n    if (count % i === 0) {\n      break;\n    }\n  } // 如果是素数，没有可以整除的数字\n\n\n  if (i === 1) {\n    for (i = number; i > 0; i--) {\n      if ((count - 1) % i === 0) {\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nmodule.exports = function (info) {\n  var rst = {};\n  var ticks = [];\n  var isRounding = info.isRounding;\n  var categories = getSimpleArray(info.data);\n  var length = categories.length;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var tickCount;\n\n  if (isRounding) {\n    // 取整操作\n    tickCount = getGreatestFactor(length - 1, maxCount - 1) + 1; // 如果计算出来只有两个坐标点，则直接使用传入的 maxCount\n\n    if (tickCount === 2) {\n      tickCount = maxCount;\n    } else if (tickCount < maxCount - SUB_COUNT) {\n      tickCount = maxCount - SUB_COUNT;\n    }\n  } else {\n    tickCount = maxCount;\n  }\n\n  if (!isRounding && length <= tickCount + tickCount / 2) {\n    ticks = [].concat(categories);\n  } else {\n    var step = parseInt(length / (tickCount - 1), 10);\n    var groups = categories.map(function (e, i) {\n      return i % step === 0 ? categories.slice(i, i + step) : null;\n    }).filter(function (e) {\n      return e;\n    });\n\n    for (var i = 1, groupLen = groups.length; i < groupLen && (isRounding ? i * step < length - step : i < tickCount - 1); i++) {\n      ticks.push(groups[i][0]);\n    }\n\n    if (categories.length) {\n      ticks.unshift(categories[0]);\n      var last = categories[length - 1];\n\n      if (ticks.indexOf(last) === -1) {\n        ticks.push(last);\n      }\n    }\n  }\n\n  rst.categories = categories;\n  rst.ticks = ticks;\n  return rst;\n};\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports) {\n\nmodule.exports = {\n  requestAnimationFrame: typeof window === 'object' && window.requestAnimationFrame ? window.requestAnimationFrame : function (fn) {\n    return setTimeout(fn, 16);\n  }\n};\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview convert the line to curve\n * @author dxq613@gmail.com\n */\nvar Vector2 = __webpack_require__(3);\n\nfunction getPoint(v) {\n  return [v.x, v.y];\n}\n\nfunction smoothBezier(points, smooth, isLoop, constraint) {\n  var cps = [];\n  var prevPoint;\n  var nextPoint;\n  var hasConstraint = !!constraint;\n  var min;\n  var max;\n  var point;\n  var len;\n  var l;\n  var i;\n\n  if (hasConstraint) {\n    min = [Infinity, Infinity];\n    max = [-Infinity, -Infinity];\n\n    for (i = 0, l = points.length; i < l; i++) {\n      point = getPoint(points[i]);\n      Vector2.min(min, min, point);\n      Vector2.max(max, max, point);\n    }\n\n    Vector2.min(min, min, constraint[0]);\n    Vector2.max(max, max, constraint[1]);\n  }\n\n  for (i = 0, len = points.length; i < len; i++) {\n    point = getPoint(points[i]);\n\n    if (isLoop) {\n      prevPoint = getPoint(points[i ? i - 1 : len - 1]);\n      nextPoint = getPoint(points[(i + 1) % len]);\n    } else {\n      if (i === 0 || i === len - 1) {\n        cps.push([point[0], point[1]]);\n        continue;\n      } else {\n        prevPoint = getPoint(points[i - 1]);\n        nextPoint = getPoint(points[i + 1]);\n      }\n    }\n\n    var v = Vector2.sub([], nextPoint, prevPoint);\n    Vector2.scale(v, v, smooth);\n    var d0 = Vector2.distance(point, prevPoint);\n    var d1 = Vector2.distance(point, nextPoint);\n    var sum = d0 + d1;\n\n    if (sum !== 0) {\n      d0 /= sum;\n      d1 /= sum;\n    }\n\n    var v1 = Vector2.scale([], v, -d0);\n    var v2 = Vector2.scale([], v, d1);\n    var cp0 = Vector2.add([], point, v1);\n    var cp1 = Vector2.add([], point, v2);\n\n    if (hasConstraint) {\n      Vector2.max(cp0, cp0, min);\n      Vector2.min(cp0, cp0, max);\n      Vector2.max(cp1, cp1, min);\n      Vector2.min(cp1, cp1, max);\n    }\n\n    cps.push([cp0[0], cp0[1]]);\n    cps.push([cp1[0], cp1[1]]);\n  }\n\n  if (isLoop) {\n    cps.push(cps.shift());\n  }\n\n  return cps;\n}\n\nfunction catmullRom2bezier(pointList, z, constraint) {\n  var isLoop = !!z;\n  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);\n  var len = pointList.length;\n  var d1 = [];\n  var cp1;\n  var cp2;\n  var p;\n\n  for (var i = 0; i < len - 1; i++) {\n    cp1 = controlPointList[i * 2];\n    cp2 = controlPointList[i * 2 + 1];\n    p = pointList[i + 1];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);\n  }\n\n  if (isLoop) {\n    cp1 = controlPointList[len];\n    cp2 = controlPointList[len + 1];\n    p = pointList[0];\n    d1.push(['C', cp1[0], cp1[1], cp2[0], cp2[1], p.x, p.y]);\n  }\n\n  return d1;\n}\n\nmodule.exports = {\n  smooth: catmullRom2bezier\n};\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Geom = __webpack_require__(6);\n\nvar ShapeUtil = __webpack_require__(19);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(37);\n\nvar Path =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Path, _Geom);\n\n  function Path() {\n    return _Geom.apply(this, arguments) || this;\n  }\n\n  var _proto = Path.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'path';\n    cfg.shapeType = 'line';\n    return cfg;\n  };\n\n  _proto.getDrawCfg = function getDrawCfg(obj) {\n    var cfg = _Geom.prototype.getDrawCfg.call(this, obj);\n\n    cfg.isStack = this.hasAdjust('stack');\n    return cfg;\n  };\n\n  _proto.draw = function draw(data, shapeFactory) {\n    var self = this;\n    var container = self.get('container');\n    var yScale = self.getYScale();\n    var connectNulls = self.get('connectNulls');\n    var splitArray = ShapeUtil.splitArray(data, yScale.field, connectNulls);\n    var cfg = this.getDrawCfg(data[0]);\n    cfg.origin = data;\n    Util.each(splitArray, function (subData, splitedIndex) {\n      cfg.splitedIndex = splitedIndex;\n      cfg.points = subData;\n      self.drawShape(cfg.shape, data[0], cfg, container, shapeFactory);\n    });\n  };\n\n  return Path;\n}(Geom);\n\nGeom.Path = Path;\nmodule.exports = Path;\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview Utility for calculate the with ratui in x axis\n * @author sima.zhang1990@gmail.com\n * @author dxq613@gmail.com\n */\nvar Global = __webpack_require__(1);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = {\n  getDefalutSize: function getDefalutSize() {\n    var defaultSize = this.get('defaultSize');\n\n    if (!defaultSize) {\n      var coord = this.get('coord');\n      var xScale = this.getXScale();\n      var dataArray = this.get('dataArray');\n      var values = Util.uniq(xScale.values);\n      var count = values.length;\n      var range = xScale.range;\n      var normalizeSize = 1 / count;\n      var widthRatio = 1;\n\n      if (coord && coord.isPolar) {\n        if (coord.transposed && count > 1) {\n          widthRatio = Global.widthRatio.multiplePie;\n        } else {\n          widthRatio = Global.widthRatio.rose;\n        }\n      } else {\n        if (xScale.isLinear) {\n          normalizeSize *= range[1] - range[0];\n        }\n\n        widthRatio = Global.widthRatio.column;\n      }\n\n      normalizeSize *= widthRatio;\n\n      if (this.hasAdjust('dodge')) {\n        normalizeSize = normalizeSize / dataArray.length;\n      }\n\n      defaultSize = normalizeSize;\n      this.set('defaultSize', defaultSize);\n    }\n\n    return defaultSize;\n  },\n  getDimWidth: function getDimWidth(dimName) {\n    var coord = this.get('coord');\n    var start = coord.convertPoint({\n      x: 0,\n      y: 0\n    });\n    var end = coord.convertPoint({\n      x: dimName === 'x' ? 1 : 0,\n      y: dimName === 'x' ? 0 : 1\n    });\n    var width = 0;\n\n    if (start && end) {\n      width = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));\n    }\n\n    return width;\n  },\n  _getWidth: function _getWidth() {\n    var width = this.get('_width');\n\n    if (!width) {\n      var coord = this.get('coord');\n\n      if (coord && coord.isPolar && !coord.transposed) {\n        width = (coord.endAngle - coord.startAngle) * coord.circleRadius;\n      } else {\n        width = this.getDimWidth('x');\n      }\n\n      this.set('_width', width);\n    }\n\n    return width;\n  },\n  _toNormalizedSize: function _toNormalizedSize(size) {\n    var width = this._getWidth();\n\n    return size / width;\n  },\n  _toCoordSize: function _toCoordSize(normalizeSize) {\n    var width = this._getWidth();\n\n    return width * normalizeSize;\n  },\n  getNormalizedSize: function getNormalizedSize(obj) {\n    var size = this.getAttrValue('size', obj);\n\n    if (Util.isNil(size)) {\n      size = this.getDefalutSize();\n    } else {\n      size = this._toNormalizedSize(size);\n    }\n\n    return size;\n  },\n  getSize: function getSize(obj) {\n    var size = this.getAttrValue('size', obj);\n\n    if (Util.isNil(size)) {\n      var normalizeSize = this.getDefalutSize();\n      size = this._toCoordSize(normalizeSize);\n    }\n\n    return size;\n  }\n};\nmodule.exports = SizeMixin;\n\n/***/ }),\n/* 44 */,\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Core = {};\n\nvar Global = __webpack_require__(1);\n\nCore.Global = Global;\nCore.version = Global.version;\nCore.Chart = __webpack_require__(15);\nCore.Shape = __webpack_require__(8);\nCore.G = __webpack_require__(5);\nCore.Util = __webpack_require__(0); // Core.track = function(enable) {\n//   Global.trackable = enable;\n// };\n// require('./track');\n// 2018-12-27 关闭打点\n\nCore.track = function () {\n  return null;\n};\n\nmodule.exports = Core;\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview default theme\n * @author dxq613@gail.com\n */\nvar Util = __webpack_require__(0);\n\nvar color1 = '#E8E8E8'; // color of axis-line and axis-grid\n\nvar color2 = '#808080'; // color of axis label\n\nvar defaultAxis = {\n  label: {\n    fill: color2,\n    fontSize: 10\n  },\n  line: {\n    stroke: color1,\n    lineWidth: 1\n  },\n  grid: {\n    type: 'line',\n    stroke: color1,\n    lineWidth: 1,\n    lineDash: [2]\n  },\n  tickLine: null,\n  labelOffset: 7.5\n};\nvar Theme = {\n  fontFamily: '\"Helvetica Neue\", \"San Francisco\", Helvetica, Tahoma, Arial, \"PingFang SC\", \"Hiragino Sans GB\", \"Heiti SC\", \"Microsoft YaHei\", sans-serif',\n  defaultColor: '#1890FF',\n  pixelRatio: 1,\n  padding: 'auto',\n  appendPadding: 15,\n  colors: ['#1890FF', '#2FC25B', '#FACC14', '#223273', '#8543E0', '#13C2C2', '#3436C7', '#F04864'],\n  shapes: {\n    line: ['line', 'dash'],\n    point: ['circle', 'hollowCircle']\n  },\n  sizes: [4, 10],\n  axis: {\n    common: defaultAxis,\n    // common axis configuration\n    bottom: Util.mix({}, defaultAxis, {\n      grid: null\n    }),\n    left: Util.mix({}, defaultAxis, {\n      line: null\n    }),\n    right: Util.mix({}, defaultAxis, {\n      line: null\n    }),\n    circle: Util.mix({}, defaultAxis, {\n      line: null\n    }),\n    radius: Util.mix({}, defaultAxis, {\n      labelOffset: 4\n    })\n  },\n  shape: {\n    line: {\n      lineWidth: 2,\n      lineJoin: 'round',\n      lineCap: 'round'\n    },\n    point: {\n      lineWidth: 0,\n      size: 3\n    },\n    area: {\n      fillOpacity: 0.1\n    }\n  },\n  _defaultAxis: defaultAxis\n};\nmodule.exports = Theme;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports) {\n\nvar DomUtil;\n/**\n * Detects support for options object argument in addEventListener.\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\n * @private\n */\n\nvar supportsEventListenerOptions = function () {\n  var supports = false;\n\n  try {\n    var options = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supports = true;\n      }\n    });\n    window.addEventListener('e', null, options);\n  } catch (e) {// continue regardless of error\n  }\n\n  return supports;\n}(); // Default passive to true as expected by Chrome for 'touchstart' and 'touchend' events.\n// https://github.com/chartjs/Chart.js/issues/4287\n\n\nvar eventListenerOptions = supportsEventListenerOptions ? {\n  passive: true\n} : false;\n\nfunction createEvent(type, chart, x, y, nativeEvent) {\n  return {\n    type: type,\n    chart: chart,\n    native: nativeEvent || null,\n    x: x !== undefined ? x : null,\n    y: y !== undefined ? y : null\n  };\n}\n\nfunction fromNativeEvent(event, chart) {\n  var type = event.type;\n  var point = {};\n  var touches = event.targetTouches;\n\n  if (touches && touches.length > 0) {\n    point.x = touches[0].clientX;\n    point.y = touches[0].clientY;\n  } else {\n    point.x = event.clientX;\n    point.y = event.clientY;\n  }\n\n  var canvas = chart.get('canvas');\n  var pos = DomUtil.getRelativePosition(point, canvas);\n  return createEvent(type, chart, pos.x, pos.y, event);\n}\n\nDomUtil = {\n  /* global wx, my, module */\n  isWx: typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function',\n  // weixin miniprogram\n  isMy: typeof my === 'object' && typeof my.getSystemInfoSync === 'function',\n  // ant miniprogram\n  isNode: typeof module !== 'undefined' && typeof module.exports !== 'undefined',\n  // in node\n  isBrowser: typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.sessionStorage !== 'undefined',\n  // in browser\n  getPixelRatio: function getPixelRatio() {\n    return window && window.devicePixelRatio || 1;\n  },\n  getStyle: function getStyle(el, property) {\n    return el.currentStyle ? el.currentStyle[property] : document.defaultView.getComputedStyle(el, null).getPropertyValue(property);\n  },\n  getWidth: function getWidth(el) {\n    var width = this.getStyle(el, 'width');\n\n    if (width === 'auto') {\n      width = el.offsetWidth;\n    }\n\n    return parseFloat(width);\n  },\n  getHeight: function getHeight(el) {\n    var height = this.getStyle(el, 'height');\n\n    if (height === 'auto') {\n      height = el.offsetHeight;\n    }\n\n    return parseFloat(height);\n  },\n  getDomById: function getDomById(id) {\n    if (!id) {\n      return null;\n    }\n\n    return document.getElementById(id);\n  },\n  getRelativePosition: function getRelativePosition(point, canvas) {\n    var canvasDom = canvas.get('el');\n\n    var _canvasDom$getBoundin = canvasDom.getBoundingClientRect(),\n        top = _canvasDom$getBoundin.top,\n        right = _canvasDom$getBoundin.right,\n        bottom = _canvasDom$getBoundin.bottom,\n        left = _canvasDom$getBoundin.left;\n\n    var paddingLeft = parseFloat(this.getStyle(canvasDom, 'padding-left'));\n    var paddingTop = parseFloat(this.getStyle(canvasDom, 'padding-top'));\n    var paddingRight = parseFloat(this.getStyle(canvasDom, 'padding-right'));\n    var paddingBottom = parseFloat(this.getStyle(canvasDom, 'padding-bottom'));\n    var width = right - left - paddingLeft - paddingRight;\n    var height = bottom - top - paddingTop - paddingBottom;\n    var pixelRatio = canvas.get('pixelRatio');\n    var mouseX = (point.x - left - paddingLeft) / width * canvasDom.width / pixelRatio;\n    var mouseY = (point.y - top - paddingTop) / height * canvasDom.height / pixelRatio;\n    return {\n      x: mouseX,\n      y: mouseY\n    };\n  },\n  addEventListener: function addEventListener(source, type, listener) {\n    DomUtil.isBrowser && source.addEventListener(type, listener, eventListenerOptions);\n  },\n  removeEventListener: function removeEventListener(source, type, listener) {\n    DomUtil.isBrowser && source.removeEventListener(type, listener, eventListenerOptions);\n  },\n  createEvent: function createEvent(event, chart) {\n    return fromNativeEvent(event, chart);\n  },\n  measureText: function measureText(text, font, ctx) {\n    if (!ctx) {\n      ctx = document.createElement('canvas').getContext('2d');\n    }\n\n    ctx.font = font || '12px sans-serif';\n    return ctx.measureText(text);\n  }\n};\nmodule.exports = DomUtil;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(29);\n\nvar upperFirst = function upperFirst(value) {\n  var str = toString(value);\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nmodule.exports = upperFirst;\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar toString = __webpack_require__(29);\n\nvar lowerFirst = function lowerFirst(value) {\n  var str = toString(value);\n  return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\nmodule.exports = lowerFirst;\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(7);\n\nvar isString = function isString(str) {\n  return isType(str, 'String');\n};\n\nmodule.exports = isString;\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 判断是否数字\n * @return {Boolean} 是否数字\n */\nvar isType = __webpack_require__(7);\n\nvar isNumber = function isNumber(value) {\n  return isType(value, 'Number');\n};\n\nmodule.exports = isNumber;\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否是布尔类型\n *\n * @param {Object} value 测试的值\n * @return {Boolean}\n */\nvar isType = __webpack_require__(7);\n\nvar isBoolean = function isBoolean(value) {\n  return isType(value, 'Boolean');\n};\n\nmodule.exports = isBoolean;\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * 是否为函数\n * @param  {*} fn 对象\n * @return {Boolean}  是否函数\n */\nvar isType = __webpack_require__(7);\n\nvar isFunction = function isFunction(value) {\n  return isType(value, 'Function');\n};\n\nmodule.exports = isFunction;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(7);\n\nvar isDate = function isDate(value) {\n  return isType(value, 'Date');\n};\n\nmodule.exports = isDate;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar isObjectLike = function isObjectLike(value) {\n  /**\n   * isObjectLike({}) => true\n   * isObjectLike([1, 2, 3]) => true\n   * isObjectLike(Function) => false\n   * isObjectLike(null) => false\n   */\n  return (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value !== null;\n};\n\nmodule.exports = isObjectLike;\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isPlainObject = __webpack_require__(32);\n\nvar isArray = __webpack_require__(20);\n\nvar MAX_MIX_LEVEL = 5;\n\nfunction _deepMix(dist, src, level, maxLevel) {\n  level = level || 0;\n  maxLevel = maxLevel || MAX_MIX_LEVEL;\n\n  for (var key in src) {\n    if (src.hasOwnProperty(key)) {\n      var value = src[key];\n\n      if (value !== null && isPlainObject(value)) {\n        if (!isPlainObject(dist[key])) {\n          dist[key] = {};\n        }\n\n        if (level < maxLevel) {\n          _deepMix(dist[key], value, level + 1, maxLevel);\n        } else {\n          dist[key] = src[key];\n        }\n      } else if (isArray(value)) {\n        dist[key] = [];\n        dist[key] = dist[key].concat(value);\n      } else if (value !== undefined) {\n        dist[key] = value;\n      }\n    }\n  }\n}\n\nvar deepMix = function deepMix() {\n  var args = new Array(arguments.length);\n  var length = args.length;\n\n  for (var i = 0; i < length; i++) {\n    args[i] = arguments[i];\n  }\n\n  var rst = args[0];\n\n  for (var _i = 1; _i < length; _i++) {\n    _deepMix(rst, args[_i]);\n  }\n\n  return rst;\n};\n\nmodule.exports = deepMix;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports) {\n\nfunction _mix(dist, obj) {\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key) && key !== 'constructor' && obj[key] !== undefined) {\n      dist[key] = obj[key];\n    }\n  }\n}\n\nvar mix = function mix(dist, src1, src2, src3) {\n  if (src1) _mix(dist, src1);\n  if (src2) _mix(dist, src2);\n  if (src3) _mix(dist, src3);\n  return dist;\n};\n\nmodule.exports = mix;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar each = __webpack_require__(33);\n\nvar contains = __webpack_require__(59);\n\nvar uniq = function uniq(arr) {\n  var resultArr = [];\n  each(arr, function (item) {\n    if (!contains(resultArr, item)) {\n      resultArr.push(item);\n    }\n  });\n  return resultArr;\n};\n\nmodule.exports = uniq;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isArrayLike = __webpack_require__(60);\n\nvar indexOf = Array.prototype.indexOf;\n\nvar contains = function contains(arr, value) {\n  if (!isArrayLike(arr)) {\n    return false;\n  }\n\n  return indexOf.call(arr, value) > -1;\n};\n\nmodule.exports = contains;\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports) {\n\nvar isArrayLike = function isArrayLike(value) {\n  /**\n   * isArrayLike([1, 2, 3]) => true\n   * isArrayLike(document.body.children) => true\n   * isArrayLike('abc') => true\n   * isArrayLike(Function) => false\n   */\n  return value !== null && typeof value !== 'function' && isFinite(value.length);\n};\n\nmodule.exports = isArrayLike;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Plot =\n/*#__PURE__*/\nfunction () {\n  function Plot(cfg) {\n    Util.mix(this, cfg);\n\n    this._init();\n  }\n\n  var _proto = Plot.prototype;\n\n  _proto._init = function _init() {\n    var self = this;\n    var start = self.start;\n    var end = self.end;\n    var xMin = Math.min(start.x, end.x);\n    var xMax = Math.max(start.x, end.x);\n    var yMin = Math.min(start.y, end.y);\n    var yMax = Math.max(start.y, end.y);\n    this.tl = {\n      x: xMin,\n      y: yMin\n    };\n    this.tr = {\n      x: xMax,\n      y: yMin\n    };\n    this.bl = {\n      x: xMin,\n      y: yMax\n    };\n    this.br = {\n      x: xMax,\n      y: yMax\n    };\n    this.width = xMax - xMin;\n    this.height = yMax - yMin;\n  }\n  /**\n   * reset\n   * @param  {Object} start start point\n   * @param  {Object} end end point\n   */\n  ;\n\n  _proto.reset = function reset(start, end) {\n    this.start = start;\n    this.end = end;\n\n    this._init();\n  }\n  /**\n   * check the point is in the range of plot\n   * @param  {Nubmer}  x x value\n   * @param  {[type]}  y y value\n   * @return {Boolean} return the result\n   */\n  ;\n\n  _proto.isInRange = function isInRange(x, y) {\n    if (Util.isObject(x)) {\n      y = x.y;\n      x = x.x;\n    }\n\n    var tl = this.tl;\n    var br = this.br;\n    return tl.x <= x && x <= br.x && tl.y <= y && y <= br.y;\n  };\n\n  return Plot;\n}();\n\nmodule.exports = Plot;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Coord = __webpack_require__(21);\n\n__webpack_require__(63);\n\nmodule.exports = Coord;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Base = __webpack_require__(21);\n\nvar Cartesian =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Cartesian, _Base);\n\n  function Cartesian() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Cartesian.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'cartesian';\n    this.transposed = false;\n    this.isRect = true;\n  };\n\n  _proto.init = function init(start, end) {\n    this.x = {\n      start: start.x,\n      end: end.x\n    };\n    this.y = {\n      start: start.y,\n      end: end.y\n    };\n  };\n\n  _proto.convertPoint = function convertPoint(point) {\n    var self = this;\n    var transposed = self.transposed;\n    var xDim = transposed ? 'y' : 'x';\n    var yDim = transposed ? 'x' : 'y';\n    var x = self.x;\n    var y = self.y;\n    return {\n      x: x.start + (x.end - x.start) * point[xDim],\n      y: y.start + (y.end - y.start) * point[yDim]\n    };\n  };\n\n  _proto.invertPoint = function invertPoint(point) {\n    var self = this;\n    var transposed = self.transposed;\n    var xDim = transposed ? 'y' : 'x';\n    var yDim = transposed ? 'x' : 'y';\n    var x = self.x;\n    var y = self.y;\n    var rst = {};\n    rst[xDim] = (point.x - x.start) / (x.end - x.start);\n    rst[yDim] = (point.y - y.start) / (y.end - y.start);\n    return rst;\n  };\n\n  return Cartesian;\n}(Base);\n\nBase.Cartesian = Cartesian;\nBase.Rect = Cartesian;\nmodule.exports = Cartesian;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Position: __webpack_require__(65),\n  Shape: __webpack_require__(66),\n  Size: __webpack_require__(67),\n  Color: __webpack_require__(68)\n};\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar isNil = __webpack_require__(9);\n\nvar isArray = __webpack_require__(13);\n\nvar each = __webpack_require__(4);\n\nvar Base = __webpack_require__(14);\n\nvar Position =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Position, _Base);\n\n  function Position(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['x', 'y'];\n    _this.type = 'position';\n    return _this;\n  }\n\n  var _proto = Position.prototype;\n\n  _proto.mapping = function mapping(x, y) {\n    var scales = this.scales;\n    var coord = this.coord;\n    var scaleX = scales[0];\n    var scaleY = scales[1];\n    var rstX;\n    var rstY;\n    var obj;\n\n    if (isNil(x) || isNil(y)) {\n      return [];\n    }\n\n    if (isArray(y) && isArray(x)) {\n      rstX = [];\n      rstY = [];\n\n      for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i++, j++) {\n        obj = coord.convertPoint({\n          x: scaleX.scale(x[i]),\n          y: scaleY.scale(y[j])\n        });\n        rstX.push(obj.x);\n        rstY.push(obj.y);\n      }\n    } else if (isArray(y)) {\n      x = scaleX.scale(x);\n      rstY = [];\n      each(y, function (yVal) {\n        yVal = scaleY.scale(yVal);\n        obj = coord.convertPoint({\n          x: x,\n          y: yVal\n        });\n\n        if (rstX && rstX !== obj.x) {\n          if (!isArray(rstX)) {\n            rstX = [rstX];\n          }\n\n          rstX.push(obj.x);\n        } else {\n          rstX = obj.x;\n        }\n\n        rstY.push(obj.y);\n      });\n    } else if (isArray(x)) {\n      y = scaleY.scale(y);\n      rstX = [];\n      each(x, function (xVal) {\n        xVal = scaleX.scale(xVal);\n        obj = coord.convertPoint({\n          x: xVal,\n          y: y\n        });\n\n        if (rstY && rstY !== obj.y) {\n          if (!isArray(rstY)) {\n            rstY = [rstY];\n          }\n\n          rstY.push(obj.y);\n        } else {\n          rstY = obj.y;\n        }\n\n        rstX.push(obj.x);\n      });\n    } else {\n      x = scaleX.scale(x);\n      y = scaleY.scale(y);\n      var point = coord.convertPoint({\n        x: x,\n        y: y\n      });\n      rstX = point.x;\n      rstY = point.y;\n    }\n\n    return [rstX, rstY];\n  };\n\n  return Position;\n}(Base);\n\nmodule.exports = Position;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(14);\n\nvar Shape =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Shape, _Base);\n\n  function Shape(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['shape'];\n    _this.type = 'shape';\n    _this.gradient = null;\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  var _proto = Shape.prototype;\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var values = this.values;\n    var index = Math.round((values.length - 1) * percent);\n    return values[index];\n  };\n\n  return Shape;\n}(Base);\n\nmodule.exports = Shape;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(14);\n\nvar Size =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Size, _Base);\n\n  function Size(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['size'];\n    _this.type = 'size';\n    _this.gradient = null;\n    return _this;\n  }\n\n  return Size;\n}(Base);\n\nmodule.exports = Size;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar ColorUtil = __webpack_require__(69);\n\nvar Base = __webpack_require__(14);\n\nvar Color =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Color, _Base);\n\n  function Color(cfg) {\n    var _this;\n\n    _this = _Base.call(this, cfg) || this;\n    _this.names = ['color'];\n    _this.type = 'color';\n    _this.gradient = null;\n\n    if (Util.isString(_this.values)) {\n      _this.linear = true;\n    }\n\n    return _this;\n  }\n  /**\n   * @override\n   */\n\n\n  var _proto = Color.prototype;\n\n  _proto.getLinearValue = function getLinearValue(percent) {\n    var gradient = this.gradient;\n\n    if (!gradient) {\n      var values = this.values;\n      gradient = ColorUtil.gradient(values);\n      this.gradient = gradient;\n    }\n\n    return gradient(percent);\n  };\n\n  return Color;\n}(Base);\n\nmodule.exports = Color;\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0); // Get the interpolation between colors\n\n\nfunction getValue(start, end, percent, index) {\n  var value = start[index] + (end[index] - start[index]) * percent;\n  return value;\n} // convert to hex\n\n\nfunction arr2hex(arr) {\n  return '#' + toRGBValue(arr[0]) + toRGBValue(arr[1]) + toRGBValue(arr[2]);\n}\n\nfunction toRGBValue(value) {\n  value = Math.round(value);\n  value = value.toString(16);\n\n  if (value.length === 1) {\n    value = '0' + value;\n  }\n\n  return value;\n}\n\nfunction calColor(colors, percent) {\n  var steps = colors.length - 1;\n  var step = Math.floor(steps * percent);\n  var left = steps * percent - step;\n  var start = colors[step];\n  var end = step === steps ? start : colors[step + 1];\n  var rgb = arr2hex([getValue(start, end, left, 0), getValue(start, end, left, 1), getValue(start, end, left, 2)]);\n  return rgb;\n}\n\nfunction hex2arr(str) {\n  var arr = [];\n  arr.push(parseInt(str.substr(1, 2), 16));\n  arr.push(parseInt(str.substr(3, 2), 16));\n  arr.push(parseInt(str.substr(5, 2), 16));\n  return arr;\n}\n\nvar colorCache = {\n  black: '#000000',\n  blue: '#0000ff',\n  grey: '#808080',\n  green: '#008000',\n  orange: '#ffa500',\n  pink: '#ffc0cb',\n  purple: '#800080',\n  red: '#ff0000',\n  white: '#ffffff',\n  yellow: '#ffff00'\n};\nvar ColorUtil = {\n  /**\n   * Returns a hexadecimal string representing this color in RGB space, such as #f7eaba.\n   * @param  {String} color color value\n   * @return {String} Returns a hexadecimal string\n   */\n  toHex: function toHex(color) {\n    if (colorCache[color]) {\n      return colorCache[color];\n    }\n\n    if (color[0] === '#') {\n      if (color.length === 7) {\n        return color;\n      }\n\n      var hex = color.replace(/^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i, function (m, r, g, b) {\n        return '#' + r + r + g + g + b + b;\n      }); // hex3 to hex6\n\n      colorCache[color] = hex;\n      return hex;\n    } // rgb/rgba to hex\n\n\n    var rst = color.match(/^rgba?[\\s+]?\\([\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?,[\\s+]?(\\d+)[\\s+]?/i);\n    rst.shift();\n    rst = arr2hex(rst);\n    colorCache[color] = rst;\n    return rst;\n  },\n  hex2arr: hex2arr,\n\n  /**\n   * handle the gradient color\n   * @param  {Array} colors the colors\n   * @return {String} return the color value\n   */\n  gradient: function gradient(colors) {\n    var points = [];\n\n    if (Util.isString(colors)) {\n      colors = colors.split('-');\n    }\n\n    Util.each(colors, function (color) {\n      if (color.indexOf('#') === -1) {\n        color = ColorUtil.toHex(color);\n      }\n\n      points.push(hex2arr(color));\n    });\n    return function (percent) {\n      return calColor(points, percent);\n    };\n  }\n};\nmodule.exports = ColorUtil;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(1);\n\nvar Scale = __webpack_require__(71);\n\nvar SCALE_TYPES_MAP = {\n  linear: 'Linear',\n  cat: 'Cat',\n  timeCat: 'TimeCat',\n  identity: 'Identity'\n};\n\nvar ScaleController =\n/*#__PURE__*/\nfunction () {\n  function ScaleController(cfg) {\n    // defs 列定义\n    this.defs = {};\n    Util.mix(this, cfg);\n  }\n\n  var _proto = ScaleController.prototype;\n\n  _proto._getDef = function _getDef(field) {\n    var defs = this.defs;\n    var def = null;\n\n    if (Global.scales[field] || defs[field]) {\n      def = Util.mix({}, Global.scales[field]);\n      Util.each(defs[field], function (v, k) {\n        if (Util.isNil(v)) {\n          delete def[k];\n        } else {\n          def[k] = v;\n        }\n      });\n    }\n\n    return def;\n  };\n\n  _proto._getDefaultType = function _getDefaultType(field, data, def) {\n    if (def && def.type) {\n      return def.type;\n    }\n\n    var type = 'linear';\n    var value = Util.Array.firstValue(data, field);\n\n    if (Util.isArray(value)) {\n      value = value[0];\n    }\n\n    if (Util.isString(value)) {\n      type = 'cat';\n    }\n\n    return type;\n  };\n\n  _proto._getScaleCfg = function _getScaleCfg(type, field, data, def) {\n    var values;\n\n    if (def && def.values) {\n      values = def.values;\n    } else {\n      values = Util.Array.values(data, field);\n    }\n\n    var cfg = {\n      field: field,\n      values: values\n    };\n\n    if (type !== 'cat' && type !== 'timeCat') {\n      if (!def || !(def.min && def.max)) {\n        var _Util$Array$getRange = Util.Array.getRange(values),\n            min = _Util$Array$getRange.min,\n            max = _Util$Array$getRange.max;\n\n        cfg.min = min;\n        cfg.max = max;\n        cfg.nice = true;\n      }\n    } else {\n      cfg.isRounding = false; // used for tickCount calculation\n    }\n\n    return cfg;\n  };\n\n  _proto.createScale = function createScale(field, data) {\n    var self = this;\n\n    var def = self._getDef(field);\n\n    var scale;\n\n    if (!data || !data.length) {\n      if (def && def.type) {\n        def.field = field;\n        scale = new Scale[SCALE_TYPES_MAP[def.type]](def);\n      } else {\n        scale = new Scale.Identity({\n          value: field,\n          field: field.toString(),\n          values: [field]\n        });\n      }\n\n      return scale;\n    }\n\n    var firstObj = data[0];\n    var firstValue = firstObj[field];\n\n    if (firstValue === null) {\n      firstValue = Util.Array.firstValue(data, field);\n    }\n\n    if (Util.isNumber(field) || Util.isNil(firstValue) && !def) {\n      scale = new Scale.Identity({\n        value: field,\n        field: field.toString(),\n        values: [field]\n      });\n    } else {\n      var type = self._getDefaultType(field, data, def);\n\n      var cfg = self._getScaleCfg(type, field, data, def);\n\n      def && Util.mix(cfg, def);\n      scale = new Scale[SCALE_TYPES_MAP[type]](cfg);\n    }\n\n    return scale;\n  };\n\n  return ScaleController;\n}();\n\nmodule.exports = ScaleController;\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Scale = __webpack_require__(12);\n\n__webpack_require__(72);\n\n__webpack_require__(75);\n\n__webpack_require__(38);\n\nmodule.exports = Scale;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview The measurement of linear data scale function\n * @author dxq613@gmail.com\n */\n\n\nvar isNil = __webpack_require__(9);\n\nvar each = __webpack_require__(4);\n\nvar Base = __webpack_require__(12);\n\nvar numberAuto = __webpack_require__(73);\n/**\n * 线性度量\n * @class Scale.Linear\n */\n\n\nvar Linear =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Linear, _Base);\n\n  function Linear() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Linear.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    var self = this;\n    self.type = 'linear';\n    self.isLinear = true;\n    /**\n     * 是否为了用户习惯，优化min,max和ticks，如果进行优化，则会根据生成的ticks调整min,max，否则舍弃(min,max)范围之外的ticks\n     * @type {Boolean}\n     * @default false\n     */\n\n    self.nice = false;\n    /**\n     * min value of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.min = null;\n    /**\n     * min value limitted of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.minLimit = null;\n    /**\n     * max value of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.max = null;\n    /**\n     * max value limitted of the scale\n     * @type {Number}\n     * @default null\n     */\n\n    self.maxLimit = null;\n    /**\n     * 自动生成标记时的个数\n     * @type {Number}\n     * @default null\n     */\n\n    self.tickCount = null;\n    /**\n     * 坐标轴点之间的间距，指的是真实数据的差值\n     * @type {Number}\n     * @default null\n     */\n\n    self.tickInterval = null;\n    /**\n     * 坐标轴点之间的最小间距，指的是真实数据的差值\n     * @type {Number}\n     * @default null\n     */\n\n    self.minTickInterval = null;\n    /**\n     * 用于计算坐标点时逼近的数组\n     * @type {Array}\n     */\n\n    self.snapArray = null;\n  }\n  /**\n   * @protected\n   * @override\n   */\n  ;\n\n  _proto.init = function init() {\n    var self = this;\n\n    if (!self.ticks) {\n      self.min = self.translate(self.min);\n      self.max = self.translate(self.max);\n      self.initTicks();\n    } else {\n      var ticks = self.ticks;\n      var firstValue = self.translate(ticks[0]);\n      var lastValue = self.translate(ticks[ticks.length - 1]);\n\n      if (isNil(self.min) || self.min > firstValue) {\n        self.min = firstValue;\n      }\n\n      if (isNil(self.max) || self.max < lastValue) {\n        self.max = lastValue;\n      }\n    }\n  }\n  /**\n   * 计算坐标点\n   * @protected\n   * @return {Array} 计算完成的坐标点\n   */\n  ;\n\n  _proto.calculateTicks = function calculateTicks() {\n    var min = this.min,\n        max = this.max,\n        minLimit = this.minLimit,\n        maxLimit = this.maxLimit,\n        tickCount = this.tickCount,\n        tickInterval = this.tickInterval,\n        minTickInterval = this.minTickInterval,\n        snapArray = this.snapArray;\n\n    if (tickCount === 1) {\n      throw new Error('linear scale\\'tickCount should not be 1');\n    }\n\n    if (max < min) {\n      throw new Error(\"max: \" + max + \" should not be less than min: \" + min);\n    }\n\n    var tmp = numberAuto({\n      min: min,\n      max: max,\n      minLimit: minLimit,\n      maxLimit: maxLimit,\n      minCount: tickCount,\n      maxCount: tickCount,\n      interval: tickInterval,\n      minTickInterval: minTickInterval,\n      snapArray: snapArray\n    });\n    return tmp.ticks;\n  } // 初始化ticks\n  ;\n\n  _proto.initTicks = function initTicks() {\n    var self = this;\n    var calTicks = self.calculateTicks();\n\n    if (self.nice) {\n      // 如果需要优化显示的tick\n      self.ticks = calTicks;\n      self.min = calTicks[0];\n      self.max = calTicks[calTicks.length - 1];\n    } else {\n      var ticks = [];\n      each(calTicks, function (tick) {\n        if (tick >= self.min && tick <= self.max) {\n          ticks.push(tick);\n        }\n      }); // 如果 ticks 为空，直接输入最小值、最大值\n\n      if (!ticks.length) {\n        ticks.push(self.min);\n        ticks.push(self.max);\n      }\n\n      self.ticks = ticks;\n    }\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.scale = function scale(value) {\n    if (isNil(value)) {\n      return NaN;\n    }\n\n    var max = this.max;\n    var min = this.min;\n\n    if (max === min) {\n      return 0;\n    }\n\n    var percent = (value - min) / (max - min);\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    return rangeMin + percent * (rangeMax - rangeMin);\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.invert = function invert(value) {\n    var percent = (value - this.rangeMin()) / (this.rangeMax() - this.rangeMin());\n    return this.min + percent * (this.max - this.min);\n  };\n\n  return Linear;\n}(Base);\n\nBase.Linear = Linear;\nmodule.exports = Linear;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 自动计算数字坐标轴\n * @author dxq613@gmail.com\n */\nvar isNil = __webpack_require__(9);\n\nvar isNumber = __webpack_require__(17);\n\nvar AutoUtil = __webpack_require__(74);\n\nvar MIN_COUNT = 5;\nvar MAX_COUNT = 7;\nvar SNAP_COUNT_ARRAY = [0, 1, 1.2, 1.5, 1.6, 2, 2.2, 2.4, 2.5, 3, 4, 5, 6, 7.5, 8, 10];\nvar SNAP_ARRAY = [0, 1, 2, 4, 5, 10];\n\nmodule.exports = function (info) {\n  var min = info.min;\n  var max = info.max;\n  var interval = info.interval;\n  var minTickInterval = info.minTickInterval;\n  var ticks = [];\n  var minCount = info.minCount || MIN_COUNT;\n  var maxCount = info.maxCount || MAX_COUNT;\n  var isFixedCount = minCount === maxCount; // 是否限定死了个数\n\n  var minLimit = isNil(info.minLimit) ? -Infinity : info.minLimit; // 限定的最小值\n\n  var maxLimit = isNil(info.maxLimit) ? Infinity : info.maxLimit; // 限定最大值\n\n  var avgCount = (minCount + maxCount) / 2;\n  var count = avgCount; // 用户传入的逼近数组\n\n  var snapArray = info.snapArray ? info.snapArray : isFixedCount ? SNAP_COUNT_ARRAY : SNAP_ARRAY; // 如果限定大小范围，同时大小范围等于用户传入的范围，同时限定了个数，interval 按照个数均分\n\n  if (min === minLimit && max === maxLimit && isFixedCount) {\n    interval = (max - min) / (count - 1);\n  }\n\n  if (isNil(min)) {\n    min = 0;\n  }\n\n  if (isNil(max)) {\n    max = 0;\n  }\n\n  if (max === min) {\n    if (min === 0) {\n      max = 1;\n    } else {\n      if (min > 0) {\n        min = 0;\n      } else {\n        max = 0;\n      }\n    }\n\n    if (max - min < 5 && !interval && max - min >= 1) {\n      interval = 1;\n    }\n  }\n\n  if (isNil(interval)) {\n    // 计算间距\n    var temp = (max - min) / (avgCount - 1);\n    interval = AutoUtil.snapFactorTo(temp, snapArray, 'ceil');\n\n    if (maxCount !== minCount) {\n      count = parseInt((max - min) / interval, 10);\n\n      if (count > maxCount) {\n        count = maxCount;\n      }\n\n      if (count < minCount) {\n        count = minCount;\n      } // 不确定tick的个数时，使得tick偏小\n\n\n      interval = AutoUtil.snapFactorTo((max - min) / (count - 1), snapArray, 'floor');\n    }\n  } // interval should not be less than minTickInterval\n\n\n  if (isNumber(minTickInterval) && interval < minTickInterval) {\n    interval = minTickInterval;\n  }\n\n  if (info.interval || maxCount !== minCount) {\n    // 校正 max 和 min\n    max = Math.min(AutoUtil.snapMultiple(max, interval, 'ceil'), maxLimit); // 向上逼近\n\n    min = Math.max(AutoUtil.snapMultiple(min, interval, 'floor'), minLimit); // 向下逼近\n\n    count = Math.round((max - min) / interval);\n    min = AutoUtil.fixedBase(min, interval);\n    max = AutoUtil.fixedBase(max, interval);\n  } else {\n    avgCount = parseInt(avgCount, 10); // 取整\n\n    var avg = (max + min) / 2;\n    var avgTick = AutoUtil.snapMultiple(avg, interval, 'ceil');\n    var sideCount = Math.floor((avgCount - 2) / 2);\n    var maxTick = avgTick + sideCount * interval;\n    var minTick;\n\n    if (avgCount % 2 === 0) {\n      minTick = avgTick - sideCount * interval;\n    } else {\n      minTick = avgTick - (sideCount + 1) * interval;\n    }\n\n    while (maxTick < max) {\n      // 保证计算出来的刻度最大值 maxTick 不小于数据最大值 max\n      maxTick = AutoUtil.fixedBase(maxTick + interval, interval);\n    }\n\n    while (minTick > min) {\n      // 保证计算出来的刻度最小值 minTick 不小于数据最大值 min\n      minTick = AutoUtil.fixedBase(minTick - interval, interval); // 防止超常浮点数计算问题\n    }\n\n    max = maxTick;\n    min = minTick;\n  }\n\n  max = Math.min(max, maxLimit);\n  min = Math.max(min, minLimit);\n  ticks.push(min);\n\n  for (var i = 1; i < count; i++) {\n    var tickValue = AutoUtil.fixedBase(interval * i + min, interval);\n\n    if (tickValue < max) {\n      ticks.push(tickValue);\n    }\n  }\n\n  if (ticks[ticks.length - 1] < max) {\n    ticks.push(max);\n  }\n\n  return {\n    min: min,\n    max: max,\n    interval: interval,\n    count: count,\n    ticks: ticks\n  };\n};\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports) {\n\n/**\n * @fileOverview 计算方法\n * @author dxq613@gmail.com\n */\n// 如果小数点后面超过 10 位浮点数时进行一下处理\nvar DECIMAL_LENGTH = 12; // 获取系数\n\nfunction getFactor(v) {\n  var factor = 1;\n\n  if (v === Infinity || v === -Infinity) {\n    throw new Error('Not support Infinity!');\n  }\n\n  if (v < 1) {\n    var count = 0;\n\n    while (v < 1) {\n      factor = factor / 10;\n      v = v * 10;\n      count++;\n    } // 浮点数计算出现问题\n\n\n    if (factor.toString().length > DECIMAL_LENGTH) {\n      factor = parseFloat(factor.toFixed(count));\n    }\n  } else {\n    while (v > 10) {\n      factor = factor * 10;\n      v = v / 10;\n    }\n  }\n\n  return factor;\n} // 取小于当前值的\n\n\nfunction arrayFloor(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  }\n\n  var pre = values[0];\n\n  if (value < values[0]) {\n    return NaN;\n  }\n\n  if (value >= values[length - 1]) {\n    return values[length - 1];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value < values[i]) {\n      break;\n    }\n\n    pre = values[i];\n  }\n\n  return pre;\n} // 大于当前值的第一个\n\n\nfunction arrayCeiling(values, value) {\n  var length = values.length;\n\n  if (length === 0) {\n    return NaN;\n  } // var pre = values[0];\n\n\n  var rst;\n\n  if (value > values[length - 1]) {\n    return NaN;\n  }\n\n  if (value < values[0]) {\n    return values[0];\n  }\n\n  for (var i = 1; i < values.length; i++) {\n    if (value <= values[i]) {\n      rst = values[i];\n      break;\n    }\n  }\n\n  return rst;\n}\n\nvar Util = {\n  // 获取逼近的数值\n  snapFactorTo: function snapFactorTo(v, arr, snapType) {\n    // 假设 v = -512,isFloor = true\n    if (isNaN(v)) {\n      return NaN;\n    }\n\n    var factor = 1; // 计算系数\n\n    if (v !== 0) {\n      if (v < 0) {\n        factor = -1;\n      }\n\n      v = v * factor; // v = 512\n\n      var tmpFactor = getFactor(v);\n      factor = factor * tmpFactor; // factor = -100\n\n      v = v / tmpFactor; // v = 5.12\n    }\n\n    if (snapType === 'floor') {\n      v = Util.snapFloor(arr, v); // v = 5\n    } else if (snapType === 'ceil') {\n      v = Util.snapCeiling(arr, v); // v = 6\n    } else {\n      v = Util.snapTo(arr, v); // 四舍五入 5\n    }\n\n    var rst = parseFloat((v * factor).toPrecision(DECIMAL_LENGTH)); // 如果出现浮点数计算问题，需要处理一下\n    // 如果出现浮点数计算问题，需要处理一下\n\n    if (Math.abs(factor) < 1 && rst.toString().length > DECIMAL_LENGTH) {\n      var decimalVal = parseInt(1 / factor);\n      var symbol = factor > 0 ? 1 : -1;\n      rst = v / decimalVal * symbol;\n    }\n\n    return rst;\n  },\n  // 获取逼近的倍数\n  snapMultiple: function snapMultiple(v, base, snapType) {\n    var div;\n\n    if (snapType === 'ceil') {\n      div = Math.ceil(v / base);\n    } else if (snapType === 'floor') {\n      div = Math.floor(v / base);\n    } else {\n      div = Math.round(v / base);\n    }\n\n    return div * base;\n  },\n\n  /**\n   * 获取逼近的值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的值\n   */\n  snapTo: function snapTo(values, value) {\n    // 这里假定values是升序排列\n    var floorVal = arrayFloor(values, value);\n    var ceilingVal = arrayCeiling(values, value);\n\n    if (isNaN(floorVal) || isNaN(ceilingVal)) {\n      if (values[0] >= value) {\n        return values[0];\n      }\n\n      var last = values[values.length - 1];\n\n      if (last <= value) {\n        return last;\n      }\n    }\n\n    if (Math.abs(value - floorVal) < Math.abs(ceilingVal - value)) {\n      return floorVal;\n    }\n\n    return ceilingVal;\n  },\n\n  /**\n   * 获取逼近的最小值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最小值\n   */\n  snapFloor: function snapFloor(values, value) {\n    // 这里假定values是升序排列\n    return arrayFloor(values, value);\n  },\n\n  /**\n   * 获取逼近的最大值，用于对齐数据\n   * @param  {Array} values   数据集合\n   * @param  {Number} value   数值\n   * @return {Number} 逼近的最大值\n   */\n  snapCeiling: function snapCeiling(values, value) {\n    // 这里假定values是升序排列\n    return arrayCeiling(values, value);\n  },\n  fixedBase: function fixedBase(v, base) {\n    var str = base.toString();\n    var index = str.indexOf('.');\n\n    if (index === -1) {\n      return Math.round(v);\n    }\n\n    var length = str.substr(index + 1).length;\n\n    if (length > 20) {\n      length = 20;\n    }\n\n    return parseFloat(v.toFixed(length));\n  }\n};\nmodule.exports = Util;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Base = __webpack_require__(12);\n\nvar isNumber = __webpack_require__(17);\n\nvar Identity =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Identity, _Base);\n\n  function Identity() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Identity.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Base.prototype._initDefaultCfg.call(this);\n\n    this.isIdentity = true;\n    this.type = 'identity';\n    /**\n     * 常量值\n     * @type {*}\n     */\n\n    this.value = null;\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.getText = function getText() {\n    return this.value.toString();\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.scale = function scale(value) {\n    if (this.value !== value && isNumber(value)) {\n      return value;\n    }\n\n    return this.range[0];\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.invert = function invert() {\n    return this.value;\n  };\n\n  return Identity;\n}(Base);\n\nBase.Identity = Identity;\nmodule.exports = Identity;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Axis = __webpack_require__(77);\n\nvar Global = __webpack_require__(1);\n\nvar _require = __webpack_require__(5),\n    Shape = _require.Shape;\n\nfunction formatTicks(ticks) {\n  var tmp = ticks.slice(0);\n\n  if (tmp.length > 0) {\n    var first = tmp[0];\n    var last = tmp[tmp.length - 1];\n\n    if (first.value !== 0) {\n      tmp.unshift({\n        value: 0\n      });\n    }\n\n    if (last.value !== 1) {\n      tmp.push({\n        value: 1\n      });\n    }\n  }\n\n  return tmp;\n}\n\nvar AxisController =\n/*#__PURE__*/\nfunction () {\n  function AxisController(cfg) {\n    this.axisCfg = {};\n    this.frontPlot = null;\n    this.backPlot = null;\n    this.axes = {}; // store the axes's options\n\n    Util.mix(this, cfg);\n  }\n\n  var _proto = AxisController.prototype;\n\n  _proto._isHide = function _isHide(field) {\n    var axisCfg = this.axisCfg;\n    return !axisCfg || axisCfg[field] === false;\n  };\n\n  _proto._getLinePosition = function _getLinePosition(scale, dimType, index, transposed) {\n    var position = '';\n    var field = scale.field;\n    var axisCfg = this.axisCfg;\n\n    if (axisCfg[field] && axisCfg[field].position) {\n      position = axisCfg[field].position;\n    } else if (dimType === 'x') {\n      position = transposed ? 'left' : 'bottom';\n    } else if (dimType === 'y') {\n      position = index ? 'right' : 'left';\n\n      if (transposed) {\n        position = 'bottom';\n      }\n    }\n\n    return position;\n  };\n\n  _proto._getLineCfg = function _getLineCfg(coord, dimType, position) {\n    var start;\n    var end;\n    var factor = 1; // Mark clockwise or counterclockwise\n\n    if (dimType === 'x') {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      if (position === 'right') {\n        // there will be several y axes\n        start = {\n          x: 1,\n          y: 0\n        };\n        end = {\n          x: 1,\n          y: 1\n        };\n      } else {\n        start = {\n          x: 0,\n          y: 0\n        };\n        end = {\n          x: 0,\n          y: 1\n        };\n        factor = -1;\n      }\n    }\n\n    if (coord.transposed) {\n      factor *= -1;\n    }\n\n    return {\n      offsetFactor: factor,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  };\n\n  _proto._getCircleCfg = function _getCircleCfg(coord) {\n    return {\n      startAngle: coord.startAngle,\n      endAngle: coord.endAngle,\n      center: coord.center,\n      radius: coord.circleRadius\n    };\n  };\n\n  _proto._getRadiusCfg = function _getRadiusCfg(coord) {\n    var transposed = coord.transposed;\n    var start;\n    var end;\n\n    if (transposed) {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 1,\n        y: 0\n      };\n    } else {\n      start = {\n        x: 0,\n        y: 0\n      };\n      end = {\n        x: 0,\n        y: 1\n      };\n    }\n\n    return {\n      offsetFactor: -1,\n      start: coord.convertPoint(start),\n      end: coord.convertPoint(end)\n    };\n  };\n\n  _proto._getAxisCfg = function _getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg) {\n    var self = this;\n    var axisCfg = this.axisCfg;\n    var ticks = scale.getTicks();\n    var cfg = Util.deepMix({\n      ticks: ticks,\n      frontContainer: this.frontPlot,\n      backContainer: this.backPlot\n    }, defaultCfg, axisCfg[scale.field]);\n    var labels = [];\n    var label = cfg.label;\n    var count = ticks.length;\n    var maxWidth = 0;\n    var maxHeight = 0;\n    var labelCfg = label;\n    Util.each(ticks, function (tick, index) {\n      if (Util.isFunction(label)) {\n        var executedLabel = label(tick.text, index, count);\n        labelCfg = executedLabel ? Util.mix({}, Global._defaultAxis.label, executedLabel) : null;\n      }\n\n      if (labelCfg) {\n        var textStyle = {};\n\n        if (labelCfg.textAlign) {\n          textStyle.textAlign = labelCfg.textAlign;\n        }\n\n        if (labelCfg.textBaseline) {\n          textStyle.textBaseline = labelCfg.textBaseline;\n        }\n\n        var axisLabel = new Shape.Text({\n          className: 'axis-label',\n          attrs: Util.mix({\n            x: 0,\n            y: 0,\n            text: tick.text,\n            fontFamily: self.chart.get('canvas').get('fontFamily')\n          }, labelCfg),\n          value: tick.value,\n          textStyle: textStyle,\n          top: labelCfg.top,\n          context: self.chart.get('canvas').get('context')\n        });\n        labels.push(axisLabel);\n\n        var _axisLabel$getBBox = axisLabel.getBBox(),\n            width = _axisLabel$getBBox.width,\n            height = _axisLabel$getBBox.height;\n\n        maxWidth = Math.max(maxWidth, width);\n        maxHeight = Math.max(maxHeight, height);\n      }\n    });\n    cfg.labels = labels;\n    cfg.maxWidth = maxWidth;\n    cfg.maxHeight = maxHeight;\n    return cfg;\n  };\n\n  _proto._createAxis = function _createAxis(coord, scale, verticalScale, dimType, index) {\n    if (index === void 0) {\n      index = '';\n    }\n\n    var self = this;\n    var coordType = coord.type;\n    var transposed = coord.transposed;\n    var type;\n    var key;\n    var defaultCfg;\n\n    if (coordType === 'cartesian' || coordType === 'rect') {\n      var position = self._getLinePosition(scale, dimType, index, transposed);\n\n      defaultCfg = Global.axis[position];\n      defaultCfg.position = position;\n      type = 'Line';\n      key = position;\n    } else {\n      if (dimType === 'x' && !transposed || dimType === 'y' && transposed) {\n        defaultCfg = Global.axis.circle;\n        type = 'Circle';\n        key = 'circle';\n      } else {\n        defaultCfg = Global.axis.radius;\n        type = 'Line';\n        key = 'radius';\n      }\n    }\n\n    var cfg = self._getAxisCfg(coord, scale, verticalScale, dimType, defaultCfg);\n\n    cfg.type = type;\n    cfg.dimType = dimType;\n    cfg.verticalScale = verticalScale;\n    cfg.index = index;\n    this.axes[key] = cfg;\n  };\n\n  _proto.createAxis = function createAxis(coord, xScale, yScales) {\n    var self = this;\n\n    if (xScale && !self._isHide(xScale.field)) {\n      self._createAxis(coord, xScale, yScales[0], 'x');\n    }\n\n    Util.each(yScales, function (yScale, index) {\n      if (!self._isHide(yScale.field)) {\n        self._createAxis(coord, yScale, xScale, 'y', index);\n      }\n    });\n    var axes = this.axes;\n    var chart = self.chart;\n\n    if (chart._isAutoPadding()) {\n      var userPadding = Util.parsePadding(chart.get('padding'));\n      var appendPadding = Util.parsePadding(chart.get('appendPadding'));\n      var legendRange = chart.get('legendRange') || {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      };\n      var padding = [userPadding[0] === 'auto' ? legendRange.top + appendPadding[0] * 2 : userPadding[0], userPadding[1] === 'auto' ? legendRange.right + appendPadding[1] : userPadding[1], userPadding[2] === 'auto' ? legendRange.bottom + appendPadding[2] : userPadding[2], userPadding[3] === 'auto' ? legendRange.left + appendPadding[3] : userPadding[3]];\n\n      if (coord.isPolar) {\n        var circleAxis = axes.circle;\n\n        if (circleAxis) {\n          var maxHeight = circleAxis.maxHeight,\n              maxWidth = circleAxis.maxWidth,\n              labelOffset = circleAxis.labelOffset;\n          padding[0] += maxHeight + labelOffset;\n          padding[1] += maxWidth + labelOffset;\n          padding[2] += maxHeight + labelOffset;\n          padding[3] += maxWidth + labelOffset;\n        }\n      } else {\n        if (axes.right && userPadding[1] === 'auto') {\n          var _axes$right = axes.right,\n              _maxWidth = _axes$right.maxWidth,\n              _labelOffset = _axes$right.labelOffset;\n          padding[1] += _maxWidth + _labelOffset;\n        }\n\n        if (axes.left && userPadding[3] === 'auto') {\n          var _axes$left = axes.left,\n              _maxWidth2 = _axes$left.maxWidth,\n              _labelOffset2 = _axes$left.labelOffset;\n          padding[3] += _maxWidth2 + _labelOffset2;\n        }\n\n        if (axes.bottom && userPadding[2] === 'auto') {\n          var _axes$bottom = axes.bottom,\n              _maxHeight = _axes$bottom.maxHeight,\n              _labelOffset3 = _axes$bottom.labelOffset;\n          padding[2] += _maxHeight + _labelOffset3;\n        }\n      }\n\n      chart.set('_padding', padding);\n\n      chart._updateLayout(padding);\n    }\n\n    Util.each(axes, function (axis) {\n      var type = axis.type,\n          grid = axis.grid,\n          verticalScale = axis.verticalScale,\n          ticks = axis.ticks,\n          dimType = axis.dimType,\n          position = axis.position,\n          index = axis.index;\n      var appendCfg;\n\n      if (coord.isPolar) {\n        if (type === 'Line') {\n          appendCfg = self._getRadiusCfg(coord);\n        } else if (type === 'Circle') {\n          appendCfg = self._getCircleCfg(coord);\n        }\n      } else {\n        appendCfg = self._getLineCfg(coord, dimType, position);\n      }\n\n      if (grid && verticalScale) {\n        var gridPoints = [];\n        var verticalTicks = formatTicks(verticalScale.getTicks());\n        Util.each(ticks, function (tick) {\n          var subPoints = [];\n          Util.each(verticalTicks, function (verticalTick) {\n            var x = dimType === 'x' ? tick.value : verticalTick.value;\n            var y = dimType === 'x' ? verticalTick.value : tick.value;\n\n            if (x >= 0 && x <= 1 && y >= 0 && y <= 1) {\n              var point = coord.convertPoint({\n                x: x,\n                y: y\n              });\n              subPoints.push(point);\n            }\n          });\n          gridPoints.push({\n            points: subPoints,\n            _id: 'axis-' + dimType + index + '-grid-' + tick.tickValue\n          });\n        });\n        axis.gridPoints = gridPoints;\n\n        if (coord.isPolar) {\n          axis.center = coord.center;\n          axis.startAngle = coord.startAngle;\n          axis.endAngle = coord.endAngle;\n        }\n      }\n\n      appendCfg._id = 'axis-' + dimType;\n\n      if (!Util.isNil(index)) {\n        appendCfg._id = 'axis-' + dimType + index;\n      }\n\n      new Axis[type](Util.mix(axis, appendCfg));\n    });\n  };\n\n  _proto.clear = function clear() {\n    this.axes = {};\n    this.frontPlot.clear();\n    this.backPlot.clear();\n  };\n\n  return AxisController;\n}();\n\nmodule.exports = AxisController;\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Abstract = __webpack_require__(26);\n\n__webpack_require__(78);\n\nmodule.exports = Abstract;\n\n/***/ }),\n/* 78 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Abstract = __webpack_require__(26);\n\nvar Line =\n/*#__PURE__*/\nfunction (_Abstract) {\n  _inheritsLoose(Line, _Abstract);\n\n  function Line() {\n    return _Abstract.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Abstract.prototype._initDefaultCfg.call(this);\n\n    this.start = null;\n    this.end = null;\n  };\n\n  _proto.getOffsetPoint = function getOffsetPoint(value) {\n    var start = this.start,\n        end = this.end;\n    return {\n      x: start.x + (end.x - start.x) * value,\n      y: start.y + (end.y - start.y) * value\n    };\n  };\n\n  _proto.getAxisVector = function getAxisVector() {\n    var start = this.start,\n        end = this.end;\n    return [end.x - start.x, end.y - start.y];\n  };\n\n  _proto.drawLine = function drawLine(lineCfg) {\n    var container = this.getContainer(lineCfg.top);\n    var start = this.start,\n        end = this.end;\n    container.addShape('line', {\n      className: 'axis-line',\n      attrs: Util.mix({\n        x1: start.x,\n        y1: start.y,\n        x2: end.x,\n        y2: end.y\n      }, lineCfg)\n    });\n  };\n\n  return Line;\n}(Abstract);\n\nAbstract.Line = Line;\nmodule.exports = Line;\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Container = __webpack_require__(35);\n\nvar Group = __webpack_require__(36);\n\nvar _require = __webpack_require__(40),\n    requestAnimationFrame = _require.requestAnimationFrame;\n\nvar Canvas =\n/*#__PURE__*/\nfunction () {\n  var _proto = Canvas.prototype;\n\n  _proto.get = function get(name) {\n    return this._attrs[name];\n  };\n\n  _proto.set = function set(name, value) {\n    this._attrs[name] = value;\n  };\n\n  function Canvas(cfg) {\n    this._attrs = Util.mix({\n      type: 'canvas',\n      children: []\n    }, cfg);\n\n    this._initPixelRatio();\n\n    this._initCanvas();\n  }\n\n  _proto._initPixelRatio = function _initPixelRatio() {\n    var pixelRatio = this.get('pixelRatio');\n\n    if (!pixelRatio) {\n      this.set('pixelRatio', Util.getPixelRatio());\n    }\n  };\n\n  _proto.beforeDraw = function beforeDraw() {\n    var context = this._attrs.context;\n    var el = this._attrs.el;\n    !Util.isWx && !Util.isMy && context && context.clearRect(0, 0, el.width, el.height);\n  };\n\n  _proto._initCanvas = function _initCanvas() {\n    var self = this;\n    var el = self.get('el');\n    var context = self.get('context');\n    var canvas;\n\n    if (context) {\n      // CanvasRenderingContext2D\n      canvas = context.canvas;\n    } else if (Util.isString(el)) {\n      // HTMLElement's id\n      canvas = Util.getDomById(el);\n    } else {\n      // HTMLElement\n      canvas = el;\n    }\n\n    if (!canvas) {\n      throw new Error('Please specify the id or el of the chart!');\n    }\n\n    if (context && canvas && !canvas.getContext) {\n      canvas.getContext = function () {\n        return context;\n      };\n    }\n\n    var width = self.get('width');\n\n    if (!width) {\n      width = Util.getWidth(canvas);\n    }\n\n    var height = self.get('height');\n\n    if (!height) {\n      height = Util.getHeight(canvas);\n    }\n\n    self.set('canvas', this);\n    self.set('el', canvas);\n    self.set('context', context || canvas.getContext('2d'));\n    self.changeSize(width, height);\n  };\n\n  _proto.changeSize = function changeSize(width, height) {\n    var pixelRatio = this.get('pixelRatio');\n    var canvasDOM = this.get('el');\n\n    if (Util.isBrowser) {\n      canvasDOM.style.width = width + 'px';\n      canvasDOM.style.height = height + 'px';\n    }\n\n    if (!Util.isWx && !Util.isMy) {\n      canvasDOM.width = width * pixelRatio;\n      canvasDOM.height = height * pixelRatio;\n\n      if (pixelRatio !== 1) {\n        var ctx = this.get('context');\n        ctx.scale(pixelRatio, pixelRatio);\n      }\n    }\n\n    this.set('width', width);\n    this.set('height', height);\n  };\n\n  _proto.getWidth = function getWidth() {\n    var pixelRatio = this.get('pixelRatio');\n    var width = this.get('width');\n    return width * pixelRatio;\n  };\n\n  _proto.getHeight = function getHeight() {\n    var pixelRatio = this.get('pixelRatio');\n    var height = this.get('height');\n    return height * pixelRatio;\n  };\n\n  _proto.getPointByClient = function getPointByClient(clientX, clientY) {\n    var el = this.get('el');\n    var bbox = el.getBoundingClientRect();\n    var width = bbox.right - bbox.left;\n    var height = bbox.bottom - bbox.top;\n    return {\n      x: (clientX - bbox.left) * (el.width / width),\n      y: (clientY - bbox.top) * (el.height / height)\n    };\n  };\n\n  _proto._beginDraw = function _beginDraw() {\n    this._attrs.toDraw = true;\n  };\n\n  _proto._endDraw = function _endDraw() {\n    this._attrs.toDraw = false;\n  };\n\n  _proto.draw = function draw() {\n    var self = this;\n\n    function drawInner() {\n      self.set('animateHandler', requestAnimationFrame(function () {\n        self.set('animateHandler', undefined);\n\n        if (self.get('toDraw')) {\n          drawInner();\n        }\n      }));\n      self.beforeDraw();\n\n      try {\n        var context = self._attrs.context;\n        var children = self._attrs.children;\n\n        for (var i = 0, len = children.length; i < len; i++) {\n          var child = children[i];\n          child.draw(context);\n        }\n\n        if (Util.isWx || Util.isMy) {\n          context.draw();\n        }\n      } catch (ev) {\n        console.warn('error in draw canvas, detail as:');\n        console.warn(ev);\n\n        self._endDraw();\n      }\n\n      self._endDraw();\n    }\n\n    if (self.get('destroyed')) {\n      return;\n    }\n\n    if (self.get('animateHandler')) {\n      this._beginDraw();\n    } else {\n      drawInner();\n    }\n  };\n\n  _proto.destroy = function destroy() {\n    if (this.get('destroyed')) {\n      return;\n    }\n\n    this.clear();\n    this._attrs = {};\n    this.set('destroyed', true);\n  };\n\n  _proto.isDestroyed = function isDestroyed() {\n    return this.get('destroyed');\n  };\n\n  return Canvas;\n}();\n\nUtil.mix(Canvas.prototype, Container, {\n  getGroupClass: function getGroupClass() {\n    return Group;\n  }\n});\nmodule.exports = Canvas;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nfunction _mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction _addStop(steps, gradient) {\n  Util.each(steps, function (item) {\n    item = item.split(':');\n    gradient.addColorStop(Number(item[0]), item[1]);\n  });\n} // the string format: 'l(0) 0:#ffffff 0.5:#7ec2f3 1:#1890ff'\n\n\nfunction _parseLineGradient(color, shape, context) {\n  var arr = color.split(' ');\n  var angle = arr[0].slice(2, arr[0].length - 1);\n  angle = _mod(parseFloat(angle) * Math.PI / 180, Math.PI * 2);\n  var steps = arr.slice(1);\n\n  var _shape$getBBox = shape.getBBox(),\n      minX = _shape$getBBox.minX,\n      minY = _shape$getBBox.minY,\n      maxX = _shape$getBBox.maxX,\n      maxY = _shape$getBBox.maxY;\n\n  var start;\n  var end;\n\n  if (angle >= 0 && angle < 0.5 * Math.PI) {\n    start = {\n      x: minX,\n      y: minY\n    };\n    end = {\n      x: maxX,\n      y: maxY\n    };\n  } else if (0.5 * Math.PI <= angle && angle < Math.PI) {\n    start = {\n      x: maxX,\n      y: minY\n    };\n    end = {\n      x: minX,\n      y: maxY\n    };\n  } else if (Math.PI <= angle && angle < 1.5 * Math.PI) {\n    start = {\n      x: maxX,\n      y: maxY\n    };\n    end = {\n      x: minX,\n      y: minY\n    };\n  } else {\n    start = {\n      x: minX,\n      y: maxY\n    };\n    end = {\n      x: maxX,\n      y: minY\n    };\n  }\n\n  var tanTheta = Math.tan(angle);\n  var tanTheta2 = tanTheta * tanTheta;\n  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;\n  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;\n  var gradient = context.createLinearGradient(start.x, start.y, x, y);\n\n  _addStop(steps, gradient);\n\n  return gradient;\n} // the string format: 'r(0.5, 0.5, 0.1) 0:#ffffff 1:#1890ff'\n\n\nfunction _parseRadialGradient(color, shape, context) {\n  var arr = color.split(' ');\n  var circleCfg = arr[0].slice(2, arr[0].length - 1);\n  circleCfg = circleCfg.split(',');\n  var fx = parseFloat(circleCfg[0]);\n  var fy = parseFloat(circleCfg[1]);\n  var fr = parseFloat(circleCfg[2]);\n  var steps = arr.slice(1); // if radius is 0, no gradient, stroke with the last color\n\n  if (fr === 0) {\n    var _color = steps[steps.length - 1];\n    return _color.split(':')[1];\n  }\n\n  var _shape$getBBox2 = shape.getBBox(),\n      width = _shape$getBBox2.width,\n      height = _shape$getBBox2.height,\n      minX = _shape$getBBox2.minX,\n      minY = _shape$getBBox2.minY;\n\n  var r = Math.sqrt(width * width + height * height) / 2;\n  var gradient = context.createRadialGradient(minX + width * fx, minY + height * fy, fr * r, minX + width / 2, minY + height / 2, r);\n\n  _addStop(steps, gradient);\n\n  return gradient;\n}\n\nmodule.exports = {\n  parseStyle: function parseStyle(color, shape, context) {\n    if (color[1] === '(') {\n      try {\n        var firstCode = color[0];\n\n        if (firstCode === 'l') {\n          return _parseLineGradient(color, shape, context);\n        } else if (firstCode === 'r') {\n          return _parseRadialGradient(color, shape, context);\n        }\n      } catch (ev) {\n        console.error('error in parsing gradient string, please check if there are any extra whitespaces.');\n        console.error(ev);\n      }\n    }\n\n    return color;\n  }\n};\n\n/***/ }),\n/* 81 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(2);\n\nvar Rect =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Rect, _Shape);\n\n  function Rect() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Rect.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'rect';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      width: 0,\n      height: 0,\n      radius: 0,\n      lineWidth: 0\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var self = this;\n    var attrs = self.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        width = attrs.width,\n        height = attrs.height;\n    context.beginPath();\n    var radius = attrs.radius;\n\n    if (!radius || !(width * height)) {\n      context.rect(x, y, width, height);\n    } else {\n      radius = Util.parsePadding(radius);\n      context.moveTo(x + radius[0], y);\n      context.lineTo(x + width - radius[1], y);\n      context.arc(x + width - radius[1], y + radius[1], radius[1], -Math.PI / 2, 0, false);\n      context.lineTo(x + width, y + height - radius[2]);\n      context.arc(x + width - radius[2], y + height - radius[2], radius[2], 0, Math.PI / 2, false);\n      context.lineTo(x + radius[3], y + height);\n      context.arc(x + radius[3], y + height - radius[3], radius[3], Math.PI / 2, Math.PI, false);\n      context.lineTo(x, y + radius[0]);\n      context.arc(x + radius[0], y + radius[0], radius[0], Math.PI, Math.PI * 3 / 2, false);\n      context.closePath();\n    }\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        width = attrs.width,\n        height = attrs.height;\n    return {\n      minX: x,\n      minY: y,\n      maxX: x + width,\n      maxY: y + height\n    };\n  };\n\n  return Rect;\n}(Shape);\n\nShape.Rect = Rect;\nmodule.exports = Rect;\n\n/***/ }),\n/* 82 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Circle, _Shape);\n\n  function Circle() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Circle.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'circle';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      r: 0,\n      lineWidth: 0\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r;\n    context.beginPath();\n    context.arc(x, y, r, 0, Math.PI * 2, false);\n    context.closePath();\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r;\n    return {\n      minX: x - r,\n      maxX: x + r,\n      minY: y - r,\n      maxY: y + r\n    };\n  };\n\n  return Circle;\n}(Shape);\n\nShape.Circle = Circle;\nmodule.exports = Circle;\n\n/***/ }),\n/* 83 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar bbox = __webpack_require__(10);\n\nvar Line =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Line, _Shape);\n\n  function Line() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canStroke = true;\n    this._attrs.type = 'line';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x1: 0,\n      y1: 0,\n      x2: 0,\n      y2: 0,\n      lineWidth: 1\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var attrs = this.get('attrs');\n    var x1 = attrs.x1,\n        y1 = attrs.y1,\n        x2 = attrs.x2,\n        y2 = attrs.y2;\n    context.beginPath();\n    context.moveTo(x1, y1);\n    context.lineTo(x2, y2);\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x1 = attrs.x1,\n        y1 = attrs.y1,\n        x2 = attrs.x2,\n        y2 = attrs.y2,\n        lineWidth = attrs.lineWidth;\n    return bbox.getBBoxFromLine(x1, y1, x2, y2, lineWidth);\n  };\n\n  return Line;\n}(Shape);\n\nShape.Line = Line;\nmodule.exports = Line;\n\n/***/ }),\n/* 84 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar bbox = __webpack_require__(10);\n\nvar Polygon =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Polygon, _Shape);\n\n  function Polygon() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Polygon.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'polygon';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      points: null,\n      lineWidth: 0\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var self = this;\n    var attrs = self.get('attrs');\n    var points = attrs.points;\n    context.beginPath();\n\n    for (var i = 0, len = points.length; i < len; i++) {\n      var point = points[i];\n\n      if (i === 0) {\n        context.moveTo(point.x, point.y);\n      } else {\n        context.lineTo(point.x, point.y);\n      }\n    }\n\n    context.closePath();\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var points = attrs.points;\n    return bbox.getBBoxFromPoints(points);\n  };\n\n  return Polygon;\n}(Shape);\n\nShape.Polygon = Polygon;\nmodule.exports = Polygon;\n\n/***/ }),\n/* 85 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar Smooth = __webpack_require__(41);\n\nvar bbox = __webpack_require__(10); // filter the point which x or y is NaN\n\n\nfunction _filterPoints(points) {\n  var filteredPoints = [];\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (!isNaN(point.x) && !isNaN(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nvar Polyline =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Polyline, _Shape);\n\n  function Polyline() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Polyline.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'polyline';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      points: null,\n      lineWidth: 1,\n      smooth: false\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var self = this;\n    var attrs = self.get('attrs');\n    var points = attrs.points,\n        smooth = attrs.smooth;\n\n    var filteredPoints = _filterPoints(points);\n\n    context.beginPath();\n\n    if (filteredPoints.length) {\n      context.moveTo(filteredPoints[0].x, filteredPoints[0].y);\n\n      if (smooth) {\n        var constaint = [[0, 0], [1, 1]];\n        var sps = Smooth.smooth(filteredPoints, false, constaint);\n\n        for (var i = 0, n = sps.length; i < n; i++) {\n          var sp = sps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n      } else {\n        var _i;\n\n        var l;\n\n        for (_i = 1, l = filteredPoints.length - 1; _i < l; _i++) {\n          context.lineTo(filteredPoints[_i].x, filteredPoints[_i].y);\n        }\n\n        context.lineTo(filteredPoints[l].x, filteredPoints[l].y);\n      }\n    }\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var points = attrs.points,\n        smooth = attrs.smooth,\n        lineWidth = attrs.lineWidth;\n\n    var filteredPoints = _filterPoints(points);\n\n    if (smooth) {\n      var newPoints = [];\n      var constaint = [[0, 0], [1, 1]];\n      var sps = Smooth.smooth(filteredPoints, false, constaint);\n\n      for (var i = 0, n = sps.length; i < n; i++) {\n        var sp = sps[i];\n\n        if (i === 0) {\n          newPoints.push([filteredPoints[0].x, filteredPoints[0].y, sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\n        } else {\n          var lastPoint = sps[i - 1];\n          newPoints.push([lastPoint[5], lastPoint[6], sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]]);\n        }\n      }\n\n      return bbox.getBBoxFromBezierGroup(newPoints, lineWidth);\n    }\n\n    return bbox.getBBoxFromPoints(filteredPoints, lineWidth);\n  };\n\n  return Polyline;\n}(Shape);\n\nShape.Polyline = Polyline;\nmodule.exports = Polyline;\n\n/***/ }),\n/* 86 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar bbox = __webpack_require__(10);\n\nvar Arc =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Arc, _Shape);\n\n  function Arc() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Arc.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canStroke = true;\n    this._attrs.canFill = true;\n    this._attrs.type = 'arc';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      r: 0,\n      startAngle: 0,\n      endAngle: Math.PI * 2,\n      clockwise: false,\n      lineWidth: 1\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        clockwise = attrs.clockwise;\n    context.beginPath();\n\n    if (startAngle !== endAngle) {\n      context.arc(x, y, r, startAngle, endAngle, clockwise);\n    }\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        clockwise = attrs.clockwise;\n    return bbox.getBBoxFromArc(x, y, r, startAngle, endAngle, clockwise);\n  };\n\n  return Arc;\n}(Shape);\n\nShape.Arc = Arc;\nmodule.exports = Arc;\n\n/***/ }),\n/* 87 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar bbox = __webpack_require__(10);\n\nvar Sector =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Sector, _Shape);\n\n  function Sector() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Sector.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'sector';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      lineWidth: 0,\n      r: 0,\n      r0: 0,\n      startAngle: 0,\n      endAngle: Math.PI * 2,\n      clockwise: false\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        r = attrs.r,\n        r0 = attrs.r0,\n        clockwise = attrs.clockwise;\n    context.beginPath();\n    var unitX = Math.cos(startAngle);\n    var unitY = Math.sin(startAngle);\n    context.moveTo(unitX * r0 + x, unitY * r0 + y);\n    context.lineTo(unitX * r + x, unitY * r + y); // 当扇形的角度非常小的时候，就不进行弧线的绘制；或者整个只有1个扇形时，会出现end<0的情况不绘制\n\n    if (Math.abs(endAngle - startAngle) > 0.0001 || startAngle === 0 && endAngle < 0) {\n      context.arc(x, y, r, startAngle, endAngle, clockwise);\n      context.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);\n\n      if (r0 !== 0) {\n        context.arc(x, y, r0, endAngle, startAngle, !clockwise);\n      }\n    }\n\n    context.closePath();\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        r = attrs.r,\n        r0 = attrs.r0,\n        startAngle = attrs.startAngle,\n        endAngle = attrs.endAngle,\n        clockwise = attrs.clockwise;\n    var outerBBox = bbox.getBBoxFromArc(x, y, r, startAngle, endAngle, clockwise);\n    var innerBBox = bbox.getBBoxFromArc(x, y, r0, startAngle, endAngle, clockwise);\n    return {\n      minX: Math.min(outerBBox.minX, innerBBox.minX),\n      minY: Math.min(outerBBox.minY, innerBBox.minY),\n      maxX: Math.max(outerBBox.maxX, innerBBox.maxX),\n      maxY: Math.max(outerBBox.maxY, innerBBox.maxY)\n    };\n  };\n\n  return Sector;\n}(Shape);\n\nShape.Sector = Sector;\nmodule.exports = Sector;\n\n/***/ }),\n/* 88 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(2);\n\nvar textWidthCacheCounter = 0;\nvar textWidthCache = {};\nvar TEXT_CACHE_MAX = 5000;\n\nvar Text =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Text, _Shape);\n\n  function Text() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Text.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'text';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      lineWidth: 0,\n      lineCount: 1,\n      fontSize: 12,\n      fontFamily: 'sans-serif',\n      fontStyle: 'normal',\n      fontWeight: 'normal',\n      fontVariant: 'normal',\n      textAlign: 'start',\n      textBaseline: 'bottom',\n      lineHeight: null,\n      textArr: null\n    };\n  };\n\n  _proto._getFontStyle = function _getFontStyle() {\n    var attrs = this._attrs.attrs;\n    var fontSize = attrs.fontSize,\n        fontFamily = attrs.fontFamily,\n        fontWeight = attrs.fontWeight,\n        fontStyle = attrs.fontStyle,\n        fontVariant = attrs.fontVariant;\n    return fontStyle + \" \" + fontVariant + \" \" + fontWeight + \" \" + fontSize + \"px \" + fontFamily;\n  };\n\n  _proto._afterAttrsSet = function _afterAttrsSet() {\n    var attrs = this._attrs.attrs;\n    attrs.font = this._getFontStyle();\n\n    if (attrs.text) {\n      var text = attrs.text;\n      var textArr = null;\n      var lineCount = 1;\n\n      if (Util.isString(text) && text.indexOf('\\n') !== -1) {\n        textArr = text.split('\\n');\n        lineCount = textArr.length;\n      }\n\n      attrs.lineCount = lineCount;\n      attrs.textArr = textArr;\n    }\n\n    this.set('attrs', attrs);\n  };\n\n  _proto._getTextHeight = function _getTextHeight() {\n    var attrs = this._attrs.attrs;\n\n    if (attrs.height) {\n      return attrs.height;\n    }\n\n    var lineCount = attrs.lineCount;\n    var fontSize = attrs.fontSize * 1;\n\n    if (lineCount > 1) {\n      var spaceingY = this._getSpaceingY();\n\n      return fontSize * lineCount + spaceingY * (lineCount - 1);\n    }\n\n    return fontSize;\n  };\n\n  _proto._getSpaceingY = function _getSpaceingY() {\n    var attrs = this._attrs.attrs;\n    var lineHeight = attrs.lineHeight;\n    var fontSize = attrs.fontSize * 1;\n    return lineHeight ? lineHeight - fontSize : fontSize * 0.14;\n  };\n\n  _proto.drawInner = function drawInner(context) {\n    var self = this;\n    var attrs = self._attrs.attrs;\n    var text = attrs.text;\n    var x = attrs.x;\n    var y = attrs.y;\n\n    if (Util.isNil(text) || isNaN(x) || isNaN(y)) {\n      // text will be 0\n      return;\n    }\n\n    var textArr = attrs.textArr;\n    var fontSize = attrs.fontSize * 1;\n\n    var spaceingY = self._getSpaceingY();\n\n    if (attrs.rotate) {\n      // do rotation\n      context.translate(x, y);\n      context.rotate(attrs.rotate);\n      x = 0;\n      y = 0;\n    }\n\n    var textBaseline = attrs.textBaseline;\n    var height;\n\n    if (textArr) {\n      height = self._getTextHeight();\n    }\n\n    var subY; // context.beginPath();\n\n    if (self.hasFill()) {\n      var fillOpacity = attrs.fillOpacity;\n\n      if (!Util.isNil(fillOpacity) && fillOpacity !== 1) {\n        context.globalAlpha = fillOpacity;\n      }\n\n      if (textArr) {\n        for (var i = 0, len = textArr.length; i < len; i++) {\n          var subText = textArr[i];\n          subY = y + i * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n\n          context.fillText(subText, x, subY);\n        }\n      } else {\n        context.fillText(text, x, y);\n      }\n    }\n\n    if (self.hasStroke()) {\n      if (textArr) {\n        for (var _i = 0, _len = textArr.length; _i < _len; _i++) {\n          var _subText = textArr[_i];\n          subY = y + _i * (spaceingY + fontSize) - height + fontSize; // bottom;\n\n          if (textBaseline === 'middle') {\n            subY += height - fontSize - (height - fontSize) / 2;\n          }\n\n          if (textBaseline === 'top') {\n            subY += height - fontSize;\n          }\n\n          context.strokeText(_subText, x, subY);\n        }\n      } else {\n        context.strokeText(text, x, y);\n      }\n    }\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var self = this;\n    var attrs = self._attrs.attrs;\n    var x = attrs.x,\n        y = attrs.y,\n        textAlign = attrs.textAlign,\n        textBaseline = attrs.textBaseline;\n\n    var width = self._getTextWidth(); // attrs.width\n\n\n    if (!width) {\n      return {\n        minX: x,\n        minY: y,\n        maxX: x,\n        maxY: y\n      };\n    }\n\n    var height = self._getTextHeight(); // attrs.height\n\n\n    var point = {\n      x: x,\n      y: y - height\n    }; // default textAlign: start, textBaseline: bottom\n\n    if (textAlign) {\n      if (textAlign === 'end' || textAlign === 'right') {\n        point.x -= width;\n      } else if (textAlign === 'center') {\n        point.x -= width / 2;\n      }\n    }\n\n    if (textBaseline) {\n      if (textBaseline === 'top') {\n        point.y += height;\n      } else if (textBaseline === 'middle') {\n        point.y += height / 2;\n      }\n    }\n\n    return {\n      minX: point.x,\n      minY: point.y,\n      maxX: point.x + width,\n      maxY: point.y + height\n    };\n  };\n\n  _proto._getTextWidth = function _getTextWidth() {\n    var attrs = this._attrs.attrs;\n\n    if (attrs.width) {\n      return attrs.width;\n    }\n\n    var text = attrs.text;\n    var context = this.get('context');\n    if (Util.isNil(text)) return undefined;\n    var font = attrs.font;\n    var textArr = attrs.textArr;\n    var key = text + '' + font;\n\n    if (textWidthCache[key]) {\n      return textWidthCache[key];\n    }\n\n    var width = 0;\n\n    if (textArr) {\n      for (var i = 0, length = textArr.length; i < length; i++) {\n        var subText = textArr[i];\n        width = Math.max(width, Util.measureText(subText, font, context).width);\n      }\n    } else {\n      width = Util.measureText(text, font, context).width;\n    }\n\n    if (textWidthCacheCounter > TEXT_CACHE_MAX) {\n      textWidthCacheCounter = 0;\n      textWidthCache = {};\n    }\n\n    textWidthCacheCounter++;\n    textWidthCache[key] = width;\n    return width;\n  };\n\n  return Text;\n}(Shape);\n\nShape.Text = Text;\nmodule.exports = Text;\n\n/***/ }),\n/* 89 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Shape = __webpack_require__(2);\n\nvar Custom =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Custom, _Shape);\n\n  function Custom() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Custom.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.createPath = null;\n    this._attrs.type = 'custom';\n  };\n\n  _proto.createPath = function createPath(context) {\n    var createPath = this.get('createPath');\n    createPath && createPath.call(this, context);\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var calculateBox = this.get('calculateBox');\n    return calculateBox && calculateBox.call(this);\n  };\n\n  return Custom;\n}(Shape);\n\nShape.Custom = Custom;\nmodule.exports = Custom;\n\n/***/ }),\n/* 90 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Path = __webpack_require__(42);\n\nvar Geom = __webpack_require__(6);\n\n__webpack_require__(37);\n\nvar Line =\n/*#__PURE__*/\nfunction (_Path) {\n  _inheritsLoose(Line, _Path);\n\n  function Line() {\n    return _Path.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Path.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'line';\n    cfg.sortable = true;\n    return cfg;\n  };\n\n  return Line;\n}(Path);\n\nGeom.Line = Line;\nmodule.exports = Line;\n\n/***/ }),\n/* 91 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Geom = __webpack_require__(6);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = __webpack_require__(43);\n\n__webpack_require__(92);\n\nvar Interval =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Interval, _Geom);\n\n  var _proto = Interval.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'interval';\n    cfg.shapeType = 'interval';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  function Interval(cfg) {\n    var _this;\n\n    _this = _Geom.call(this, cfg) || this;\n    Util.mix(_assertThisInitialized(_this), SizeMixin);\n    return _this;\n  }\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\n\n    cfg.size = this.getNormalizedSize(obj);\n    return cfg;\n  };\n\n  _proto.clearInner = function clearInner() {\n    _Geom.prototype.clearInner.call(this);\n\n    this.set('defaultSize', null);\n  };\n\n  return Interval;\n}(Geom);\n\nGeom.Interval = Interval;\nmodule.exports = Interval;\n\n/***/ }),\n/* 92 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(8);\n\nvar Vector2 = __webpack_require__(3);\n\nvar Global = __webpack_require__(1);\n\nfunction getRectPoints(cfg) {\n  var x = cfg.x,\n      y = cfg.y,\n      y0 = cfg.y0,\n      size = cfg.size;\n  var ymin = y0;\n  var ymax = y;\n\n  if (Util.isArray(y)) {\n    ymax = y[1];\n    ymin = y[0];\n  }\n\n  var xmin;\n  var xmax;\n\n  if (Util.isArray(x)) {\n    xmin = x[0];\n    xmax = x[1];\n  } else {\n    xmin = x - size / 2;\n    xmax = x + size / 2;\n  }\n\n  return [{\n    x: xmin,\n    y: ymin\n  }, {\n    x: xmin,\n    y: ymax\n  }, {\n    x: xmax,\n    y: ymax\n  }, {\n    x: xmax,\n    y: ymin\n  }];\n}\n\nfunction getRectRange(points) {\n  var xValues = [];\n  var yValues = [];\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n    xValues.push(point.x);\n    yValues.push(point.y);\n  }\n\n  var xMin = Math.min.apply(null, xValues);\n  var yMin = Math.min.apply(null, yValues);\n  var xMax = Math.max.apply(null, xValues);\n  var yMax = Math.max.apply(null, yValues);\n  return {\n    x: xMin,\n    y: yMin,\n    width: xMax - xMin,\n    height: yMax - yMin\n  };\n}\n\nvar Interval = Shape.registerFactory('interval', {\n  defaultShapeType: 'rect',\n  getDefaultPoints: function getDefaultPoints(cfg) {\n    return getRectPoints(cfg);\n  }\n});\nShape.registerShape('interval', 'rect', {\n  draw: function draw(cfg, container) {\n    var points = this.parsePoints(cfg.points);\n    var style = Util.mix({\n      fill: cfg.color\n    }, Global.shape.interval, cfg.style);\n\n    if (cfg.isInCircle) {\n      var newPoints = points.slice(0);\n\n      if (this._coord.transposed) {\n        newPoints = [points[0], points[3], points[2], points[1]];\n      }\n\n      var _cfg$center = cfg.center,\n          x = _cfg$center.x,\n          y = _cfg$center.y;\n      var v = [1, 0];\n      var v0 = [newPoints[0].x - x, newPoints[0].y - y];\n      var v1 = [newPoints[1].x - x, newPoints[1].y - y];\n      var v2 = [newPoints[2].x - x, newPoints[2].y - y];\n      var startAngle = Vector2.angleTo(v, v1);\n      var endAngle = Vector2.angleTo(v, v2);\n      var r0 = Vector2.length(v0);\n      var r = Vector2.length(v1);\n\n      if (startAngle >= 1.5 * Math.PI) {\n        startAngle = startAngle - 2 * Math.PI;\n      }\n\n      if (endAngle >= 1.5 * Math.PI) {\n        endAngle = endAngle - 2 * Math.PI;\n      }\n\n      return container.addShape('Sector', {\n        className: 'interval',\n        attrs: Util.mix({\n          x: x,\n          y: y,\n          r: r,\n          r0: r0,\n          startAngle: startAngle,\n          endAngle: endAngle\n        }, style)\n      });\n    }\n\n    var rectCfg = getRectRange(points);\n    return container.addShape('rect', {\n      className: 'interval',\n      attrs: Util.mix(rectCfg, style)\n    });\n  }\n});\nmodule.exports = Interval;\n\n/***/ }),\n/* 93 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = {\n  Stack: __webpack_require__(94),\n  Dodge: __webpack_require__(96)\n};\n\n/***/ }),\n/* 94 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Stack = __webpack_require__(95);\n\nmodule.exports = Stack;\n\n/***/ }),\n/* 95 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar isArray = __webpack_require__(13);\n\nvar isNil = __webpack_require__(9);\n\nvar Adjust = __webpack_require__(23);\n\nvar Stack =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Stack, _Adjust);\n\n  function Stack() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Stack.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.xField = null; // 调整对应的 x 方向对应的字段名称\n\n    this.yField = null; // 调整对应的 y 方向对应的字段名称\n  };\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    this.processStack(dataArray);\n  };\n\n  _proto.processStack = function processStack(dataArray) {\n    var self = this;\n    var xField = self.xField;\n    var yField = self.yField;\n    var count = dataArray.length;\n    var stackCache = {\n      positive: {},\n      negative: {}\n    }; // 层叠顺序翻转\n\n    if (self.reverseOrder) {\n      dataArray = dataArray.slice(0).reverse();\n    }\n\n    for (var i = 0; i < count; i++) {\n      var data = dataArray[i];\n\n      for (var j = 0, len = data.length; j < len; j++) {\n        var item = data[j];\n        var x = item[xField] || 0;\n        var y = item[yField];\n        var xkey = x.toString();\n        y = isArray(y) ? y[1] : y;\n\n        if (!isNil(y)) {\n          var direction = y >= 0 ? 'positive' : 'negative';\n\n          if (!stackCache[direction][xkey]) {\n            stackCache[direction][xkey] = 0;\n          }\n\n          item[yField] = [stackCache[direction][xkey], y + stackCache[direction][xkey]];\n          stackCache[direction][xkey] += y;\n        }\n      }\n    }\n  };\n\n  return Stack;\n}(Adjust);\n\nAdjust.Stack = Stack;\nmodule.exports = Stack;\n\n/***/ }),\n/* 96 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Dodge = __webpack_require__(97);\n\nmodule.exports = Dodge;\n\n/***/ }),\n/* 97 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar Adjust = __webpack_require__(23);\n\nvar each = __webpack_require__(4);\n\nvar MARGIN_RATIO = 1 / 2;\nvar DODGE_RATIO = 1 / 2;\n\nvar Dodge =\n/*#__PURE__*/\nfunction (_Adjust) {\n  _inheritsLoose(Dodge, _Adjust);\n\n  function Dodge() {\n    return _Adjust.apply(this, arguments) || this;\n  }\n\n  var _proto = Dodge.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    /**\n     * 调整过程中,2个数据的间距\n     * @type {Number}\n     */\n    this.marginRatio = MARGIN_RATIO;\n    /**\n     * 调整占单位宽度的比例,例如：占2个分类间距的 1/2\n     * @type {Number}\n     */\n\n    this.dodgeRatio = DODGE_RATIO;\n    this.adjustNames = ['x', 'y']; // 调整的维度，默认,x,y都做调整\n  };\n\n  _proto.getDodgeOffset = function getDodgeOffset(range, index, count) {\n    var self = this;\n    var pre = range.pre;\n    var next = range.next;\n    var tickLength = next - pre;\n    var width = tickLength * self.dodgeRatio / count;\n    var margin = self.marginRatio * width;\n    var offset = 1 / 2 * (tickLength - count * width - (count - 1) * margin) + ((index + 1) * width + index * margin) - 1 / 2 * width - 1 / 2 * tickLength;\n    return (pre + next) / 2 + offset;\n  };\n\n  _proto.processAdjust = function processAdjust(dataArray) {\n    var self = this;\n    var count = dataArray.length;\n    var xField = self.xField;\n    each(dataArray, function (data, index) {\n      for (var i = 0, len = data.length; i < len; i++) {\n        var obj = data[i];\n        var value = obj[xField];\n        var range = {\n          pre: len === 1 ? value - 1 : value - 0.5,\n          next: len === 1 ? value + 1 : value + 0.5\n        };\n        var dodgeValue = self.getDodgeOffset(range, index, count);\n        obj[xField] = dodgeValue;\n      }\n    });\n  };\n\n  return Dodge;\n}(Adjust);\n\nAdjust.Dodge = Dodge;\nmodule.exports = Dodge;\n\n/***/ }),\n/* 98 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Base = __webpack_require__(21);\n\nvar Vector2 = __webpack_require__(3);\n\nvar Matrix = __webpack_require__(24);\n\nvar Polar =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Polar, _Base);\n\n  function Polar() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Polar.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'polar';\n    this.startAngle = -Math.PI / 2;\n    this.endAngle = Math.PI * 3 / 2;\n    this.inner = 0;\n    this.innerRadius = 0; // alias\n\n    this.isPolar = true;\n    this.transposed = false;\n    this.center = null;\n    this.radius = null; // relative, 0 ~ 1\n  };\n\n  _proto.init = function init(start, end) {\n    var self = this;\n    var inner = self.inner || self.innerRadius;\n    var width = Math.abs(end.x - start.x);\n    var height = Math.abs(end.y - start.y);\n    var maxRadius;\n    var center;\n\n    if (self.startAngle === -Math.PI && self.endAngle === 0) {\n      maxRadius = Math.min(width / 2, height);\n      center = {\n        x: (start.x + end.x) / 2,\n        y: start.y\n      };\n    } else {\n      maxRadius = Math.min(width, height) / 2;\n      center = {\n        x: (start.x + end.x) / 2,\n        y: (start.y + end.y) / 2\n      };\n    }\n\n    var radius = self.radius;\n\n    if (radius > 0 && radius <= 1) {\n      maxRadius = maxRadius * radius;\n    }\n\n    this.x = {\n      start: self.startAngle,\n      end: self.endAngle\n    };\n    this.y = {\n      start: maxRadius * inner,\n      end: maxRadius\n    };\n    this.center = center;\n    this.circleRadius = maxRadius; // the radius value in px\n  };\n\n  _proto.convertPoint = function convertPoint(point) {\n    var self = this;\n    var center = self.center;\n    var transposed = self.transposed;\n    var xDim = transposed ? 'y' : 'x';\n    var yDim = transposed ? 'x' : 'y';\n    var x = self.x;\n    var y = self.y;\n    var angle = x.start + (x.end - x.start) * point[xDim];\n    var radius = y.start + (y.end - y.start) * point[yDim];\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  _proto.invertPoint = function invertPoint(point) {\n    var self = this;\n    var center = self.center,\n        transposed = self.transposed,\n        x = self.x,\n        y = self.y;\n    var xDim = transposed ? 'y' : 'x';\n    var yDim = transposed ? 'x' : 'y';\n    var m = [1, 0, 0, 1, 0, 0];\n    Matrix.rotate(m, m, x.start);\n    var startV = [1, 0];\n    Vector2.transformMat2d(startV, startV, m);\n    startV = [startV[0], startV[1]];\n    var pointV = [point.x - center.x, point.y - center.y];\n\n    if (Vector2.zero(pointV)) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    var theta = Vector2.angleTo(startV, pointV, x.end < x.start);\n\n    if (Math.abs(theta - Math.PI * 2) < 0.001) {\n      theta = 0;\n    }\n\n    var l = Vector2.length(pointV);\n    var percentX = theta / (x.end - x.start);\n    percentX = x.end - x.start > 0 ? percentX : -percentX;\n    var percentY = (l - y.start) / (y.end - y.start);\n    var rst = {};\n    rst[xDim] = percentX;\n    rst[yDim] = percentY;\n    return rst;\n  };\n\n  return Polar;\n}(Base);\n\nBase.Polar = Polar;\nmodule.exports = Polar;\n\n/***/ }),\n/* 99 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * @fileOverview 提取公共代码到util方法\n * @author dxq613@gmail.com\n */\nvar isString = __webpack_require__(18);\n\nvar isDate = __webpack_require__(118);\n\nmodule.exports = {\n  toTimeStamp: function toTimeStamp(value) {\n    if (isString(value)) {\n      if (value.indexOf('T') > 0) {\n        value = new Date(value).getTime();\n      } else {\n        value = new Date(value.replace(/-/ig, '/')).getTime();\n      }\n    }\n\n    if (isDate(value)) {\n      value = value.getTime();\n    }\n\n    return value;\n  }\n};\n\n/***/ }),\n/* 100 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * marker shapes，used for tooltip and legend\n */\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(5),\n    Shape = _require.Shape;\n\nvar SYMBOLS = {\n  circle: function circle(x, y, r, ctx) {\n    ctx.arc(x, y, r, 0, Math.PI * 2, false);\n  },\n  square: function square(x, y, r, ctx) {\n    ctx.moveTo(x - r, y - r);\n    ctx.lineTo(x + r, y - r);\n    ctx.lineTo(x + r, y + r);\n    ctx.lineTo(x - r, y + r);\n    ctx.closePath();\n  }\n};\n\nvar Marker =\n/*#__PURE__*/\nfunction (_Shape) {\n  _inheritsLoose(Marker, _Shape);\n\n  function Marker() {\n    return _Shape.apply(this, arguments) || this;\n  }\n\n  var _proto = Marker.prototype;\n\n  _proto._initProperties = function _initProperties() {\n    _Shape.prototype._initProperties.call(this);\n\n    this._attrs.canFill = true;\n    this._attrs.canStroke = true;\n    this._attrs.type = 'marker';\n  };\n\n  _proto.getDefaultAttrs = function getDefaultAttrs() {\n    return {\n      x: 0,\n      y: 0,\n      lineWidth: 0\n    };\n  };\n\n  _proto.createPath = function createPath(context) {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        radius = attrs.radius;\n    var symbol = attrs.symbol || 'circle';\n    var method;\n\n    if (Util.isFunction(symbol)) {\n      method = symbol;\n    } else {\n      method = SYMBOLS[symbol];\n    }\n\n    context.beginPath();\n    method(x, y, radius, context, this);\n  };\n\n  _proto.calculateBox = function calculateBox() {\n    var attrs = this.get('attrs');\n    var x = attrs.x,\n        y = attrs.y,\n        radius = attrs.radius;\n    return {\n      minX: x - radius,\n      minY: y - radius,\n      maxX: x + radius,\n      maxY: y + radius\n    };\n  };\n\n  return Marker;\n}(Shape);\n\nmodule.exports = Marker;\n\n/***/ }),\n/* 101 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(5),\n    Group = _require.Group;\n\nvar Marker = __webpack_require__(100);\n\nvar MARKER_RADIUS = 3;\n\nvar List =\n/*#__PURE__*/\nfunction () {\n  var _proto = List.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      showTitle: false,\n\n      /**\n       * title string\n       * @type {?String}\n       */\n      title: null,\n\n      /**\n       * items array\n       * @type {?Array}\n       */\n      items: null,\n\n      /**\n       * offset between title and items\n       * @type {Number}\n       */\n      titleGap: 12,\n\n      /**\n       * offset between each item\n       * @type {Number}\n       */\n      itemGap: 10,\n\n      /**\n       * the offset between each item in vertical direaction\n       * @type {Number}\n       */\n      itemMarginBottom: 12,\n\n      /**\n       * the formatter for item text\n       * @type {[type]}\n       */\n      itemFormatter: null,\n      itemWidth: null,\n\n      /**\n       * offset between marker and text\n       * @type {Number}\n       */\n      wordSpace: 6,\n      x: 0,\n      y: 0,\n      layout: 'horizontal',\n\n      /**\n       * the join string of `name` and `value`\n       * @type {String}\n       */\n      joinString: ': '\n    };\n  };\n\n  function List(cfg) {\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\n\n    this._init();\n\n    this._renderTitle();\n\n    this._renderItems();\n  }\n\n  _proto._init = function _init() {\n    var container = new Group({\n      zIndex: this.zIndex || 0\n    });\n    this.container = container;\n    var wrapper = container.addGroup();\n    this.wrapper = wrapper;\n    var itemsGroup = wrapper.addGroup({\n      className: 'itemsGroup'\n    });\n    this.itemsGroup = itemsGroup;\n\n    if (this.parent) {\n      this.parent.add(container);\n    }\n  };\n\n  _proto._renderTitle = function _renderTitle(title) {\n    title = title || this.title;\n    var titleShape = this.titleShape;\n    var titleHeight = 0;\n\n    if (this.showTitle && title) {\n      if (titleShape && !titleShape.get('destroyed')) {\n        titleShape.attr('text', title);\n      } else {\n        var wrapper = this.wrapper,\n            titleStyle = this.titleStyle;\n        titleShape = wrapper.addShape('text', {\n          className: 'title',\n          attrs: Util.mix({\n            x: 0,\n            y: 0,\n            text: title\n          }, titleStyle)\n        });\n        this.titleShape = titleShape;\n      }\n\n      titleHeight = titleShape.getBBox().height + this.titleGap;\n    }\n\n    this._titleHeight = titleHeight;\n  };\n\n  _proto._renderItems = function _renderItems(items) {\n    var self = this;\n    items = items || self.items;\n\n    if (!items) {\n      return;\n    }\n\n    if (self.reversed) {\n      items.reverse();\n    }\n\n    Util.each(items, function (item, index) {\n      self._addItem(item, index);\n    });\n\n    if (items.length > 1) {\n      this._adjustItems();\n    }\n\n    this._renderBackground();\n  };\n\n  _proto._renderBackground = function _renderBackground() {\n    var background = this.background;\n\n    if (background) {\n      var container = this.container;\n      var wrapper = this.wrapper;\n\n      var _wrapper$getBBox = wrapper.getBBox(),\n          minX = _wrapper$getBBox.minX,\n          minY = _wrapper$getBBox.minY,\n          width = _wrapper$getBBox.width,\n          height = _wrapper$getBBox.height;\n\n      var padding = background.padding || [0, 0, 0, 0];\n      padding = Util.parsePadding(padding);\n      var attrs = Util.mix({\n        x: minX - padding[3],\n        y: minY - padding[0],\n        width: width + padding[1] + padding[3],\n        height: height + padding[0] + padding[2]\n      }, background);\n      var backShape = this.backShape;\n\n      if (backShape) {\n        backShape.attr(attrs);\n      } else {\n        backShape = container.addShape('Rect', {\n          zIndex: -1,\n          attrs: attrs\n        });\n      }\n\n      this.backShape = backShape;\n      container.sort();\n    }\n  };\n\n  _proto._addItem = function _addItem(item) {\n    var itemsGroup = this.itemsGroup;\n    var itemGroup = itemsGroup.addGroup({\n      name: item.name,\n      value: item.value,\n      dataValue: item.dataValue,\n      checked: item.checked\n    });\n    var unCheckStyle = this.unCheckStyle,\n        unCheckColor = this.unCheckColor,\n        nameStyle = this.nameStyle,\n        valueStyle = this.valueStyle,\n        wordSpace = this.wordSpace;\n    var marker = item.marker,\n        value = item.value;\n    var startX = 0;\n\n    if (unCheckColor) {\n      unCheckStyle.fill = unCheckColor;\n    }\n\n    if (marker) {\n      var radius = marker.radius || MARKER_RADIUS;\n      var markerAttrs = Util.mix({\n        x: radius,\n        y: this._titleHeight\n      }, marker);\n\n      if (item.checked === false) {\n        Util.mix(markerAttrs, unCheckStyle);\n      }\n\n      var markerShape = new Marker({\n        className: 'item-marker',\n        attrs: markerAttrs\n      });\n      itemGroup.add(markerShape);\n      startX += markerShape.getBBox().width + wordSpace;\n    }\n\n    var nameText;\n    var name = item.name;\n\n    if (name) {\n      var joinString = this.joinString || '';\n      name = value ? name + joinString : name;\n      nameText = itemGroup.addShape('text', {\n        className: 'name',\n        attrs: Util.mix({\n          x: startX,\n          y: this._titleHeight,\n          text: this._formatItemValue(name)\n        }, nameStyle, item.checked === false ? unCheckStyle : null)\n      });\n    }\n\n    if (value) {\n      var valueX = startX;\n\n      if (nameText) {\n        valueX += nameText.getBBox().width;\n      }\n\n      itemGroup.addShape('text', {\n        className: 'value',\n        attrs: Util.mix({\n          x: valueX,\n          y: this._titleHeight,\n          text: value\n        }, valueStyle, item.checked === false ? unCheckStyle : null)\n      });\n    }\n\n    return itemGroup;\n  };\n\n  _proto._formatItemValue = function _formatItemValue(value) {\n    var formatter = this.itemFormatter;\n\n    if (formatter) {\n      value = formatter.call(this, value);\n    }\n\n    return value;\n  };\n\n  _proto._getMaxItemWidth = function _getMaxItemWidth() {\n    var width;\n    var itemWidth = this.itemWidth;\n\n    if (Util.isNumber(itemWidth) || Util.isNil(itemWidth)) {\n      return itemWidth;\n    }\n\n    if (itemWidth === 'auto') {\n      var itemsGroup = this.itemsGroup;\n      var children = itemsGroup.get('children');\n      var count = children.length;\n      var maxItemWidth = 0;\n\n      for (var i = 0; i < count; i++) {\n        var _children$i$getBBox = children[i].getBBox(),\n            _width = _children$i$getBBox.width;\n\n        maxItemWidth = Math.max(maxItemWidth, _width);\n      }\n\n      var maxLength = this.maxLength;\n      var itemGap = this.itemGap;\n      var twoAvgWidth = (maxLength - itemGap) / 2;\n      var threeAvgWidth = (maxLength - itemGap * 2) / 3;\n\n      if (count === 2) {\n        width = Math.max(maxItemWidth, twoAvgWidth);\n      } else {\n        // 1. max <= 3Avg, 3Avg\n        // 2. 3Avg < max && max < 2avg, 2avg\n        // 3. max > 2avg, max, one column\n        if (maxItemWidth <= threeAvgWidth) {\n          width = threeAvgWidth;\n        } else if (maxItemWidth <= twoAvgWidth) {\n          width = twoAvgWidth;\n        } else {\n          width = maxItemWidth;\n        }\n      }\n\n      return width;\n    }\n  };\n\n  _proto._adjustHorizontal = function _adjustHorizontal() {\n    var maxLength = this.maxLength,\n        itemsGroup = this.itemsGroup;\n    var children = itemsGroup.get('children');\n    var itemGap = this.itemGap,\n        itemMarginBottom = this.itemMarginBottom;\n    var titleHeight = this._titleHeight;\n    var row = 0;\n    var rowWidth = 0;\n    var width;\n    var height;\n\n    var itemWidth = this._getMaxItemWidth();\n\n    var legendHitBoxes = [];\n\n    for (var i = 0, len = children.length; i < len; i++) {\n      var child = children[i];\n      var box = child.getBBox();\n      var childHeight = box.height;\n      var childWidth = box.width;\n      width = itemWidth || childWidth;\n      height = childHeight + itemMarginBottom;\n\n      if (width - (maxLength - rowWidth) > 0.0001) {\n        row++;\n        rowWidth = 0;\n      }\n\n      child.moveTo(rowWidth, row * height);\n      legendHitBoxes.push({\n        x: rowWidth,\n        y: row * height + titleHeight - childHeight / 2,\n        width: childWidth * 1.375,\n        height: childHeight * 1.375\n      });\n      rowWidth += width + itemGap;\n    }\n\n    this.legendHitBoxes = legendHitBoxes;\n    return;\n  };\n\n  _proto._adjustVertical = function _adjustVertical() {\n    var maxLength = this.maxLength,\n        itemsGroup = this.itemsGroup;\n    var itemGap = this.itemGap,\n        itemMarginBottom = this.itemMarginBottom,\n        itemWidth = this.itemWidth;\n    var titleHeight = this._titleHeight;\n    var children = itemsGroup.get('children');\n    var colHeight = 0;\n    var width;\n    var height;\n    var maxItemWidth = 0;\n    var totalWidth = 0;\n    var legendHitBoxes = [];\n\n    for (var i = 0, length = children.length; i < length; i++) {\n      var child = children[i];\n      var bbox = child.getBBox();\n      width = bbox.width;\n      height = bbox.height;\n\n      if (Util.isNumber(itemWidth)) {\n        maxItemWidth = itemWidth + itemGap;\n      } else if (width > maxItemWidth) {\n        maxItemWidth = width + itemGap;\n      }\n\n      if (maxLength - colHeight < height) {\n        colHeight = 0;\n        totalWidth += maxItemWidth;\n        child.moveTo(totalWidth, 0);\n        legendHitBoxes.push({\n          x: totalWidth,\n          y: titleHeight - height / 2,\n          width: width * 1.375,\n          height: height * 1.375\n        });\n      } else {\n        child.moveTo(totalWidth, colHeight);\n        legendHitBoxes.push({\n          x: totalWidth,\n          y: colHeight - height / 2 + titleHeight,\n          width: width * 1.375,\n          height: height * 1.375\n        });\n      }\n\n      colHeight += height + itemMarginBottom;\n    }\n\n    this.legendHitBoxes = legendHitBoxes;\n    return;\n  };\n\n  _proto._adjustItems = function _adjustItems() {\n    var layout = this.layout;\n\n    if (layout === 'horizontal') {\n      this._adjustHorizontal();\n    } else {\n      this._adjustVertical();\n    }\n  };\n\n  _proto.moveTo = function moveTo(x, y) {\n    this.x = x;\n    this.y = y;\n    var container = this.container;\n    container && container.moveTo(x, y);\n    return this;\n  };\n\n  _proto.setItems = function setItems(items) {\n    this.clearItems();\n\n    this._renderItems(items);\n  };\n\n  _proto.setTitle = function setTitle(title) {\n    this._renderTitle(title);\n  };\n\n  _proto.clearItems = function clearItems() {\n    var itemsGroup = this.itemsGroup;\n    itemsGroup.clear();\n  };\n\n  _proto.getWidth = function getWidth() {\n    var container = this.container;\n    var bbox = container.getBBox();\n    return bbox.width;\n  };\n\n  _proto.getHeight = function getHeight() {\n    var container = this.container;\n    var bbox = container.getBBox();\n    return bbox.height;\n  };\n\n  _proto.show = function show() {\n    var container = this.container;\n    container.show();\n  };\n\n  _proto.hide = function hide() {\n    var container = this.container;\n    container.hide();\n  };\n\n  _proto.clear = function clear() {\n    var container = this.container;\n    container.clear();\n    container.remove(true);\n  };\n\n  return List;\n}();\n\nmodule.exports = List;\n\n/***/ }),\n/* 102 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Animate configuration and register\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar defaultAnimationCfg = {\n  appear: {\n    duration: 450,\n    easing: 'quadraticOut'\n  },\n  // 'appear' animation options\n  update: {\n    duration: 300,\n    easing: 'quadraticOut'\n  },\n  // 'update' animation options\n  enter: {\n    duration: 300,\n    easing: 'quadraticOut'\n  },\n  // 'enter' animation options\n  leave: {\n    duration: 350,\n    easing: 'quadraticIn' // 'leave' animation options\n\n  }\n};\nvar Animate = {\n  defaultCfg: {},\n  Action: {},\n  getAnimation: function getAnimation(geomType, coord, animationType) {\n    var geomAnimateCfg = this.defaultCfg[geomType];\n\n    if (geomAnimateCfg) {\n      var animation = geomAnimateCfg[animationType];\n\n      if (Util.isFunction(animation)) {\n        return animation(coord);\n      }\n    }\n\n    return false;\n  },\n  getAnimateCfg: function getAnimateCfg(geomType, animationType) {\n    var defaultCfg = defaultAnimationCfg[animationType];\n    var geomConfig = this.defaultCfg[geomType];\n\n    if (geomConfig && geomConfig.cfg && geomConfig.cfg[animationType]) {\n      return Util.deepMix({}, defaultCfg, geomConfig.cfg[animationType]);\n    }\n\n    return defaultCfg;\n  },\n  registerAnimation: function registerAnimation(animationName, animationFun) {\n    if (!this.Action) {\n      this.Action = {};\n    }\n\n    this.Action[animationName] = animationFun;\n  }\n};\nmodule.exports = Animate;\n\n/***/ }),\n/* 103 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Utility\n * @author sima.zhang1990@gmail.com\n */\nvar _require = __webpack_require__(5),\n    Matrix = _require.Matrix;\n\nvar Util = __webpack_require__(0);\n\nvar Helpers = {\n  getCoordInfo: function getCoordInfo(coord) {\n    var start = coord.start;\n    var end = coord.end;\n    return {\n      start: start,\n      end: end,\n      width: end.x - start.x,\n      height: Math.abs(end.y - start.y)\n    };\n  },\n  getScaledMatrix: function getScaledMatrix(shape, v, direct) {\n    var scaledMatrix;\n    shape.apply(v);\n    var x = v[0];\n    var y = v[1];\n\n    if (direct === 'x') {\n      shape.transform([['t', x, y], ['s', 0.01, 1], ['t', -x, -y]]);\n      var matrix = shape.getMatrix();\n      scaledMatrix = Matrix.transform(matrix, [['t', x, y], ['s', 100, 1], ['t', -x, -y]]);\n    } else if (direct === 'y') {\n      shape.transform([['t', x, y], ['s', 1, 0.01], ['t', -x, -y]]);\n\n      var _matrix = shape.getMatrix();\n\n      scaledMatrix = Matrix.transform(_matrix, [['t', x, y], ['s', 1, 100], ['t', -x, -y]]);\n    } else if (direct === 'xy') {\n      shape.transform([['t', x, y], ['s', 0.01, 0.01], ['t', -x, -y]]);\n\n      var _matrix2 = shape.getMatrix();\n\n      scaledMatrix = Matrix.transform(_matrix2, [['t', x, y], ['s', 100, 100], ['t', -x, -y]]);\n    }\n\n    return scaledMatrix;\n  },\n  getAnimateParam: function getAnimateParam(animateCfg, index, id) {\n    var result = {};\n\n    if (animateCfg.delay) {\n      result.delay = Util.isFunction(animateCfg.delay) ? animateCfg.delay(index, id) : animateCfg.delay;\n    }\n\n    result.easing = animateCfg.easing;\n    result.duration = animateCfg.duration;\n    result.delay = animateCfg.delay;\n    return result;\n  },\n  doAnimation: function doAnimation(shape, endState, animateCfg, callback) {\n    var id = shape._id;\n    var index = shape.get('index');\n\n    var _Helpers$getAnimatePa = Helpers.getAnimateParam(animateCfg, index, id),\n        easing = _Helpers$getAnimatePa.easing,\n        delay = _Helpers$getAnimatePa.delay,\n        duration = _Helpers$getAnimatePa.duration;\n\n    var anim = shape.animate().to({\n      attrs: endState,\n      duration: duration,\n      delay: delay,\n      easing: easing\n    });\n\n    if (callback) {\n      anim.onEnd(function () {\n        callback();\n      });\n    }\n  }\n};\nmodule.exports = Helpers;\n\n/***/ }),\n/* 104 */,\n/* 105 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Geom = __webpack_require__(6);\n\n__webpack_require__(106);\n\n__webpack_require__(42);\n\n__webpack_require__(90);\n\n__webpack_require__(108);\n\n__webpack_require__(91);\n\n__webpack_require__(110);\n\n__webpack_require__(112);\n\nmodule.exports = Geom;\n\n/***/ }),\n/* 106 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Geom = __webpack_require__(6);\n\n__webpack_require__(107);\n\nvar Point =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Point, _Geom);\n\n  function Point() {\n    return _Geom.apply(this, arguments) || this;\n  }\n\n  var _proto = Point.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'point';\n    cfg.shapeType = 'point';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  _proto.draw = function draw(data, shapeFactory) {\n    var self = this;\n    var container = self.get('container');\n    Util.each(data, function (obj) {\n      var shape = obj.shape;\n      var cfg = self.getDrawCfg(obj);\n\n      if (Util.isArray(obj.y)) {\n        var hasStack = self.hasAdjust('stack');\n        Util.each(obj.y, function (y, idx) {\n          cfg.y = y;\n\n          if (!hasStack || idx !== 0) {\n            self.drawShape(shape, obj, cfg, container, shapeFactory);\n          }\n        });\n      } else if (!Util.isNil(obj.y)) {\n        self.drawShape(shape, obj, cfg, container, shapeFactory);\n      }\n    });\n  };\n\n  return Point;\n}(Geom);\n\nGeom.Point = Point;\nmodule.exports = Point;\n\n/***/ }),\n/* 107 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(1);\n\nvar ShapeUtil = __webpack_require__(19);\n\nvar Shape = __webpack_require__(8);\n\nvar SHAPES = ['circle', 'hollowCircle', 'rect'];\nvar Point = Shape.registerFactory('point', {\n  defaultShapeType: 'circle',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    return ShapeUtil.splitPoints(pointInfo);\n  }\n});\n\nfunction getPointsCfg(cfg) {\n  var style = {\n    lineWidth: 0,\n    stroke: cfg.color,\n    fill: cfg.color\n  };\n\n  if (cfg.size) {\n    style.size = cfg.size;\n  }\n\n  Util.mix(style, cfg.style);\n  return Util.mix({}, Global.shape.point, style);\n}\n\nfunction drawShape(cfg, container, shape) {\n  if (cfg.size === 0) return;\n  var pointCfg = getPointsCfg(cfg);\n  var size = pointCfg.r || pointCfg.size;\n  var x = cfg.x;\n  var y = !Util.isArray(cfg.y) ? [cfg.y] : cfg.y;\n\n  if (shape === 'hollowCircle') {\n    pointCfg.lineWidth = 1;\n    pointCfg.fill = null;\n  }\n\n  for (var i = 0, len = y.length; i < len; i++) {\n    if (shape === 'rect') {\n      return container.addShape('Rect', {\n        className: 'point',\n        attrs: Util.mix({\n          x: x - size,\n          y: y[i] - size,\n          width: size * 2,\n          height: size * 2\n        }, pointCfg)\n      });\n    }\n\n    return container.addShape('Circle', {\n      className: 'point',\n      attrs: Util.mix({\n        x: x,\n        y: y[i],\n        r: size\n      }, pointCfg)\n    });\n  }\n}\n\nUtil.each(SHAPES, function (shapeType) {\n  Shape.registerShape('point', shapeType, {\n    draw: function draw(cfg, container) {\n      return drawShape(cfg, container, shapeType);\n    }\n  });\n});\nmodule.exports = Point;\n\n/***/ }),\n/* 108 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\n/**\n * @fileOverview area geometry\n * @author dxq613 @gmail.com\n * @author sima.zhang1990@gmail.com\n */\nvar Geom = __webpack_require__(6);\n\nvar ShapeUtil = __webpack_require__(19);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(109);\n\nvar Area =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Area, _Geom);\n\n  function Area() {\n    return _Geom.apply(this, arguments) || this;\n  }\n\n  var _proto = Area.prototype;\n\n  /**\n   * get the default configuration\n   * @protected\n   * @return {Object} return the result\n   */\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'area';\n    cfg.shapeType = 'area';\n    cfg.generatePoints = true;\n    cfg.sortable = true;\n    return cfg;\n  };\n\n  _proto.draw = function draw(data, shapeFactory) {\n    var self = this;\n    var container = self.get('container');\n    var cfg = this.getDrawCfg(data[0]);\n    var yScale = self.getYScale();\n    var connectNulls = self.get('connectNulls');\n    var splitArray = ShapeUtil.splitArray(data, yScale.field, connectNulls);\n    cfg.origin = data;\n    Util.each(splitArray, function (subData, splitedIndex) {\n      cfg.splitedIndex = splitedIndex;\n      var points = subData.map(function (obj) {\n        return obj.points;\n      });\n      cfg.points = points;\n      self.drawShape(cfg.shape, data[0], cfg, container, shapeFactory);\n    });\n  };\n\n  return Area;\n}(Geom);\n\nGeom.Area = Area;\nmodule.exports = Area;\n\n/***/ }),\n/* 109 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Shape = __webpack_require__(8);\n\nvar Smooth = __webpack_require__(41);\n\nvar bbox = __webpack_require__(10);\n\nvar Global = __webpack_require__(1);\n\nfunction equals(v1, v2) {\n  return Math.abs(v1 - v2) < 0.00001;\n}\n\nfunction notEmpty(value) {\n  return !isNaN(value) && !Util.isNil(value);\n}\n\nfunction filterPoints(points) {\n  var filteredPoints = []; // filter the point which x or y is NaN\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var point = points[i];\n\n    if (notEmpty(point.x) && notEmpty(point.y)) {\n      filteredPoints.push(point);\n    }\n  }\n\n  return filteredPoints;\n}\n\nfunction equalsCenter(points, center) {\n  var eqls = true;\n  Util.each(points, function (point) {\n    if (!equals(point.x, center.x) || !equals(point.y, center.y)) {\n      eqls = false;\n      return false;\n    }\n  });\n  return eqls;\n}\n\nfunction drawRectShape(topPoints, bottomPoints, container, style, isSmooth) {\n  var shape;\n  var points = topPoints.concat(bottomPoints);\n\n  if (isSmooth) {\n    shape = container.addShape('Custom', {\n      className: 'area',\n      attrs: Util.mix({\n        points: points\n      }, style),\n      createPath: function createPath(context) {\n        var constaint = [[0, 0], [1, 1]];\n        var points = filterPoints(this._attrs.attrs.points);\n        var pointsLen = points.length;\n        var topPoints = points.slice(0, pointsLen / 2);\n        var bottomPoints = points.slice(pointsLen / 2, pointsLen);\n        var topSps = Smooth.smooth(topPoints, false, constaint);\n        context.beginPath();\n        context.moveTo(topPoints[0].x, topPoints[0].y);\n\n        for (var i = 0, n = topSps.length; i < n; i++) {\n          var sp = topSps[i];\n          context.bezierCurveTo(sp[1], sp[2], sp[3], sp[4], sp[5], sp[6]);\n        }\n\n        if (bottomPoints.length) {\n          var bottomSps = Smooth.smooth(bottomPoints, false, constaint);\n          context.lineTo(bottomPoints[0].x, bottomPoints[0].y);\n\n          for (var _i = 0, _n = bottomSps.length; _i < _n; _i++) {\n            var _sp = bottomSps[_i];\n            context.bezierCurveTo(_sp[1], _sp[2], _sp[3], _sp[4], _sp[5], _sp[6]);\n          }\n        }\n\n        context.closePath();\n      },\n      calculateBox: function calculateBox() {\n        var points = filterPoints(this._attrs.attrs.points);\n        return bbox.getBBoxFromPoints(points);\n      }\n    });\n  } else {\n    shape = container.addShape('Polyline', {\n      className: 'area',\n      attrs: Util.mix({\n        points: points\n      }, style)\n    });\n  }\n\n  return shape;\n}\n\nfunction drawShape(cfg, container, isSmooth) {\n  var self = this;\n  var points = cfg.points;\n  var topPoints = [];\n  var bottomPoints = [];\n  Util.each(points, function (point) {\n    bottomPoints.push(point[0]);\n    topPoints.push(point[1]);\n  });\n  var style = Util.mix({\n    fillStyle: cfg.color\n  }, Global.shape.area, cfg.style);\n  bottomPoints.reverse();\n  topPoints = self.parsePoints(topPoints);\n  bottomPoints = self.parsePoints(bottomPoints);\n\n  if (cfg.isInCircle) {\n    topPoints.push(topPoints[0]);\n    bottomPoints.unshift(bottomPoints[bottomPoints.length - 1]);\n\n    if (equalsCenter(bottomPoints, cfg.center)) {\n      bottomPoints = [];\n    }\n  }\n\n  return drawRectShape(topPoints, bottomPoints, container, style, isSmooth);\n}\n\nvar Area = Shape.registerFactory('area', {\n  defaultShapeType: 'area',\n  getDefaultPoints: function getDefaultPoints(obj) {\n    var x = obj.x;\n    var y = obj.y;\n    var y0 = obj.y0;\n    y = Util.isArray(y) ? y : [y0, y];\n    var points = [];\n    points.push({\n      x: x,\n      y: y[0]\n    }, {\n      x: x,\n      y: y[1]\n    });\n    return points;\n  }\n});\nvar SHAPES = ['area', 'smooth'];\nUtil.each(SHAPES, function (shapeType) {\n  Shape.registerShape('area', shapeType, {\n    draw: function draw(cfg, container) {\n      var smooth = shapeType === 'smooth';\n      return drawShape.call(this, cfg, container, smooth);\n    }\n  });\n});\nmodule.exports = Area;\n\n/***/ }),\n/* 110 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Geom = __webpack_require__(6);\n\nvar Util = __webpack_require__(0);\n\n__webpack_require__(111);\n\nvar Polygon =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Polygon, _Geom);\n\n  function Polygon() {\n    return _Geom.apply(this, arguments) || this;\n  }\n\n  var _proto = Polygon.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'polygon';\n    cfg.shapeType = 'polygon';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\n\n    var self = this;\n    var x = cfg.x;\n    var y = cfg.y;\n    var temp;\n\n    if (!(Util.isArray(x) && Util.isArray(y))) {\n      var xScale = self.getXScale();\n      var yScale = self.getYScale();\n      var xCount = xScale.values ? xScale.values.length : xScale.ticks.length;\n      var yCount = yScale.values ? yScale.values.length : yScale.ticks.length;\n      var xOffset = 0.5 * 1 / xCount;\n      var yOffset = 0.5 * 1 / yCount;\n\n      if (xScale.isCategory && yScale.isCategory) {\n        x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];\n        y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];\n      } else if (Util.isArray(x)) {\n        temp = x;\n        x = [temp[0], temp[0], temp[1], temp[1]];\n        y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];\n      } else if (Util.isArray(y)) {\n        temp = y;\n        y = [temp[0], temp[1], temp[1], temp[0]];\n        x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];\n      }\n\n      cfg.x = x;\n      cfg.y = y;\n    }\n\n    return cfg;\n  };\n\n  return Polygon;\n}(Geom);\n\nGeom.Polygon = Polygon;\nmodule.exports = Polygon;\n\n/***/ }),\n/* 111 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Shape = __webpack_require__(8);\n\nvar Util = __webpack_require__(0);\n\nvar Polygon = Shape.registerFactory('polygon', {\n  defaultShapeType: 'polygon',\n  getDefaultPoints: function getDefaultPoints(pointInfo) {\n    var points = [];\n    var x = pointInfo.x,\n        y = pointInfo.y;\n\n    for (var i = 0, len = x.length; i < len; i++) {\n      points.push({\n        x: x[i],\n        y: y[i]\n      });\n    }\n\n    return points;\n  }\n});\nShape.registerShape('polygon', 'polygon', {\n  draw: function draw(cfg, container) {\n    var points = this.parsePoints(cfg.points);\n    var style = Util.mix({\n      fill: cfg.color,\n      points: points\n    }, cfg.style);\n    return container.addShape('Polygon', {\n      className: 'polygon',\n      attrs: style\n    });\n  }\n});\nmodule.exports = Polygon;\n\n/***/ }),\n/* 112 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Geom = __webpack_require__(6);\n\nvar Util = __webpack_require__(0);\n\nvar SizeMixin = __webpack_require__(43);\n\n__webpack_require__(113);\n\nvar Schema =\n/*#__PURE__*/\nfunction (_Geom) {\n  _inheritsLoose(Schema, _Geom);\n\n  var _proto = Schema.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    var cfg = _Geom.prototype.getDefaultCfg.call(this);\n\n    cfg.type = 'schema';\n    cfg.shapeType = 'schema';\n    cfg.generatePoints = true;\n    return cfg;\n  };\n\n  function Schema(cfg) {\n    var _this;\n\n    _this = _Geom.call(this, cfg) || this;\n    Util.mix(_assertThisInitialized(_this), SizeMixin);\n    return _this;\n  }\n\n  _proto.createShapePointsCfg = function createShapePointsCfg(obj) {\n    var cfg = _Geom.prototype.createShapePointsCfg.call(this, obj);\n\n    cfg.size = this.getNormalizedSize(obj);\n    return cfg;\n  };\n\n  _proto.clearInner = function clearInner() {\n    _Geom.prototype.clearInner.call(this);\n\n    this.set('defaultSize', null);\n  };\n\n  return Schema;\n}(Geom);\n\nGeom.Schema = Schema;\nmodule.exports = Schema;\n\n/***/ }),\n/* 113 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Shape = __webpack_require__(8);\n\nvar Util = __webpack_require__(0);\n\nfunction _sortValue(value) {\n  var sorted = value.sort(function (a, b) {\n    return a < b ? 1 : -1;\n  });\n  var length = sorted.length;\n\n  if (length < 4) {\n    var min = sorted[length - 1];\n\n    for (var i = 0; i < 4 - length; i++) {\n      sorted.push(min);\n    }\n  }\n\n  return sorted;\n} // from left bottom corner, and clockwise\n\n\nfunction getCandlePoints(x, y, width) {\n  var yValues = _sortValue(y);\n\n  var points = [{\n    x: x,\n    y: yValues[0]\n  }, {\n    x: x,\n    y: yValues[1]\n  }, {\n    x: x - width / 2,\n    y: yValues[2]\n  }, {\n    x: x - width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[1]\n  }, {\n    x: x + width / 2,\n    y: yValues[2]\n  }, {\n    x: x,\n    y: yValues[2]\n  }, {\n    x: x,\n    y: yValues[3]\n  }];\n  return points;\n}\n\nvar Schema = Shape.registerFactory('schema', {});\nShape.registerShape('schema', 'candle', {\n  getPoints: function getPoints(cfg) {\n    return getCandlePoints(cfg.x, cfg.y, cfg.size);\n  },\n  draw: function draw(cfg, container) {\n    var points = this.parsePoints(cfg.points);\n    var style = Util.mix({\n      stroke: cfg.color,\n      fill: cfg.color,\n      lineWidth: 1\n    }, cfg.style);\n    return container.addShape('Custom', {\n      className: 'schema',\n      attrs: style,\n      createPath: function createPath(ctx) {\n        ctx.beginPath();\n        ctx.moveTo(points[0].x, points[0].y);\n        ctx.lineTo(points[1].x, points[1].y);\n        ctx.moveTo(points[2].x, points[2].y);\n\n        for (var i = 3; i < 6; i++) {\n          ctx.lineTo(points[i].x, points[i].y);\n        }\n\n        ctx.closePath();\n        ctx.moveTo(points[6].x, points[6].y);\n        ctx.lineTo(points[7].x, points[7].y);\n      }\n    });\n  }\n});\nmodule.exports = Schema;\n\n/***/ }),\n/* 114 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar Abstract = __webpack_require__(26);\n\nvar Circle =\n/*#__PURE__*/\nfunction (_Abstract) {\n  _inheritsLoose(Circle, _Abstract);\n\n  function Circle() {\n    return _Abstract.apply(this, arguments) || this;\n  }\n\n  var _proto = Circle.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Abstract.prototype._initDefaultCfg.call(this);\n\n    this.startAngle = -Math.PI / 2; // start angle，in radian\n\n    this.endAngle = Math.PI * 3 / 2; // end angle, in radian\n\n    this.radius = null; // radius\n\n    this.center = null; // center\n  };\n\n  _proto.getOffsetPoint = function getOffsetPoint(value) {\n    var startAngle = this.startAngle,\n        endAngle = this.endAngle;\n    var angle = startAngle + (endAngle - startAngle) * value;\n    return this._getCirclePoint(angle);\n  };\n\n  _proto._getCirclePoint = function _getCirclePoint(angle, radius) {\n    var self = this;\n    var center = self.center;\n    radius = radius || self.radius;\n    return {\n      x: center.x + Math.cos(angle) * radius,\n      y: center.y + Math.sin(angle) * radius\n    };\n  };\n\n  _proto.getTextAlignInfo = function getTextAlignInfo(point, offset) {\n    var self = this;\n    var offsetVector = self.getOffsetVector(point, offset);\n    var align;\n    var baseLine = 'middle';\n\n    if (offsetVector[0] > 0) {\n      align = 'left';\n    } else if (offsetVector[0] < 0) {\n      align = 'right';\n    } else {\n      align = 'center';\n\n      if (offsetVector[1] > 0) {\n        baseLine = 'top';\n      } else if (offsetVector[1] < 0) {\n        baseLine = 'bottom';\n      }\n    }\n\n    return {\n      textAlign: align,\n      textBaseline: baseLine\n    };\n  };\n\n  _proto.getAxisVector = function getAxisVector(point) {\n    var center = this.center;\n    var factor = this.offsetFactor;\n    return [(point.y - center.y) * factor, (point.x - center.x) * -1 * factor];\n  };\n\n  _proto.drawLine = function drawLine(lineCfg) {\n    var center = this.center,\n        radius = this.radius,\n        startAngle = this.startAngle,\n        endAngle = this.endAngle;\n    var container = this.getContainer(lineCfg.top);\n    container.addShape('arc', {\n      className: 'axis-line',\n      attrs: Util.mix({\n        x: center.x,\n        y: center.y,\n        r: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n      }, lineCfg)\n    });\n  };\n\n  return Circle;\n}(Abstract);\n\nAbstract.Circle = Circle;\nmodule.exports = Circle;\n\n/***/ }),\n/* 115 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar TimeCat = __webpack_require__(116);\n\nmodule.exports = TimeCat;\n\n/***/ }),\n/* 116 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n/**\n * @fileOverview 时间数据作为分类类型\n * @author dxq613@gmail.com\n */\n\n\nvar Base = __webpack_require__(12);\n\nvar Category = __webpack_require__(38);\n\nvar fecha = __webpack_require__(117);\n\nvar catAuto = __webpack_require__(39);\n\nvar TimeUtil = __webpack_require__(99);\n\nvar each = __webpack_require__(4);\n\nvar isNumber = __webpack_require__(17);\n\nvar isObject = __webpack_require__(25);\n\nvar isString = __webpack_require__(18);\n/**\n * 度量的构造函数\n * @class Scale.TimeCategory\n */\n\n\nvar TimeCategory =\n/*#__PURE__*/\nfunction (_Category) {\n  _inheritsLoose(TimeCategory, _Category);\n\n  function TimeCategory() {\n    return _Category.apply(this, arguments) || this;\n  }\n\n  var _proto = TimeCategory.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    _Category.prototype._initDefaultCfg.call(this);\n\n    this.type = 'timeCat';\n    /**\n     * 是否需要排序，默认进行排序\n     * @type {Boolean}\n     */\n\n    this.sortable = true;\n    this.tickCount = 5;\n    /**\n     * 时间格式化\n     * @type {String}\n     */\n\n    this.mask = 'YYYY-MM-DD';\n  };\n\n  _proto.init = function init() {\n    var self = this;\n    var values = this.values; // 针对时间分类类型，会将时间统一转换为时间戳\n\n    each(values, function (v, i) {\n      values[i] = self._toTimeStamp(v);\n    });\n\n    if (this.sortable) {\n      // 允许排序\n      values.sort(function (v1, v2) {\n        return v1 - v2;\n      });\n    }\n\n    if (!self.ticks) {\n      self.ticks = this.calculateTicks();\n    }\n  }\n  /**\n   * 计算 ticks\n   * @return {array} 返回 ticks 数组\n   */\n  ;\n\n  _proto.calculateTicks = function calculateTicks() {\n    var self = this;\n    var count = self.tickCount;\n    var ticks;\n\n    if (count) {\n      var temp = catAuto({\n        maxCount: count,\n        data: self.values,\n        isRounding: self.isRounding\n      });\n      ticks = temp.ticks;\n    } else {\n      ticks = self.values;\n    }\n\n    return ticks;\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.translate = function translate(value) {\n    value = this._toTimeStamp(value);\n    var index = this.values.indexOf(value);\n\n    if (index === -1) {\n      if (isNumber(value) && value < this.values.length) {\n        index = value;\n      } else {\n        index = NaN;\n      }\n    }\n\n    return index;\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.scale = function scale(value) {\n    var rangeMin = this.rangeMin();\n    var rangeMax = this.rangeMax();\n    var index = this.translate(value);\n    var percent;\n\n    if (this.values.length === 1 || isNaN(index)) {\n      // is index is NAN should not be set as 0\n      percent = index;\n    } else if (index > -1) {\n      percent = index / (this.values.length - 1);\n    } else {\n      percent = 0;\n    }\n\n    return rangeMin + percent * (rangeMax - rangeMin);\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.getText = function getText(value) {\n    var result = '';\n    var index = this.translate(value);\n\n    if (index > -1) {\n      result = this.values[index];\n    } else {\n      result = value;\n    }\n\n    var formatter = this.formatter;\n    result = parseInt(result, 10);\n    result = formatter ? formatter(result) : fecha.format(result, this.mask);\n    return result;\n  }\n  /**\n   * @override\n   */\n  ;\n\n  _proto.getTicks = function getTicks() {\n    var self = this;\n    var ticks = this.ticks;\n    var rst = [];\n    each(ticks, function (tick) {\n      var obj;\n\n      if (isObject(tick)) {\n        obj = tick;\n      } else {\n        obj = {\n          text: isString(tick) ? tick : self.getText(tick),\n          value: self.scale(tick),\n          tickValue: tick // 用于坐标轴上文本动画时确定前后帧的对应关系\n\n        };\n      }\n\n      rst.push(obj);\n    });\n    return rst;\n  } // 将时间转换为时间戳\n  ;\n\n  _proto._toTimeStamp = function _toTimeStamp(value) {\n    return TimeUtil.toTimeStamp(value);\n  };\n\n  return TimeCategory;\n}(Category);\n\nBase.TimeCat = TimeCategory;\nmodule.exports = TimeCategory;\n\n/***/ }),\n/* 117 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar __WEBPACK_AMD_DEFINE_RESULT__;(function (main) {\n  'use strict';\n  /**\n   * Parse or format dates\n   * @class fecha\n   */\n\n  var fecha = {};\n  var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|([HhMsDm])\\1?|[aA]|\"[^\"]*\"|'[^']*'/g;\n  var twoDigits = /\\d\\d?/;\n  var threeDigits = /\\d{3}/;\n  var fourDigits = /\\d{4}/;\n  var word = /[0-9]*['a-z\\u00A0-\\u05FF\\u0700-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]+|[\\u0600-\\u06FF\\/]+(\\s*?[\\u0600-\\u06FF]+){1,2}/i;\n  var literal = /\\[([^]*?)\\]/gm;\n\n  var noop = function () {};\n\n  function shorten(arr, sLen) {\n    var newArr = [];\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      newArr.push(arr[i].substr(0, sLen));\n    }\n\n    return newArr;\n  }\n\n  function monthUpdate(arrName) {\n    return function (d, v, i18n) {\n      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());\n\n      if (~index) {\n        d.month = index;\n      }\n    };\n  }\n\n  function pad(val, len) {\n    val = String(val);\n    len = len || 2;\n\n    while (val.length < len) {\n      val = '0' + val;\n    }\n\n    return val;\n  }\n\n  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  var monthNamesShort = shorten(monthNames, 3);\n  var dayNamesShort = shorten(dayNames, 3);\n  fecha.i18n = {\n    dayNamesShort: dayNamesShort,\n    dayNames: dayNames,\n    monthNamesShort: monthNamesShort,\n    monthNames: monthNames,\n    amPm: ['am', 'pm'],\n    DoFn: function DoFn(D) {\n      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];\n    }\n  };\n  var formatFlags = {\n    D: function (dateObj) {\n      return dateObj.getDate();\n    },\n    DD: function (dateObj) {\n      return pad(dateObj.getDate());\n    },\n    Do: function (dateObj, i18n) {\n      return i18n.DoFn(dateObj.getDate());\n    },\n    d: function (dateObj) {\n      return dateObj.getDay();\n    },\n    dd: function (dateObj) {\n      return pad(dateObj.getDay());\n    },\n    ddd: function (dateObj, i18n) {\n      return i18n.dayNamesShort[dateObj.getDay()];\n    },\n    dddd: function (dateObj, i18n) {\n      return i18n.dayNames[dateObj.getDay()];\n    },\n    M: function (dateObj) {\n      return dateObj.getMonth() + 1;\n    },\n    MM: function (dateObj) {\n      return pad(dateObj.getMonth() + 1);\n    },\n    MMM: function (dateObj, i18n) {\n      return i18n.monthNamesShort[dateObj.getMonth()];\n    },\n    MMMM: function (dateObj, i18n) {\n      return i18n.monthNames[dateObj.getMonth()];\n    },\n    YY: function (dateObj) {\n      return String(dateObj.getFullYear()).substr(2);\n    },\n    YYYY: function (dateObj) {\n      return pad(dateObj.getFullYear(), 4);\n    },\n    h: function (dateObj) {\n      return dateObj.getHours() % 12 || 12;\n    },\n    hh: function (dateObj) {\n      return pad(dateObj.getHours() % 12 || 12);\n    },\n    H: function (dateObj) {\n      return dateObj.getHours();\n    },\n    HH: function (dateObj) {\n      return pad(dateObj.getHours());\n    },\n    m: function (dateObj) {\n      return dateObj.getMinutes();\n    },\n    mm: function (dateObj) {\n      return pad(dateObj.getMinutes());\n    },\n    s: function (dateObj) {\n      return dateObj.getSeconds();\n    },\n    ss: function (dateObj) {\n      return pad(dateObj.getSeconds());\n    },\n    S: function (dateObj) {\n      return Math.round(dateObj.getMilliseconds() / 100);\n    },\n    SS: function (dateObj) {\n      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);\n    },\n    SSS: function (dateObj) {\n      return pad(dateObj.getMilliseconds(), 3);\n    },\n    a: function (dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];\n    },\n    A: function (dateObj, i18n) {\n      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();\n    },\n    ZZ: function (dateObj) {\n      var o = dateObj.getTimezoneOffset();\n      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);\n    }\n  };\n  var parseFlags = {\n    D: [twoDigits, function (d, v) {\n      d.day = v;\n    }],\n    Do: [new RegExp(twoDigits.source + word.source), function (d, v) {\n      d.day = parseInt(v, 10);\n    }],\n    M: [twoDigits, function (d, v) {\n      d.month = v - 1;\n    }],\n    YY: [twoDigits, function (d, v) {\n      var da = new Date(),\n          cent = +('' + da.getFullYear()).substr(0, 2);\n      d.year = '' + (v > 68 ? cent - 1 : cent) + v;\n    }],\n    h: [twoDigits, function (d, v) {\n      d.hour = v;\n    }],\n    m: [twoDigits, function (d, v) {\n      d.minute = v;\n    }],\n    s: [twoDigits, function (d, v) {\n      d.second = v;\n    }],\n    YYYY: [fourDigits, function (d, v) {\n      d.year = v;\n    }],\n    S: [/\\d/, function (d, v) {\n      d.millisecond = v * 100;\n    }],\n    SS: [/\\d{2}/, function (d, v) {\n      d.millisecond = v * 10;\n    }],\n    SSS: [threeDigits, function (d, v) {\n      d.millisecond = v;\n    }],\n    d: [twoDigits, noop],\n    ddd: [word, noop],\n    MMM: [word, monthUpdate('monthNamesShort')],\n    MMMM: [word, monthUpdate('monthNames')],\n    a: [word, function (d, v, i18n) {\n      var val = v.toLowerCase();\n\n      if (val === i18n.amPm[0]) {\n        d.isPm = false;\n      } else if (val === i18n.amPm[1]) {\n        d.isPm = true;\n      }\n    }],\n    ZZ: [/([\\+\\-]\\d\\d:?\\d\\d|Z)/, function (d, v) {\n      if (v === 'Z') v = '+00:00';\n      var parts = (v + '').match(/([\\+\\-]|\\d\\d)/gi),\n          minutes;\n\n      if (parts) {\n        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);\n        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;\n      }\n    }]\n  };\n  parseFlags.dd = parseFlags.d;\n  parseFlags.dddd = parseFlags.ddd;\n  parseFlags.DD = parseFlags.D;\n  parseFlags.mm = parseFlags.m;\n  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;\n  parseFlags.MM = parseFlags.M;\n  parseFlags.ss = parseFlags.s;\n  parseFlags.A = parseFlags.a; // Some common format strings\n\n  fecha.masks = {\n    default: 'ddd MMM DD YYYY HH:mm:ss',\n    shortDate: 'M/D/YY',\n    mediumDate: 'MMM D, YYYY',\n    longDate: 'MMMM D, YYYY',\n    fullDate: 'dddd, MMMM D, YYYY',\n    shortTime: 'HH:mm',\n    mediumTime: 'HH:mm:ss',\n    longTime: 'HH:mm:ss.SSS'\n  };\n  /***\n   * Format a date\n   * @method format\n   * @param {Date|number} dateObj\n   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'\n   */\n\n  fecha.format = function (dateObj, mask, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof dateObj === 'number') {\n      dateObj = new Date(dateObj);\n    }\n\n    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {\n      throw new Error('Invalid Date in fecha.format');\n    }\n\n    mask = fecha.masks[mask] || mask || fecha.masks['default'];\n    var literals = []; // Make literals inactive by replacing them with ??\n\n    mask = mask.replace(literal, function ($0, $1) {\n      literals.push($1);\n      return '??';\n    }); // Apply formatting rules\n\n    mask = mask.replace(token, function ($0) {\n      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);\n    }); // Inline literal values back into the formatted value\n\n    return mask.replace(/\\?\\?/g, function () {\n      return literals.shift();\n    });\n  };\n  /**\n   * Parse a date string into an object, changes - into /\n   * @method parse\n   * @param {string} dateStr Date string\n   * @param {string} format Date parse format\n   * @returns {Date|boolean}\n   */\n\n\n  fecha.parse = function (dateStr, format, i18nSettings) {\n    var i18n = i18nSettings || fecha.i18n;\n\n    if (typeof format !== 'string') {\n      throw new Error('Invalid format in fecha.parse');\n    }\n\n    format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings\n    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS\n\n    if (dateStr.length > 1000) {\n      return false;\n    }\n\n    var isValid = true;\n    var dateInfo = {};\n    format.replace(token, function ($0) {\n      if (parseFlags[$0]) {\n        var info = parseFlags[$0];\n        var index = dateStr.search(info[0]);\n\n        if (!~index) {\n          isValid = false;\n        } else {\n          dateStr.replace(info[0], function (result) {\n            info[1](dateInfo, result, i18n);\n            dateStr = dateStr.substr(index + result.length);\n            return result;\n          });\n        }\n      }\n\n      return parseFlags[$0] ? '' : $0.slice(1, $0.length - 1);\n    });\n\n    if (!isValid) {\n      return false;\n    }\n\n    var today = new Date();\n\n    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {\n      dateInfo.hour = +dateInfo.hour + 12;\n    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {\n      dateInfo.hour = 0;\n    }\n\n    var date;\n\n    if (dateInfo.timezoneOffset != null) {\n      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;\n      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));\n    } else {\n      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);\n    }\n\n    return date;\n  };\n  /* istanbul ignore next */\n\n\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = fecha;\n  } else if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return fecha;\n    }.call(exports, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this);\n\n/***/ }),\n/* 118 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar isType = __webpack_require__(16);\n\nvar isDate = function isDate(value) {\n  return isType(value, 'Date');\n};\n\nmodule.exports = isDate;\n\n/***/ }),\n/* 119 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Arc =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Arc, _GuideBase);\n\n  function Arc() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Arc.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'arc';\n    /**\n     * start point\n     * @type {Array | Function}\n     */\n\n    this.start = [];\n    /**\n     * end point\n     * @type {Array | Function}\n     */\n\n    this.end = [];\n    /**\n     * style configuration\n     * @type {Object}\n     */\n\n    this.style = {\n      stroke: '#999',\n      lineWidth: 1\n    };\n  };\n\n  _proto.render = function render(coord, container) {\n    var self = this;\n    var start = self.parsePoint(coord, self.start);\n    var end = self.parsePoint(coord, self.end);\n\n    if (!start || !end) {\n      return;\n    }\n\n    var coordCenter = coord.center;\n    var radius = Math.sqrt((start.x - coordCenter.x) * (start.x - coordCenter.x) + (start.y - coordCenter.y) * (start.y - coordCenter.y));\n    var startAngle = Math.atan2(start.y - coordCenter.y, start.x - coordCenter.x);\n    var endAngle = Math.atan2(end.y - coordCenter.y, end.x - coordCenter.x);\n    var shape = container.addShape('arc', {\n      className: 'guide-arc',\n      attrs: Util.mix({\n        x: coordCenter.x,\n        y: coordCenter.y,\n        r: radius,\n        startAngle: startAngle,\n        endAngle: endAngle\n      }, self.style)\n    });\n    self.element = shape;\n    return shape;\n  };\n\n  return Arc;\n}(GuideBase);\n\nGuideBase.Arc = Arc;\nmodule.exports = Arc;\n\n/***/ }),\n/* 120 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nfunction getOffsetFromAlign(alignX, alignY, width, height) {\n  var result = [];\n\n  if (alignX === 'left' && alignY === 'top') {\n    result[0] = 0;\n    result[1] = 0;\n  } else if (alignX === 'right' && alignY === 'top') {\n    result[0] = -width;\n    result[1] = 0;\n  } else if (alignX === 'left' && alignY === 'bottom') {\n    result[0] = 0;\n    result[1] = Math.floor(-height);\n  } else if (alignX === 'right' && alignY === 'bottom') {\n    result[0] = Math.floor(-width);\n    result[1] = Math.floor(-height);\n  } else if (alignX === 'right' && alignY === 'middle') {\n    result[0] = Math.floor(-width);\n    result[1] = Math.floor(-height / 2);\n  } else if (alignX === 'left' && alignY === 'middle') {\n    result[0] = 0;\n    result[1] = Math.floor(-height / 2);\n  } else if (alignX === 'center' && alignY === 'bottom') {\n    result[0] = Math.floor(-width / 2);\n    result[1] = Math.floor(-height);\n  } else if (alignX === 'center' && alignY === 'top') {\n    result[0] = Math.floor(-width / 2);\n    result[1] = 0;\n  } else {\n    result[0] = Math.floor(-width / 2);\n    result[1] = Math.floor(-height / 2);\n  }\n\n  return result;\n}\n\nfunction modifyCSS(DOM, CSS) {\n  for (var key in CSS) {\n    if (CSS.hasOwnProperty(key)) {\n      DOM.style[key] = CSS[key];\n    }\n  }\n\n  return DOM;\n}\n\nfunction createDom(str) {\n  var container = document.createElement('div');\n  str = str.replace(/(^\\s*)|(\\s*$)/g, '');\n  container.innerHTML = '' + str;\n  return container.childNodes[0];\n}\n\nvar Html =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Html, _GuideBase);\n\n  function Html() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Html.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'html';\n    /**\n     * dom position\n     * @type {Object | Array}\n     */\n\n    this.position = null;\n    /**\n      * alignment for horizontal direction，can be 'left','center','right'\n      * @type {String}\n      */\n\n    this.alignX = 'center';\n    /**\n      * alignment for vertical direction，can be 'top', 'middle', 'bottom'\n      * @type {String}\n      */\n\n    this.alignY = 'middle';\n    /**\n      * offset for horizontal direction\n      * @type {Number}\n      */\n\n    this.offsetX = null;\n    /**\n      * offset for vertical direction\n      * @type {Number}\n      */\n\n    this.offsetY = null;\n    /**\n    * the html string\n    *@type {String | Function}\n    */\n\n    this.html = null;\n  } // override paint\n  ;\n\n  _proto.render = function render(coord, container) {\n    var self = this;\n    var position = self.parsePoint(coord, self.position);\n\n    if (!position) {\n      return;\n    }\n\n    var myNode = createDom(self.html);\n    myNode = modifyCSS(myNode, {\n      position: 'absolute',\n      top: Math.floor(position.y) + 'px',\n      left: Math.floor(position.x) + 'px',\n      visibility: 'hidden'\n    });\n    var canvasDom = container.get('canvas').get('el');\n    var parentNode = canvasDom.parentNode;\n    parentNode = modifyCSS(parentNode, {\n      position: 'relative'\n    });\n    var wrapperNode = createDom('<div class=\"guideWapper\" style=\"position: absolute;top: 0; left: 0;\"></div>');\n    parentNode.appendChild(wrapperNode);\n    wrapperNode.appendChild(myNode);\n    var canvasOffsetTop = canvasDom.offsetTop;\n    var canvasOffsetLeft = canvasDom.offsetLeft;\n    var alignX = self.alignX,\n        alignY = self.alignY,\n        offsetX = self.offsetX,\n        offsetY = self.offsetY;\n    var width = Util.getWidth(myNode);\n    var height = Util.getHeight(myNode);\n    var newOffset = getOffsetFromAlign(alignX, alignY, width, height);\n    position.x = position.x + newOffset[0] + canvasOffsetLeft;\n    position.y = position.y + newOffset[1] + canvasOffsetTop;\n\n    if (offsetX) {\n      position.x += offsetX;\n    }\n\n    if (offsetY) {\n      position.y += offsetY;\n    }\n\n    modifyCSS(myNode, {\n      top: Math.floor(position.y) + 'px',\n      left: Math.floor(position.x) + 'px',\n      visibility: 'visible'\n    });\n    self.element = wrapperNode;\n  };\n\n  _proto.remove = function remove() {\n    var element = this.element;\n    element && element.parentNode && element.parentNode.removeChild(element);\n  };\n\n  return Html;\n}(GuideBase);\n\nGuideBase.Html = Html;\nmodule.exports = Html;\n\n/***/ }),\n/* 121 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Line =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Line, _GuideBase);\n\n  function Line() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Line.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'line';\n    this.start = [];\n    this.end = [];\n    this.style = {\n      stroke: '#000',\n      lineWidth: 1\n    };\n  };\n\n  _proto.render = function render(coord, container) {\n    var points = [];\n    points[0] = this.parsePoint(coord, this.start);\n    points[1] = this.parsePoint(coord, this.end);\n\n    if (!points[0] || !points[1]) {\n      return;\n    }\n\n    var shape = container.addShape('Line', {\n      className: 'guide-line',\n      attrs: Util.mix({\n        x1: points[0].x,\n        y1: points[0].y,\n        x2: points[1].x,\n        y2: points[1].y\n      }, this.style)\n    });\n    this.element = shape;\n    return shape;\n  };\n\n  return Line;\n}(GuideBase);\n\nGuideBase.Line = Line;\nmodule.exports = Line;\n\n/***/ }),\n/* 122 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Rect =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Rect, _GuideBase);\n\n  function Rect() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Rect.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'rect';\n    this.start = [];\n    this.end = [];\n    this.style = {\n      fill: '#CCD7EB',\n      opacity: 0.4\n    };\n  };\n\n  _proto.render = function render(coord, container) {\n    var start = this.parsePoint(coord, this.start);\n    var end = this.parsePoint(coord, this.end);\n\n    if (!start || !end) {\n      return;\n    }\n\n    var shape = container.addShape('rect', {\n      className: 'guide-rect',\n      attrs: Util.mix({\n        x: Math.min(start.x, end.x),\n        y: Math.min(start.y, end.y),\n        width: Math.abs(end.x - start.x),\n        height: Math.abs(start.y - end.y)\n      }, this.style)\n    });\n    this.element = shape;\n    return shape;\n  };\n\n  return Rect;\n}(GuideBase);\n\nGuideBase.Rect = Rect;\nmodule.exports = Rect;\n\n/***/ }),\n/* 123 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Text =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Text, _GuideBase);\n\n  function Text() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Text.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'text';\n    /**\n     * the position of text\n     * @type {Function | Array}\n     */\n\n    this.position = null;\n    /**\n     * the display content\n     * @type {String}\n     */\n\n    this.content = null;\n    /**\n     * style configuration for text\n     * @type {Object}\n     */\n\n    this.style = {\n      fill: '#000'\n    };\n    /**\n     * offset of horizontal direction\n     * @type {Number}\n     */\n\n    this.offsetX = 0;\n    /**\n     * offset of vertical direction\n     * @type {Number}\n     */\n\n    this.offsetY = 0;\n  };\n\n  _proto.render = function render(coord, container) {\n    var position = this.position;\n    var point = this.parsePoint(coord, position);\n\n    if (!point) {\n      return;\n    }\n\n    var content = this.content,\n        style = this.style,\n        offsetX = this.offsetX,\n        offsetY = this.offsetY;\n\n    if (offsetX) {\n      point.x += offsetX;\n    }\n\n    if (offsetY) {\n      point.y += offsetY;\n    }\n\n    var shape = container.addShape('text', {\n      className: 'guide-text',\n      attrs: Util.mix({\n        x: point.x,\n        y: point.y,\n        text: content\n      }, style)\n    });\n    this.element = shape;\n    return shape;\n  };\n\n  return Text;\n}(GuideBase);\n\nGuideBase.Text = Text;\nmodule.exports = Text;\n\n/***/ }),\n/* 124 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Tag =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Tag, _GuideBase);\n\n  function Tag() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Tag.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'tag';\n    this.position = null;\n    this.content = null;\n    this.direct = 'tl';\n    this.autoAdjust = true;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.side = 4;\n    this.background = {\n      padding: 5,\n      radius: 2,\n      fill: '#1890FF'\n    };\n    this.textStyle = {\n      fontSize: 12,\n      fill: '#fff',\n      textAlign: 'center',\n      textBaseline: 'middle'\n    };\n    this.withPoint = true;\n    this.pointStyle = {\n      fill: '#1890FF',\n      r: 3,\n      lineWidth: 1,\n      stroke: '#fff'\n    };\n  };\n\n  _proto._getDirect = function _getDirect(container, point, tagWidth, tagHeight) {\n    var direct = this.direct;\n    var side = this.side;\n    var canvas = container.get('canvas');\n    var clientWidth = canvas.get('width');\n    var clientHeight = canvas.get('height');\n    var x = point.x,\n        y = point.y;\n    var vertical = direct[0];\n    var horizontal = direct[1]; // adjust for vertical direction\n\n    if (vertical === 't' && y - side - tagHeight < 0) {\n      vertical = 'b';\n    } else if (vertical === 'b' && y + side + tagHeight > clientHeight) {\n      vertical = 't';\n    } // adjust for horizontal direction\n\n\n    var diff = vertical === 'c' ? side : 0;\n\n    if (horizontal === 'l' && x - diff - tagWidth < 0) {\n      horizontal = 'r';\n    } else if (horizontal === 'r' && x + diff + tagWidth > clientWidth) {\n      horizontal = 'l';\n    } else if (horizontal === 'c') {\n      if (tagWidth / 2 + x + diff > clientWidth) {\n        horizontal = 'l';\n      } else if (x - tagWidth / 2 - diff < 0) {\n        horizontal = 'r';\n      }\n    }\n\n    direct = vertical + horizontal;\n    return direct;\n  };\n\n  _proto.render = function render(coord, container) {\n    var position = this.parsePoint(coord, this.position);\n\n    if (!position) {\n      return;\n    }\n\n    var content = this.content,\n        background = this.background,\n        textStyle = this.textStyle;\n    var shapes = [];\n    var wrapperContainer = container.addGroup({\n      className: 'guide-tag'\n    });\n\n    if (this.withPoint) {\n      var pointShape = wrapperContainer.addShape('Circle', {\n        className: 'guide-tag-point',\n        attrs: Util.mix({\n          x: position.x,\n          y: position.y\n        }, this.pointStyle)\n      });\n      shapes.push(pointShape);\n    }\n\n    var tagContainer = wrapperContainer.addGroup(); // create a text shape\n\n    var tagText = tagContainer.addShape('text', {\n      className: 'guide-tag-text',\n      zIndex: 1,\n      attrs: Util.mix({\n        x: 0,\n        y: 0,\n        text: content\n      }, textStyle)\n    });\n    shapes.push(tagText); // create background box\n\n    var textBBox = tagText.getBBox();\n    var padding = Util.parsePadding(background.padding);\n    var tagWidth = textBBox.width + padding[1] + padding[3];\n    var tagHeight = textBBox.height + padding[0] + padding[2];\n    var yMin = textBBox.minY - padding[0];\n    var xMin = textBBox.minX - padding[3];\n    var tagBg = tagContainer.addShape('rect', {\n      className: 'guide-tag-bg',\n      zIndex: -1,\n      attrs: Util.mix({\n        x: xMin,\n        y: yMin,\n        width: tagWidth,\n        height: tagHeight\n      }, background)\n    });\n    shapes.push(tagBg);\n    var direct = this.autoAdjust ? this._getDirect(container, position, tagWidth, tagHeight) : this.direct;\n    var side = this.side;\n    var x = position.x + this.offsetX;\n    var y = position.y + this.offsetY;\n    var arrowPoints;\n    var radius = Util.parsePadding(background.radius);\n\n    if (direct === 'tl') {\n      arrowPoints = [{\n        x: tagWidth + xMin - side - 1,\n        y: tagHeight + yMin - 1\n      }, // 这个 1 是为了防止出现白边\n      {\n        x: tagWidth + xMin,\n        y: tagHeight + yMin - 1\n      }, {\n        x: tagWidth + xMin,\n        y: tagHeight + side + yMin\n      }];\n      radius[2] = 0;\n      x = x - tagWidth;\n      y = y - side - tagHeight;\n    } else if (direct === 'cl') {\n      arrowPoints = [{\n        x: tagWidth + xMin - 1,\n        y: (tagHeight - side) / 2 + yMin - 1\n      }, {\n        x: tagWidth + xMin - 1,\n        y: (tagHeight + side) / 2 + yMin + 1\n      }, {\n        x: tagWidth + side + xMin,\n        y: tagHeight / 2 + yMin\n      }];\n      x = x - tagWidth - side;\n      y = y - tagHeight / 2;\n    } else if (direct === 'bl') {\n      arrowPoints = [{\n        x: tagWidth + xMin,\n        y: -side + yMin\n      }, {\n        x: tagWidth + xMin - side - 1,\n        y: yMin + 1\n      }, {\n        x: tagWidth + xMin,\n        y: yMin + 1\n      }];\n      radius[1] = 0;\n      x = x - tagWidth;\n      y = y + side;\n    } else if (direct === 'bc') {\n      arrowPoints = [{\n        x: tagWidth / 2 + xMin,\n        y: -side + yMin\n      }, {\n        x: (tagWidth - side) / 2 + xMin - 1,\n        y: yMin + 1\n      }, {\n        x: (tagWidth + side) / 2 + xMin + 1,\n        y: yMin + 1\n      }];\n      x = x - tagWidth / 2;\n      y = y + side;\n    } else if (direct === 'br') {\n      arrowPoints = [{\n        x: xMin,\n        y: yMin - side\n      }, {\n        x: xMin,\n        y: yMin + 1\n      }, {\n        x: xMin + side + 1,\n        y: yMin + 1\n      }];\n      radius[0] = 0;\n      y = y + side;\n    } else if (direct === 'cr') {\n      arrowPoints = [{\n        x: xMin - side,\n        y: tagHeight / 2 + yMin\n      }, {\n        x: xMin + 1,\n        y: (tagHeight - side) / 2 + yMin - 1\n      }, {\n        x: xMin + 1,\n        y: (tagHeight + side) / 2 + yMin + 1\n      }];\n      x = x + side;\n      y = y - tagHeight / 2;\n    } else if (direct === 'tr') {\n      arrowPoints = [{\n        x: xMin,\n        y: tagHeight + side + yMin\n      }, {\n        x: xMin,\n        y: tagHeight + yMin - 1\n      }, {\n        x: side + xMin + 1,\n        y: tagHeight + yMin - 1\n      }];\n      radius[3] = 0;\n      y = y - tagHeight - side;\n    } else if (direct === 'tc') {\n      arrowPoints = [{\n        x: (tagWidth - side) / 2 + xMin - 1,\n        y: tagHeight + yMin - 1\n      }, {\n        x: (tagWidth + side) / 2 + xMin + 1,\n        y: tagHeight + yMin - 1\n      }, {\n        x: tagWidth / 2 + xMin,\n        y: tagHeight + side + yMin\n      }];\n      x = x - tagWidth / 2;\n      y = y - tagHeight - side;\n    }\n\n    var sideShape = tagContainer.addShape('Polygon', {\n      className: 'guide-tag-side',\n      zIndex: 0,\n      attrs: {\n        points: arrowPoints,\n        fill: background.fill\n      }\n    });\n    shapes.push(sideShape);\n    tagBg.attr('radius', radius);\n    tagContainer.moveTo(x - xMin, y - yMin);\n    tagContainer.sort();\n    this.element = wrapperContainer;\n    return shapes;\n  };\n\n  return Tag;\n}(GuideBase);\n\nGuideBase.Tag = Tag;\nmodule.exports = Tag;\n\n/***/ }),\n/* 125 */\n/***/ (function(module, exports, __webpack_require__) {\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nvar Util = __webpack_require__(0);\n\nvar GuideBase = __webpack_require__(11);\n\nvar Point =\n/*#__PURE__*/\nfunction (_GuideBase) {\n  _inheritsLoose(Point, _GuideBase);\n\n  function Point() {\n    return _GuideBase.apply(this, arguments) || this;\n  }\n\n  var _proto = Point.prototype;\n\n  _proto._initDefaultCfg = function _initDefaultCfg() {\n    this.type = 'point';\n    this.position = null;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.style = {\n      fill: '#1890FF',\n      r: 3,\n      lineWidth: 1,\n      stroke: '#fff'\n    };\n  };\n\n  _proto.render = function render(coord, container) {\n    var position = this.parsePoint(coord, this.position);\n    if (!position) return null;\n    var shape = container.addShape('Circle', {\n      className: 'guide-point',\n      attrs: Util.mix({\n        x: position.x + this.offsetX,\n        y: position.y + this.offsetY\n      }, this.style)\n    });\n    this.element = shape;\n    return shape;\n  };\n\n  return Point;\n}(GuideBase);\n\nGuideBase.Point = Point;\nmodule.exports = Point;\n\n/***/ }),\n/* 126 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Global = __webpack_require__(1);\n\nvar Tooltip = __webpack_require__(127);\n\nvar Helper = __webpack_require__(28); // Register the default configuration for Tooltip\n\n\nGlobal.tooltip = Util.deepMix({\n  triggerOn: ['touchstart', 'touchmove'],\n  // triggerOff: 'touchend',\n  alwaysShow: false,\n  showTitle: false,\n  showCrosshairs: false,\n  crosshairsStyle: {\n    stroke: 'rgba(0, 0, 0, 0.25)',\n    lineWidth: 1\n  },\n  showTooltipMarker: true,\n  background: {\n    radius: 1,\n    fill: 'rgba(0, 0, 0, 0.65)',\n    padding: [3, 5]\n  },\n  titleStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fontSize: 12,\n    fill: 'rgba(255, 255, 255, 0.65)',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fontSize: 12,\n    fill: '#fff',\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  showItemMarker: true,\n  itemMarkerStyle: {\n    radius: 3,\n    symbol: 'circle',\n    lineWidth: 1,\n    stroke: '#fff'\n  },\n  layout: 'horizontal',\n  snap: false\n}, Global.tooltip || {});\n\nfunction _getTooltipValueScale(geom) {\n  var colorAttr = geom.getAttr('color');\n\n  if (colorAttr) {\n    var colorScale = colorAttr.getScale(colorAttr.type);\n\n    if (colorScale.isLinear) {\n      return colorScale;\n    }\n  }\n\n  var xScale = geom.getXScale();\n  var yScale = geom.getYScale();\n\n  if (yScale) {\n    return yScale;\n  }\n\n  return xScale;\n}\n\nfunction getTooltipName(geom, origin) {\n  var name;\n  var nameScale;\n\n  var groupScales = geom._getGroupScales();\n\n  if (groupScales.length) {\n    Util.each(groupScales, function (scale) {\n      nameScale = scale;\n      return false;\n    });\n  }\n\n  if (nameScale) {\n    var field = nameScale.field;\n    name = nameScale.getText(origin[field]);\n  } else {\n    var valueScale = _getTooltipValueScale(geom);\n\n    name = valueScale.alias || valueScale.field;\n  }\n\n  return name;\n}\n\nfunction getTooltipValue(geom, origin) {\n  var scale = _getTooltipValueScale(geom);\n\n  return scale.getText(origin[scale.field]);\n}\n\nfunction getTooltipTitle(geom, origin) {\n  var position = geom.getAttr('position');\n  var field = position.getFields()[0];\n  var scale = geom.get('scales')[field];\n  return scale.getText(origin[scale.field]);\n}\n\nfunction _indexOfArray(items, item) {\n  var rst = -1;\n  Util.each(items, function (sub, index) {\n    if (sub.title === item.title && sub.name === item.name && sub.value === item.value && sub.color === item.color) {\n      rst = index;\n      return false;\n    }\n  });\n  return rst;\n}\n\nfunction _uniqItems(items) {\n  var tmp = [];\n  Util.each(items, function (item) {\n    var index = _indexOfArray(tmp, item);\n\n    if (index === -1) {\n      tmp.push(item);\n    } else {\n      tmp[index] = item;\n    }\n  });\n  return tmp;\n}\n\nfunction isEqual(arr1, arr2) {\n  return JSON.stringify(arr1) === JSON.stringify(arr2);\n}\n\nvar TooltipController =\n/*#__PURE__*/\nfunction () {\n  function TooltipController(cfg) {\n    this.enable = true;\n    this.cfg = {};\n    this.tooltip = null;\n    this.chart = null;\n    this.timeStamp = 0;\n    Util.mix(this, cfg);\n    var chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n  }\n\n  var _proto = TooltipController.prototype;\n\n  _proto._setCrosshairsCfg = function _setCrosshairsCfg() {\n    var self = this;\n    var chart = self.chart;\n    var defaultCfg = Util.mix({}, Global.tooltip);\n    var geoms = chart.get('geoms');\n    var shapes = [];\n    Util.each(geoms, function (geom) {\n      var type = geom.get('type');\n\n      if (shapes.indexOf(type) === -1) {\n        shapes.push(type);\n      }\n    });\n    var coordType = chart.get('coord').type;\n\n    if (geoms.length && (coordType === 'cartesian' || coordType === 'rect')) {\n      if (shapes.length === 1 && ['line', 'area', 'path', 'point'].indexOf(shapes[0]) !== -1) {\n        Util.mix(defaultCfg, {\n          showCrosshairs: true\n        });\n      }\n    }\n\n    return defaultCfg;\n  };\n\n  _proto._getMaxLength = function _getMaxLength(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var _cfg = cfg,\n        layout = _cfg.layout,\n        plotRange = _cfg.plotRange;\n    return layout === 'horizontal' ? plotRange.br.x - plotRange.bl.x : plotRange.bl.y - plotRange.tr.y;\n  };\n\n  _proto.render = function render() {\n    var self = this;\n\n    if (self.tooltip) {\n      return;\n    }\n\n    var chart = self.chart;\n    var canvas = chart.get('canvas');\n    var frontPlot = chart.get('frontPlot').addGroup({\n      className: 'tooltipContainer',\n      zIndex: 10\n    });\n    var backPlot = chart.get('backPlot').addGroup({\n      className: 'tooltipContainer'\n    });\n    var plotRange = chart.get('plotRange');\n    var coord = chart.get('coord');\n\n    var defaultCfg = self._setCrosshairsCfg();\n\n    var cfg = self.cfg; // 通过 chart.tooltip() 接口传入的 tooltip 配置项\n\n    var tooltipCfg = Util.deepMix({\n      plotRange: plotRange,\n      frontPlot: frontPlot,\n      backPlot: backPlot,\n      canvas: canvas,\n      fixed: coord.transposed || coord.isPolar\n    }, defaultCfg, cfg); // 创建 tooltip 实例需要的配置，不应该修改 this.cfg，即用户传入的配置\n\n    tooltipCfg.maxLength = self._getMaxLength(tooltipCfg);\n    this._tooltipCfg = tooltipCfg;\n    var tooltip = new Tooltip(tooltipCfg);\n    self.tooltip = tooltip;\n    self.bindEvents();\n  };\n\n  _proto.clear = function clear() {\n    var tooltip = this.tooltip;\n    tooltip && tooltip.destroy();\n    this.tooltip = null;\n    this.prePoint = null;\n    this._lastActive = null;\n    this.unBindEvents();\n  };\n\n  _proto._getTooltipMarkerStyle = function _getTooltipMarkerStyle(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var _cfg2 = cfg,\n        type = _cfg2.type,\n        items = _cfg2.items;\n    var tooltipCfg = this._tooltipCfg;\n\n    if (type === 'rect') {\n      var x;\n      var y;\n      var width;\n      var height;\n      var chart = this.chart;\n\n      var _chart$get = chart.get('plotRange'),\n          tl = _chart$get.tl,\n          br = _chart$get.br;\n\n      var coord = chart.get('coord');\n      var firstItem = items[0];\n      var lastItem = items[items.length - 1];\n      var intervalWidth = firstItem.width;\n\n      if (coord.transposed) {\n        x = tl.x;\n        y = lastItem.y - intervalWidth * 0.75;\n        width = br.x - tl.x;\n        height = firstItem.y - lastItem.y + 1.5 * intervalWidth;\n      } else {\n        x = firstItem.x - intervalWidth * 0.75;\n        y = tl.y;\n        width = lastItem.x - firstItem.x + 1.5 * intervalWidth;\n        height = br.y - tl.y;\n      }\n\n      cfg.style = Util.mix({\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        fill: '#CCD6EC',\n        opacity: 0.3\n      }, tooltipCfg.tooltipMarkerStyle);\n    } else {\n      cfg.style = Util.mix({\n        radius: 4,\n        fill: '#fff',\n        lineWidth: 2\n      }, tooltipCfg.tooltipMarkerStyle);\n    }\n\n    return cfg;\n  };\n\n  _proto._setTooltip = function _setTooltip(point, items, tooltipMarkerCfg) {\n    if (tooltipMarkerCfg === void 0) {\n      tooltipMarkerCfg = {};\n    }\n\n    var lastActive = this._lastActive;\n    var tooltip = this.tooltip;\n    var cfg = this._tooltipCfg;\n    items = _uniqItems(items);\n    var chart = this.chart;\n    var coord = chart.get('coord');\n    var yScale = chart.getYScales()[0];\n    var snap = cfg.snap;\n\n    if (snap === false && yScale.isLinear) {\n      var invertPoint = coord.invertPoint(point);\n      var plot = chart.get('plotRange');\n      var tip;\n      var pos;\n\n      if (Helper.isPointInPlot(point, plot)) {\n        if (coord.transposed) {\n          tip = yScale.invert(invertPoint.x);\n          pos = point.x;\n          tooltip.setXTipContent(tip);\n          tooltip.setXTipPosition(pos);\n          tooltip.setYCrosshairPosition(pos);\n        } else {\n          tip = yScale.invert(invertPoint.y);\n          pos = point.y;\n          tooltip.setYTipContent(tip);\n          tooltip.setYTipPosition(pos);\n          tooltip.setXCrosshairPosition(pos);\n        }\n      }\n    }\n\n    if (cfg.onShow) {\n      cfg.onShow({\n        x: point.x,\n        y: point.y,\n        tooltip: tooltip,\n        items: items,\n        tooltipMarkerCfg: tooltipMarkerCfg\n      });\n    }\n\n    if (isEqual(lastActive, items)) {\n      if (snap === false && (Util.directionEnabled(cfg.crosshairsType, 'y') || cfg.showYTip)) {\n        var canvas = this.chart.get('canvas');\n        canvas.draw();\n      }\n\n      return;\n    }\n\n    this._lastActive = items;\n    var onChange = cfg.onChange;\n\n    if (onChange) {\n      onChange({\n        x: point.x,\n        y: point.y,\n        tooltip: tooltip,\n        items: items,\n        tooltipMarkerCfg: tooltipMarkerCfg\n      });\n    }\n\n    var first = items[0];\n    var title = first.title || first.name;\n    var xTipPosX = first.x;\n\n    if (items.length > 1) {\n      xTipPosX = (items[0].x + items[items.length - 1].x) / 2;\n    }\n\n    tooltip.setContent(title, items, coord.transposed);\n    tooltip.setPosition(items, point);\n\n    if (coord.transposed) {\n      var yTipPosY = first.y;\n\n      if (items.length > 1) {\n        yTipPosY = (items[0].y + items[items.length - 1].y) / 2;\n      }\n\n      tooltip.setYTipContent(title);\n      tooltip.setYTipPosition(yTipPosY);\n      tooltip.setXCrosshairPosition(yTipPosY);\n\n      if (snap) {\n        tooltip.setXTipContent(first.value);\n        tooltip.setXTipPosition(xTipPosX);\n        tooltip.setYCrosshairPosition(xTipPosX);\n      }\n    } else {\n      tooltip.setXTipContent(title);\n      tooltip.setXTipPosition(xTipPosX);\n      tooltip.setYCrosshairPosition(xTipPosX);\n\n      if (snap) {\n        tooltip.setYTipContent(first.value);\n        tooltip.setYTipPosition(first.y);\n        tooltip.setXCrosshairPosition(first.y);\n      }\n    }\n\n    var markerItems = tooltipMarkerCfg.items;\n\n    if (cfg.showTooltipMarker && markerItems.length) {\n      tooltipMarkerCfg = this._getTooltipMarkerStyle(tooltipMarkerCfg);\n      tooltip.setMarkers(tooltipMarkerCfg);\n    } else {\n      tooltip.clearMarkers();\n    }\n\n    tooltip.show();\n  };\n\n  _proto.showTooltip = function showTooltip(point) {\n    var self = this;\n    var chart = self.chart;\n    var tooltipMarkerType;\n    var tooltipMarkerItems = [];\n    var items = [];\n    var cfg = self._tooltipCfg;\n    var marker;\n\n    if (cfg.showItemMarker) {\n      marker = cfg.itemMarkerStyle;\n    }\n\n    var geoms = chart.get('geoms');\n    var coord = chart.get('coord');\n    Util.each(geoms, function (geom) {\n      if (geom.get('visible')) {\n        var type = geom.get('type');\n        var records = geom.getSnapRecords(point);\n        Util.each(records, function (record) {\n          if (record.x && record.y) {\n            var x = record.x,\n                y = record.y,\n                _origin = record._origin,\n                color = record.color;\n            var tooltipItem = {\n              x: x,\n              y: Util.isArray(y) ? y[1] : y,\n              color: color || Global.defaultColor,\n              origin: _origin,\n              name: getTooltipName(geom, _origin),\n              value: getTooltipValue(geom, _origin),\n              title: getTooltipTitle(geom, _origin)\n            };\n\n            if (marker) {\n              tooltipItem.marker = Util.mix({\n                fill: color || Global.defaultColor\n              }, marker);\n            }\n\n            items.push(tooltipItem);\n\n            if (['line', 'area', 'path'].indexOf(type) !== -1) {\n              tooltipMarkerType = 'circle';\n              tooltipMarkerItems.push(tooltipItem);\n            } else if (type === 'interval' && (coord.type === 'cartesian' || coord.type === 'rect')) {\n              tooltipMarkerType = 'rect';\n              tooltipItem.width = geom.getSize(record._origin);\n              tooltipMarkerItems.push(tooltipItem);\n            }\n          }\n        });\n      }\n    });\n\n    if (items.length) {\n      var tooltipMarkerCfg = {\n        items: tooltipMarkerItems,\n        type: tooltipMarkerType\n      };\n\n      self._setTooltip(point, items, tooltipMarkerCfg);\n    } else {\n      self.hideTooltip();\n    }\n  };\n\n  _proto.hideTooltip = function hideTooltip() {\n    var cfg = this._tooltipCfg;\n    this._lastActive = null;\n    var tooltip = this.tooltip;\n\n    if (tooltip) {\n      tooltip.hide();\n\n      if (cfg.onHide) {\n        cfg.onHide({\n          tooltip: tooltip\n        });\n      }\n\n      var canvas = this.chart.get('canvas');\n      canvas.draw();\n    }\n  };\n\n  _proto.handleShowEvent = function handleShowEvent(ev) {\n    var chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n    var plot = chart.get('plotRange');\n    var point = Util.createEvent(ev, chart);\n\n    if (!Helper.isPointInPlot(point, plot) && !this._tooltipCfg.alwaysShow) {\n      // not in chart plot\n      this.hideTooltip();\n      return;\n    }\n\n    var lastTimeStamp = this.timeStamp;\n    var timeStamp = +new Date();\n\n    if (timeStamp - lastTimeStamp > 16) {\n      this.showTooltip(point);\n      this.timeStamp = timeStamp;\n    }\n  };\n\n  _proto.handleHideEvent = function handleHideEvent() {\n    var chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n    this.hideTooltip();\n  };\n\n  _proto.handleDocEvent = function handleDocEvent(ev) {\n    var chart = this.chart;\n    if (!this.enable || chart.get('_closeTooltip')) return;\n    var canvasDom = this.canvasDom;\n\n    if (ev.target !== canvasDom) {\n      this.hideTooltip();\n    }\n  };\n\n  _proto._handleEvent = function _handleEvent(methodName, method, action) {\n    var canvasDom = this.canvasDom;\n    Util.each([].concat(methodName), function (aMethod) {\n      if (action === 'bind') {\n        Util.addEventListener(canvasDom, aMethod, method);\n      } else {\n        Util.removeEventListener(canvasDom, aMethod, method);\n      }\n    });\n  };\n\n  _proto.bindEvents = function bindEvents() {\n    var cfg = this._tooltipCfg;\n    var triggerOn = cfg.triggerOn,\n        triggerOff = cfg.triggerOff,\n        alwaysShow = cfg.alwaysShow;\n    var showMethod = Util.wrapBehavior(this, 'handleShowEvent');\n    var hideMethod = Util.wrapBehavior(this, 'handleHideEvent');\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'bind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'bind'); // TODO: 当用户点击 canvas 外的事件时 tooltip 消失\n\n    if (!alwaysShow) {\n      var docMethod = Util.wrapBehavior(this, 'handleDocEvent');\n      Util.isBrowser && Util.addEventListener(document, 'touchstart', docMethod);\n    }\n  };\n\n  _proto.unBindEvents = function unBindEvents() {\n    var cfg = this._tooltipCfg;\n    var triggerOn = cfg.triggerOn,\n        triggerOff = cfg.triggerOff,\n        alwaysShow = cfg.alwaysShow;\n    var showMethod = Util.getWrapBehavior(this, 'handleShowEvent');\n    var hideMethod = Util.getWrapBehavior(this, 'handleHideEvent');\n    triggerOn && this._handleEvent(triggerOn, showMethod, 'unBind');\n    triggerOff && this._handleEvent(triggerOff, hideMethod, 'unBind');\n\n    if (!alwaysShow) {\n      var docMethod = Util.getWrapBehavior(this, 'handleDocEvent');\n      Util.isBrowser && Util.removeEventListener(document, 'touchstart', docMethod);\n    }\n  };\n\n  return TooltipController;\n}();\n\nmodule.exports = {\n  init: function init(chart) {\n    var tooltipController = new TooltipController({\n      chart: chart\n    });\n    chart.set('tooltipController', tooltipController);\n\n    chart.tooltip = function (enable, cfg) {\n      if (Util.isObject(enable)) {\n        cfg = enable;\n        enable = true;\n      }\n\n      tooltipController.enable = enable;\n\n      if (cfg) {\n        tooltipController.cfg = cfg;\n      }\n\n      return this;\n    };\n  },\n  afterGeomDraw: function afterGeomDraw(chart) {\n    var tooltipController = chart.get('tooltipController');\n    tooltipController.render();\n\n    chart.showTooltip = function (point) {\n      tooltipController.showTooltip(point);\n      return this;\n    };\n\n    chart.hideTooltip = function () {\n      tooltipController.hideTooltip();\n      return this;\n    };\n  },\n  clearInner: function clearInner(chart) {\n    var tooltipController = chart.get('tooltipController');\n    tooltipController.clear();\n  }\n};\n\n/***/ }),\n/* 127 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Marker = __webpack_require__(100);\n\nvar Container = __webpack_require__(101);\n\nvar TextBox = __webpack_require__(128);\n\nvar GAP = 4;\n/**\n * TODOList：\n * 1. 移除 fixed 参数\n */\n\nvar Tooltip =\n/*#__PURE__*/\nfunction () {\n  var _proto = Tooltip.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      /**\n       * wether show the crosshairs\n       * @type {Object}\n       */\n      showCrosshairs: false,\n\n      /**\n       * the style for crosshairs\n       * @type {Object}\n       */\n      crosshairsStyle: {\n        stroke: 'rgba(0, 0, 0, 0.25)',\n        lineWidth: 1\n      },\n\n      /**\n       * the type of crosshairs, optional value is 'x', 'y' or 'xy', default is 'y'\n       */\n      crosshairsType: 'y',\n\n      /**\n       * show or hide the x axis tip\n       */\n      showXTip: false,\n\n      /**\n       * show or hide the y axis tip\n       */\n      showYTip: false,\n      xTip: null,\n      xTipBackground: {\n        radius: 1,\n        fill: 'rgba(0, 0, 0, 0.65)',\n        padding: [3, 5]\n      },\n      yTip: null,\n      yTipBackground: {\n        radius: 1,\n        fill: 'rgba(0, 0, 0, 0.65)',\n        padding: [3, 5]\n      },\n\n      /**\n       * the style for tooltip container's background\n       * @type {Object}\n       */\n      background: null,\n\n      /**\n       * layout, can be horizontal or vertical\n       * @type {String}\n       */\n      layout: 'horizontal',\n      offsetX: 0,\n      offsetY: 0\n    };\n  };\n\n  function Tooltip(cfg) {\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\n    var frontPlot = this.frontPlot,\n        custom = this.custom;\n\n    if (!custom) {\n      // custom means user do customize\n      var container = new Container(Util.mix({\n        parent: frontPlot,\n        zIndex: 3\n      }, cfg));\n      this.container = container;\n      var fixed = this.fixed,\n          background = this.background;\n\n      if (!fixed) {\n        this.tooltipArrow = frontPlot.addShape('Polygon', {\n          className: 'tooltip-arrow',\n          visible: false,\n          zIndex: 2,\n          attrs: Util.mix({\n            points: []\n          }, background)\n        });\n      }\n    }\n\n    if (this.showXTip) {\n      var xTipBackground = this.xTipBackground;\n      var xTipBox = new TextBox({\n        className: 'xTip',\n        background: xTipBackground,\n        visible: false\n      });\n      frontPlot.add(xTipBox.container);\n      this.xTipBox = xTipBox;\n    }\n\n    if (this.showYTip) {\n      var yTipBackground = this.yTipBackground;\n      var yTipBox = new TextBox({\n        className: 'yTip',\n        background: yTipBackground,\n        visible: false\n      });\n      frontPlot.add(yTipBox.container);\n      this.yTipBox = yTipBox;\n    }\n\n    if (this.showCrosshairs) {\n      this._renderCrosshairs();\n    }\n\n    frontPlot.sort();\n  }\n\n  _proto.setContent = function setContent(title, items) {\n    this.title = title;\n    this.items = items;\n\n    if (!this.custom) {\n      var container = this.container;\n      container.setTitle(title);\n      container.setItems(items);\n    }\n  };\n\n  _proto.setYTipContent = function setYTipContent(val) {\n    var yTip = this.yTip;\n\n    if (Util.isFunction(yTip)) {\n      val = yTip(val);\n    } else {\n      val = Util.mix({\n        text: val\n      }, yTip);\n    }\n\n    this.yTipBox && this.yTipBox.updateContent(val);\n  };\n\n  _proto.setYTipPosition = function setYTipPosition(pos) {\n    var plotRange = this.plotRange;\n    var crosshairsShapeX = this.crosshairsShapeX;\n\n    if (this.showYTip) {\n      var yTipBox = this.yTipBox;\n      var yTipHeight = yTipBox.getHeight();\n      var yTipWidth = yTipBox.getWidth();\n      var posX = plotRange.tl.x - yTipWidth;\n      var posY = pos - yTipHeight / 2;\n\n      if (posY <= plotRange.tl.y) {\n        posY = plotRange.tl.y;\n      }\n\n      if (posY + yTipHeight >= plotRange.br.y) {\n        posY = plotRange.br.y - yTipHeight;\n      }\n\n      if (posX < 0) {\n        posX = plotRange.tl.x;\n        crosshairsShapeX && crosshairsShapeX.attr('x1', plotRange.tl.x + yTipWidth);\n      }\n\n      yTipBox.updatePosition(posX, posY);\n    }\n  };\n\n  _proto.setXTipContent = function setXTipContent(val) {\n    var xTip = this.xTip;\n\n    if (Util.isFunction(xTip)) {\n      val = xTip(val);\n    } else {\n      val = Util.mix({\n        text: val\n      }, xTip);\n    }\n\n    this.xTipBox && this.xTipBox.updateContent(val);\n  };\n\n  _proto.setXTipPosition = function setXTipPosition(pos) {\n    var showXTip = this.showXTip,\n        canvas = this.canvas,\n        plotRange = this.plotRange,\n        xTipBox = this.xTipBox,\n        crosshairsShapeY = this.crosshairsShapeY;\n\n    if (showXTip) {\n      // const el = canvas.get('el');\n      // const canvasHeight = Util.getHeight(el);\n      var canvasHeight = canvas.get('height');\n      var xTipWidth = xTipBox.getWidth();\n      var xTipHeight = xTipBox.getHeight();\n      var posX = pos - xTipWidth / 2;\n      var posY = plotRange.br.y;\n\n      if (posX <= plotRange.tl.x) {\n        posX = plotRange.tl.x;\n      }\n\n      if (posX + xTipWidth >= plotRange.tr.x) {\n        posX = plotRange.tr.x - xTipWidth;\n      }\n\n      if (canvasHeight - posY < xTipHeight) {\n        posY -= xTipHeight;\n      }\n\n      xTipBox.updatePosition(posX, posY);\n      crosshairsShapeY && crosshairsShapeY.attr('y1', posY);\n    }\n  };\n\n  _proto.setXCrosshairPosition = function setXCrosshairPosition(pos) {\n    this.crosshairsShapeX && this.crosshairsShapeX.moveTo(0, pos);\n  };\n\n  _proto.setYCrosshairPosition = function setYCrosshairPosition(pos) {\n    this.crosshairsShapeY && this.crosshairsShapeY.moveTo(pos, 0);\n  };\n\n  _proto.setPosition = function setPosition(items) {\n    var container = this.container,\n        plotRange = this.plotRange,\n        offsetX = this.offsetX,\n        offsetY = this.offsetY,\n        fixed = this.fixed,\n        tooltipArrow = this.tooltipArrow;\n\n    if (!container) {\n      return;\n    }\n\n    var containerBBox = container.container.getBBox();\n    var minX = containerBBox.minX,\n        minY = containerBBox.minY,\n        width = containerBBox.width,\n        height = containerBBox.height;\n    var tl = plotRange.tl,\n        tr = plotRange.tr;\n    var posX = 0;\n    var posY = tl.y - height - GAP + offsetY;\n\n    if (fixed) {\n      var x = (tl.x + tr.x) / 2;\n      posX = x - width / 2 + offsetX;\n    } else {\n      var _x;\n\n      if (items.length > 1) {\n        _x = (items[0].x + items[items.length - 1].x) / 2;\n      } else {\n        _x = items[0].x;\n      }\n\n      posX = _x - width / 2 + offsetX;\n\n      if (posX < tl.x) {\n        posX = tl.x;\n      }\n\n      if (posX + width > tr.x) {\n        posX = tr.x - width;\n      }\n\n      if (tooltipArrow) {\n        tooltipArrow.attr('points', [{\n          x: _x - 3,\n          y: tl.y - GAP + offsetY\n        }, {\n          x: _x + 3,\n          y: tl.y - GAP + offsetY\n        }, {\n          x: _x,\n          y: tl.y + offsetY\n        }]);\n        var backShape = container.backShape;\n        var radius = Util.parsePadding(backShape.attr('radius'));\n\n        if (_x === tl.x) {\n          radius[3] = 0;\n          tooltipArrow.attr('points', [{\n            x: tl.x,\n            y: tl.y + offsetY\n          }, {\n            x: tl.x,\n            y: tl.y - GAP + offsetY\n          }, {\n            x: tl.x + GAP,\n            y: tl.y - GAP + offsetY\n          }]);\n        } else if (_x === tr.x) {\n          radius[2] = 0;\n          tooltipArrow.attr('points', [{\n            x: tr.x,\n            y: tl.y + offsetY\n          }, {\n            x: tr.x - GAP,\n            y: tl.y - GAP + offsetY\n          }, {\n            x: tr.x,\n            y: tl.y - GAP + offsetY\n          }]);\n        }\n\n        backShape.attr('radius', radius);\n      }\n    }\n\n    container.moveTo(posX - minX, posY - minY);\n  };\n\n  _proto.setMarkers = function setMarkers(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var self = this;\n    var _cfg = cfg,\n        items = _cfg.items,\n        style = _cfg.style,\n        type = _cfg.type;\n\n    var markerGroup = self._getMarkerGroup(type);\n\n    if (type === 'circle') {\n      for (var i = 0, length = items.length; i < length; i++) {\n        var item = items[i];\n        var marker = new Marker({\n          className: 'tooltip-circle-marker',\n          attrs: Util.mix({\n            x: item.x,\n            y: item.y,\n            stroke: item.color\n          }, style)\n        });\n        markerGroup.add(marker);\n      }\n    } else {\n      markerGroup.addShape('rect', {\n        className: 'tooltip-rect-marker',\n        attrs: style\n      });\n    }\n  };\n\n  _proto.clearMarkers = function clearMarkers() {\n    var markerGroup = this.markerGroup;\n    markerGroup && markerGroup.clear();\n  };\n\n  _proto.show = function show() {\n    var crosshairsShapeX = this.crosshairsShapeX;\n    var crosshairsShapeY = this.crosshairsShapeY;\n    var markerGroup = this.markerGroup;\n    var container = this.container;\n    var tooltipArrow = this.tooltipArrow;\n    var xTipBox = this.xTipBox;\n    var yTipBox = this.yTipBox;\n    var canvas = this.canvas;\n    crosshairsShapeX && crosshairsShapeX.show();\n    crosshairsShapeY && crosshairsShapeY.show();\n    markerGroup && markerGroup.show();\n    container && container.show();\n    tooltipArrow && tooltipArrow.show();\n    xTipBox && xTipBox.show();\n    yTipBox && yTipBox.show();\n    canvas.draw();\n  };\n\n  _proto.hide = function hide() {\n    var crosshairsShapeX = this.crosshairsShapeX;\n    var crosshairsShapeY = this.crosshairsShapeY;\n    var markerGroup = this.markerGroup;\n    var container = this.container;\n    var tooltipArrow = this.tooltipArrow;\n    var xTipBox = this.xTipBox;\n    var yTipBox = this.yTipBox;\n    crosshairsShapeX && crosshairsShapeX.hide();\n    crosshairsShapeY && crosshairsShapeY.hide();\n    markerGroup && markerGroup.hide();\n    container && container.hide();\n    tooltipArrow && tooltipArrow.hide();\n    xTipBox && xTipBox.hide();\n    yTipBox && yTipBox.hide();\n  };\n\n  _proto.destroy = function destroy() {\n    var crosshairsShapeX = this.crosshairsShapeX;\n    var crosshairsShapeY = this.crosshairsShapeY;\n    var markerGroup = this.markerGroup;\n    var container = this.container;\n    var tooltipArrow = this.tooltipArrow;\n    var xTipBox = this.xTipBox;\n    var yTipBox = this.yTipBox;\n    crosshairsShapeX && crosshairsShapeX.remove(true);\n    crosshairsShapeY && crosshairsShapeY.remove(true);\n    markerGroup && markerGroup.remove(true);\n    tooltipArrow && tooltipArrow.remove(true);\n    container && container.clear();\n    xTipBox && xTipBox.clear();\n    yTipBox && yTipBox.clear();\n    this.destroyed = true;\n  };\n\n  _proto._getMarkerGroup = function _getMarkerGroup(type) {\n    var markerGroup = this.markerGroup;\n\n    if (!markerGroup) {\n      if (type === 'circle') {\n        markerGroup = this.frontPlot.addGroup({\n          zIndex: 1\n        });\n        this.frontPlot.sort();\n      } else {\n        markerGroup = this.backPlot.addGroup();\n      }\n\n      this.markerGroup = markerGroup;\n    } else {\n      markerGroup.clear();\n    }\n\n    return markerGroup;\n  };\n\n  _proto._renderCrosshairs = function _renderCrosshairs() {\n    var crosshairsType = this.crosshairsType,\n        crosshairsStyle = this.crosshairsStyle,\n        frontPlot = this.frontPlot,\n        plotRange = this.plotRange;\n    var tl = plotRange.tl,\n        br = plotRange.br;\n\n    if (Util.directionEnabled(crosshairsType, 'x')) {\n      this.crosshairsShapeX = frontPlot.addShape('Line', {\n        className: 'tooltip-crosshairs-x',\n        zIndex: 0,\n        visible: false,\n        attrs: Util.mix({\n          x1: tl.x,\n          y1: 0,\n          x2: br.x,\n          y2: 0\n        }, crosshairsStyle)\n      });\n    }\n\n    if (Util.directionEnabled(crosshairsType, 'y')) {\n      this.crosshairsShapeY = frontPlot.addShape('Line', {\n        className: 'tooltip-crosshairs-y',\n        zIndex: 0,\n        visible: false,\n        attrs: Util.mix({\n          x1: 0,\n          y1: br.y,\n          x2: 0,\n          y2: tl.y\n        }, crosshairsStyle)\n      });\n    }\n  };\n\n  return Tooltip;\n}();\n\nmodule.exports = Tooltip;\n\n/***/ }),\n/* 128 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar _require = __webpack_require__(5),\n    Group = _require.Group;\n\nvar TextBox =\n/*#__PURE__*/\nfunction () {\n  var _proto = TextBox.prototype;\n\n  _proto.getDefaultCfg = function getDefaultCfg() {\n    return {\n      x: 0,\n      y: 0,\n      content: '',\n      textStyle: {\n        fontSize: 12,\n        fill: '#fff',\n        textAlign: 'center',\n        textBaseline: 'middle'\n      },\n      background: {\n        radius: 1,\n        fill: 'rgba(0, 0, 0, 0.65)',\n        padding: [3, 5]\n      },\n      width: 0,\n      height: 0,\n      className: ''\n    };\n  };\n\n  function TextBox(cfg) {\n    Util.deepMix(this, this.getDefaultCfg(), cfg);\n\n    this._init();\n\n    var content = this.content,\n        x = this.x,\n        y = this.y;\n\n    if (!Util.isNil(content)) {\n      this.updateContent(content);\n    }\n\n    this.updatePosition(x, y);\n  }\n\n  _proto._init = function _init() {\n    var content = this.content,\n        textStyle = this.textStyle,\n        background = this.background,\n        className = this.className,\n        visible = this.visible;\n    var container = new Group({\n      className: className,\n      zIndex: 0,\n      visible: visible\n    });\n    var text = container.addShape('Text', {\n      className: className + '-text',\n      zIndex: 1,\n      attrs: Util.mix({\n        text: content,\n        x: 0,\n        y: 0\n      }, textStyle)\n    });\n    var backgroundShape = container.addShape('Rect', {\n      className: className + '-bg',\n      zIndex: -1,\n      attrs: Util.mix({\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0\n      }, background)\n    });\n    container.sort();\n    this.container = container;\n    this.textShape = text;\n    this.backgroundShape = backgroundShape;\n  };\n\n  _proto._getBBox = function _getBBox() {\n    var textShape = this.textShape;\n    var background = this.background;\n    var textBBox = textShape.getBBox();\n    var padding = Util.parsePadding(background.padding);\n    var width = textBBox.width + padding[1] + padding[3];\n    var height = textBBox.height + padding[0] + padding[2];\n    var x = textBBox.minX - padding[3];\n    var y = textBBox.minY - padding[0];\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height\n    };\n  };\n\n  _proto.updateContent = function updateContent(text) {\n    var textShape = this.textShape,\n        backgroundShape = this.backgroundShape;\n\n    if (!Util.isNil(text)) {\n      if (!Util.isObject(text)) {\n        text = {\n          text: text\n        };\n      }\n\n      textShape.attr(text); // update box shape\n\n      var _this$_getBBox = this._getBBox(),\n          x = _this$_getBBox.x,\n          y = _this$_getBBox.y,\n          tipWidth = _this$_getBBox.width,\n          tipHeight = _this$_getBBox.height;\n\n      var width = this.width || tipWidth;\n      var height = this.height || tipHeight;\n      backgroundShape.attr({\n        x: x,\n        y: y,\n        width: width,\n        height: height\n      });\n      this._width = width;\n      this._height = height;\n      this.content = text.text;\n    }\n  };\n\n  _proto.updatePosition = function updatePosition(x, y) {\n    var container = this.container;\n\n    var _this$_getBBox2 = this._getBBox(),\n        xMin = _this$_getBBox2.x,\n        yMin = _this$_getBBox2.y;\n\n    container.moveTo(x - xMin, y - yMin);\n    this.x = x - xMin;\n    this.y = y - yMin;\n  };\n\n  _proto.getWidth = function getWidth() {\n    return this._width;\n  };\n\n  _proto.getHeight = function getHeight() {\n    return this._height;\n  };\n\n  _proto.show = function show() {\n    this.container.show();\n  };\n\n  _proto.hide = function hide() {\n    this.container.hide();\n  };\n\n  _proto.clear = function clear() {\n    var container = this.container;\n    container.clear();\n    container.remove(true);\n    this.container = null;\n    this.textShape = null;\n    this.backgroundShape = null;\n  };\n\n  return TextBox;\n}();\n\nmodule.exports = TextBox;\n\n/***/ }),\n/* 129 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar Guide = __webpack_require__(11);\n\nvar Global = __webpack_require__(1); // register the default configuration for Guide\n\n\nGlobal.guide = Util.deepMix({\n  line: {\n    style: {\n      stroke: '#a3a3a3',\n      lineWidth: 1\n    },\n    top: true\n  },\n  text: {\n    style: {\n      fill: '#787878',\n      textAlign: 'center',\n      textBaseline: 'middle'\n    },\n    offsetX: 0,\n    offsetY: 0,\n    top: true\n  },\n  rect: {\n    style: {\n      fill: '#fafafa'\n    },\n    top: false\n  },\n  arc: {\n    style: {\n      stroke: '#a3a3a3'\n    },\n    top: true\n  },\n  html: {\n    offsetX: 0,\n    offsetY: 0,\n    alignX: 'center',\n    alignY: 'middle'\n  },\n  tag: {\n    top: true,\n    offsetX: 0,\n    offsetY: 0,\n    side: 4,\n    background: {\n      padding: 5,\n      radius: 2,\n      fill: '#1890FF'\n    },\n    textStyle: {\n      fontSize: 12,\n      fill: '#fff',\n      textAlign: 'center',\n      textBaseline: 'middle'\n    }\n  },\n  point: {\n    top: true,\n    offsetX: 0,\n    offsetY: 0,\n    style: {\n      fill: '#fff',\n      r: 3,\n      lineWidth: 2,\n      stroke: '#1890ff'\n    }\n  }\n}, Global.guide || {});\n\nvar GuideController =\n/*#__PURE__*/\nfunction () {\n  function GuideController(cfg) {\n    this.guides = [];\n    this.xScale = null;\n    this.yScales = null;\n    this.guideShapes = [];\n    Util.mix(this, cfg);\n  }\n\n  var _proto = GuideController.prototype;\n\n  _proto._toString = function _toString(position) {\n    if (Util.isFunction(position)) {\n      position = position(this.xScale, this.yScales);\n    }\n\n    position = position.toString();\n    return position;\n  };\n\n  _proto._getId = function _getId(shape, guide) {\n    var id = guide.id;\n\n    if (!id) {\n      var type = guide.type;\n\n      if (type === 'arc' || type === 'line' || type === 'rect') {\n        id = this._toString(guide.start) + '-' + this._toString(guide.end);\n      } else {\n        id = this._toString(guide.position);\n      }\n    }\n\n    return id;\n  };\n\n  _proto.paint = function paint(coord) {\n    var self = this;\n    var chart = self.chart,\n        guides = self.guides,\n        xScale = self.xScale,\n        yScales = self.yScales;\n    var guideShapes = [];\n    Util.each(guides, function (guide, idx) {\n      guide.xScale = xScale;\n      guide.yScales = yScales;\n      var container;\n\n      if (guide.type === 'regionFilter') {\n        // TODO: RegionFilter support animation\n        guide.chart = chart;\n      } else {\n        container = guide.top ? self.frontPlot : self.backPlot;\n      }\n\n      guide.coord = coord;\n      guide.container = container;\n      guide.canvas = chart.get('canvas');\n      var shape = guide.render(coord, container);\n\n      if (shape) {\n        var id = self._getId(shape, guide);\n\n        [].concat(shape).forEach(function (s) {\n          s._id = s.get('className') + '-' + id;\n          s.set('index', idx);\n          guideShapes.push(s);\n        });\n      }\n    });\n    self.guideShapes = guideShapes;\n  };\n\n  _proto.clear = function clear() {\n    this.reset();\n    this.guides = [];\n    return this;\n  };\n\n  _proto.reset = function reset() {\n    var guides = this.guides;\n    Util.each(guides, function (guide) {\n      guide.remove();\n    });\n  };\n\n  _proto._createGuide = function _createGuide(type, cfg) {\n    var ClassName = Util.upperFirst(type);\n    var guide = new Guide[ClassName](Util.deepMix({}, Global.guide[type], cfg));\n    this.guides.push(guide);\n    return guide;\n  };\n\n  _proto.line = function line(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('line', cfg);\n  };\n\n  _proto.text = function text(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('text', cfg);\n  };\n\n  _proto.arc = function arc(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('arc', cfg);\n  };\n\n  _proto.html = function html(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('html', cfg);\n  };\n\n  _proto.rect = function rect(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('rect', cfg);\n  };\n\n  _proto.tag = function tag(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('tag', cfg);\n  };\n\n  _proto.point = function point(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('point', cfg);\n  };\n\n  _proto.regionFilter = function regionFilter(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    return this._createGuide('regionFilter', cfg);\n  };\n\n  return GuideController;\n}();\n\nmodule.exports = {\n  init: function init(chart) {\n    var guideController = new GuideController({\n      frontPlot: chart.get('frontPlot').addGroup({\n        zIndex: 20,\n        className: 'guideContainer'\n      }),\n      backPlot: chart.get('backPlot').addGroup({\n        className: 'guideContainer'\n      })\n    });\n    chart.set('guideController', guideController);\n    /**\n     * 为图表添加 guide\n     * @return {GuideController} 返回 guide 控制器\n     */\n\n    chart.guide = function () {\n      return guideController;\n    };\n  },\n  afterGeomDraw: function afterGeomDraw(chart) {\n    var guideController = chart.get('guideController');\n\n    if (!guideController.guides.length) {\n      return;\n    }\n\n    var xScale = chart.getXScale();\n    var yScales = chart.getYScales();\n    var coord = chart.get('coord');\n    guideController.xScale = xScale;\n    guideController.yScales = yScales;\n    guideController.chart = chart; // for regionFilter\n\n    guideController.paint(coord);\n  },\n  clear: function clear(chart) {\n    chart.get('guideController').clear();\n  },\n  repaint: function repaint(chart) {\n    chart.get('guideController').reset();\n  }\n};\n\n/***/ }),\n/* 130 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Util = __webpack_require__(0);\n\nvar List = __webpack_require__(101);\n\nvar Global = __webpack_require__(1);\n\nvar LEGEND_GAP = 12;\nvar MARKER_SIZE = 3;\nvar DEFAULT_CFG = {\n  itemMarginBottom: 12,\n  itemGap: 10,\n  showTitle: false,\n  titleStyle: {\n    fontSize: 12,\n    fill: '#808080',\n    textAlign: 'start',\n    textBaseline: 'top'\n  },\n  nameStyle: {\n    fill: '#808080',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  valueStyle: {\n    fill: '#000000',\n    fontSize: 12,\n    textAlign: 'start',\n    textBaseline: 'middle'\n  },\n  unCheckStyle: {\n    fill: '#bfbfbf'\n  },\n  itemWidth: 'auto',\n  wordSpace: 6,\n  selectedMode: 'multiple' // 'multiple' or 'single'\n\n}; // Register the default configuration for Legend\n\nGlobal.legend = Util.deepMix({\n  common: DEFAULT_CFG,\n  // common legend configuration\n  right: Util.mix({\n    position: 'right',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  left: Util.mix({\n    position: 'left',\n    layout: 'vertical'\n  }, DEFAULT_CFG),\n  top: Util.mix({\n    position: 'top',\n    layout: 'horizontal'\n  }, DEFAULT_CFG),\n  bottom: Util.mix({\n    position: 'bottom',\n    layout: 'horizontal'\n  }, DEFAULT_CFG)\n}, Global.legend || {});\n\nfunction getPaddingByPos(pos, appendPadding) {\n  var padding = 0;\n  appendPadding = Util.parsePadding(appendPadding);\n\n  switch (pos) {\n    case 'top':\n      padding = appendPadding[0];\n      break;\n\n    case 'right':\n      padding = appendPadding[1];\n      break;\n\n    case 'bottom':\n      padding = appendPadding[2];\n      break;\n\n    case 'left':\n      padding = appendPadding[3];\n      break;\n\n    default:\n      break;\n  }\n\n  return padding;\n}\n\nvar LegendController =\n/*#__PURE__*/\nfunction () {\n  function LegendController(cfg) {\n    this.legendCfg = {};\n    this.enable = true;\n    this.position = 'top';\n    Util.mix(this, cfg);\n    var chart = this.chart;\n    this.canvasDom = chart.get('canvas').get('el');\n    this.clear();\n  }\n\n  var _proto = LegendController.prototype;\n\n  _proto.addLegend = function addLegend(scale, items, filterVals) {\n    var self = this;\n    var legendCfg = self.legendCfg;\n    var field = scale.field;\n    var fieldCfg = legendCfg[field];\n\n    if (fieldCfg === false) {\n      return null;\n    }\n\n    if (fieldCfg && fieldCfg.custom) {\n      self.addCustomLegend(field);\n    } else {\n      var position = legendCfg.position || self.position;\n\n      if (fieldCfg && fieldCfg.position) {\n        position = fieldCfg.position;\n      }\n\n      if (scale.isCategory) {\n        self._addCategoryLegend(scale, items, position, filterVals);\n      }\n    }\n  };\n\n  _proto.addCustomLegend = function addCustomLegend(field) {\n    var self = this;\n    var legendCfg = self.legendCfg;\n\n    if (field && legendCfg[field]) {\n      legendCfg = legendCfg[field];\n    }\n\n    var position = legendCfg.position || self.position;\n    var legends = self.legends;\n    legends[position] = legends[position] || [];\n    var items = legendCfg.items;\n\n    if (!items) {\n      return null;\n    }\n\n    var container = self.container;\n    Util.each(items, function (item) {\n      if (!Util.isPlainObject(item.marker)) {\n        item.marker = {\n          symbol: item.marker || 'circle',\n          fill: item.fill,\n          radius: MARKER_SIZE\n        };\n      } else {\n        item.marker.radius = item.marker.radius || MARKER_SIZE;\n      }\n\n      item.checked = Util.isNil(item.checked) ? true : item.checked;\n      item.name = item.name || item.value;\n    });\n    var legend = new List(Util.deepMix({}, Global.legend[position], legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items: items,\n      parent: container\n    }));\n    legends[position].push(legend);\n  };\n\n  _proto.clear = function clear() {\n    var legends = this.legends;\n    Util.each(legends, function (legendItems) {\n      Util.each(legendItems, function (legend) {\n        legend.clear();\n      });\n    });\n    this.legends = {};\n    this.unBindEvents();\n  };\n\n  _proto._isFiltered = function _isFiltered(scale, values, value) {\n    var rst = false;\n    Util.each(values, function (val) {\n      rst = rst || scale.getText(val) === scale.getText(value);\n\n      if (rst) {\n        return false;\n      }\n    });\n    return rst;\n  };\n\n  _proto._getMaxLength = function _getMaxLength(position) {\n    var chart = this.chart;\n    var appendPadding = Util.parsePadding(chart.get('appendPadding'));\n    return position === 'right' || position === 'left' ? chart.get('height') - (appendPadding[0] + appendPadding[2]) : chart.get('width') - (appendPadding[1] + appendPadding[3]);\n  };\n\n  _proto._addCategoryLegend = function _addCategoryLegend(scale, items, position, filterVals) {\n    var self = this;\n    var legendCfg = self.legendCfg,\n        legends = self.legends,\n        container = self.container,\n        chart = self.chart;\n    var field = scale.field;\n    legends[position] = legends[position] || [];\n    var symbol = 'circle';\n\n    if (legendCfg[field] && legendCfg[field].marker) {\n      symbol = legendCfg[field].marker;\n    } else if (legendCfg.marker) {\n      symbol = legendCfg.marker;\n    }\n\n    Util.each(items, function (item) {\n      if (Util.isPlainObject(symbol)) {\n        Util.mix(item.marker, symbol);\n      } else {\n        item.marker.symbol = symbol;\n      }\n\n      if (filterVals) {\n        item.checked = self._isFiltered(scale, filterVals, item.dataValue);\n      }\n    });\n    var legendItems = chart.get('legendItems');\n    legendItems[field] = items;\n    var lastCfg = Util.deepMix({}, Global.legend[position], legendCfg[field] || legendCfg, {\n      maxLength: self._getMaxLength(position),\n      items: items,\n      field: field,\n      filterVals: filterVals,\n      parent: container\n    });\n\n    if (lastCfg.showTitle) {\n      Util.deepMix(lastCfg, {\n        title: scale.alias || scale.field\n      });\n    }\n\n    var legend = new List(lastCfg);\n    legends[position].push(legend);\n    return legend;\n  };\n\n  _proto._alignLegend = function _alignLegend(legend, pre, position) {\n    var self = this;\n    var _self$plotRange = self.plotRange,\n        tl = _self$plotRange.tl,\n        bl = _self$plotRange.bl;\n    var chart = self.chart;\n    var offsetX = legend.offsetX || 0;\n    var offsetY = legend.offsetY || 0;\n    var chartWidth = chart.get('width');\n    var chartHeight = chart.get('height');\n    var appendPadding = Util.parsePadding(chart.get('appendPadding'));\n    var legendHeight = legend.getHeight();\n    var legendWidth = legend.getWidth();\n    var x = 0;\n    var y = 0;\n\n    if (position === 'left' || position === 'right') {\n      var verticalAlign = legend.verticalAlign || 'middle';\n      var height = Math.abs(tl.y - bl.y);\n      x = position === 'left' ? appendPadding[3] : chartWidth - legendWidth - appendPadding[1];\n      y = (height - legendHeight) / 2 + tl.y;\n\n      if (verticalAlign === 'top') {\n        y = tl.y;\n      } else if (verticalAlign === 'bottom') {\n        y = bl.y - legendHeight;\n      }\n\n      if (pre) {\n        y = pre.get('y') - legendHeight - LEGEND_GAP;\n      }\n    } else {\n      var align = legend.align || 'left';\n      x = appendPadding[3];\n\n      if (align === 'center') {\n        x = chartWidth / 2 - legendWidth / 2;\n      } else if (align === 'right') {\n        x = chartWidth - (legendWidth + appendPadding[1]);\n      }\n\n      y = position === 'top' ? appendPadding[0] + Math.abs(legend.container.getBBox().minY) : chartHeight - legendHeight;\n\n      if (pre) {\n        var preWidth = pre.getWidth();\n        x = pre.x + preWidth + LEGEND_GAP;\n      }\n    }\n\n    if (position === 'bottom' && offsetY > 0) {\n      offsetY = 0;\n    }\n\n    if (position === 'right' && offsetX > 0) {\n      offsetX = 0;\n    }\n\n    legend.moveTo(x + offsetX, y + offsetY);\n  };\n\n  _proto.alignLegends = function alignLegends() {\n    var self = this;\n    var legends = self.legends;\n    Util.each(legends, function (legendItems, position) {\n      Util.each(legendItems, function (legend, index) {\n        var pre = legendItems[index - 1];\n\n        self._alignLegend(legend, pre, position);\n      });\n    });\n    return self;\n  };\n\n  _proto.handleEvent = function handleEvent(ev) {\n    var self = this;\n\n    function findItem(x, y) {\n      var result = null;\n      var legends = self.legends;\n      Util.each(legends, function (legendItems) {\n        Util.each(legendItems, function (legend) {\n          var itemsGroup = legend.itemsGroup,\n              legendHitBoxes = legend.legendHitBoxes;\n          var children = itemsGroup.get('children');\n\n          if (children.length) {\n            var legendPosX = legend.x;\n            var legendPosY = legend.y;\n            Util.each(legendHitBoxes, function (box, index) {\n              if (x >= box.x + legendPosX && x <= box.x + box.width + legendPosX && y >= box.y + legendPosY && y <= box.height + box.y + legendPosY) {\n                // inbox\n                result = {\n                  clickedItem: children[index],\n                  clickedLegend: legend\n                };\n                return false;\n              }\n            });\n          }\n        });\n      });\n      return result;\n    }\n\n    var chart = self.chart;\n\n    var _Util$createEvent = Util.createEvent(ev, chart),\n        x = _Util$createEvent.x,\n        y = _Util$createEvent.y;\n\n    var clicked = findItem(x, y);\n\n    if (clicked && clicked.clickedLegend.clickable !== false) {\n      var clickedItem = clicked.clickedItem,\n          clickedLegend = clicked.clickedLegend;\n\n      if (clickedLegend.onClick) {\n        ev.clickedItem = clickedItem;\n        clickedLegend.onClick(ev);\n      } else if (!clickedLegend.custom) {\n        var checked = clickedItem.get('checked');\n        var value = clickedItem.get('dataValue');\n        var filterVals = clickedLegend.filterVals,\n            field = clickedLegend.field,\n            selectedMode = clickedLegend.selectedMode;\n        var isSingeSelected = selectedMode === 'single';\n\n        if (isSingeSelected) {\n          chart.filter(field, function (val) {\n            return val === value;\n          });\n        } else {\n          if (!checked) {\n            filterVals.push(value);\n          } else {\n            Util.Array.remove(filterVals, value);\n          }\n\n          chart.filter(field, function (val) {\n            return filterVals.indexOf(val) !== -1;\n          });\n        }\n\n        chart.repaint();\n      }\n    }\n  };\n\n  _proto.bindEvents = function bindEvents() {\n    var legendCfg = this.legendCfg;\n    var triggerOn = legendCfg.triggerOn || 'touchstart';\n    var method = Util.wrapBehavior(this, 'handleEvent');\n    Util.addEventListener(this.canvasDom, triggerOn, method);\n  };\n\n  _proto.unBindEvents = function unBindEvents() {\n    var legendCfg = this.legendCfg;\n    var triggerOn = legendCfg.triggerOn || 'touchstart';\n    var method = Util.getWrapBehavior(this, 'handleEvent');\n    Util.removeEventListener(this.canvasDom, triggerOn, method);\n  };\n\n  return LegendController;\n}();\n\nmodule.exports = {\n  init: function init(chart) {\n    var legendController = new LegendController({\n      container: chart.get('backPlot'),\n      plotRange: chart.get('plotRange'),\n      chart: chart\n    });\n    chart.set('legendController', legendController);\n\n    chart.legend = function (field, cfg) {\n      var legendCfg = legendController.legendCfg;\n      legendController.enable = true;\n\n      if (Util.isBoolean(field)) {\n        legendController.enable = field;\n        legendCfg = cfg || {};\n      } else if (Util.isObject(field)) {\n        legendCfg = field;\n      } else {\n        legendCfg[field] = cfg;\n      }\n\n      legendController.legendCfg = legendCfg;\n      return this;\n    };\n  },\n  beforeGeomDraw: function beforeGeomDraw(chart) {\n    var legendController = chart.get('legendController');\n    if (!legendController.enable) return null; // legend is not displayed\n\n    var legendCfg = legendController.legendCfg;\n\n    if (legendCfg && legendCfg.custom) {\n      legendController.addCustomLegend();\n    } else {\n      var legendItems = chart.getLegendItems();\n      var scales = chart.get('scales');\n      var filters = chart.get('filters');\n      Util.each(legendItems, function (items, field) {\n        var scale = scales[field];\n        var values = scale.values;\n        var filterVals;\n\n        if (filters && filters[field]) {\n          filterVals = values.filter(filters[field]);\n        } else {\n          filterVals = values.slice(0);\n        }\n\n        legendController.addLegend(scale, items, filterVals);\n      });\n    }\n\n    if (legendCfg && legendCfg.clickable !== false) {\n      legendController.bindEvents();\n    }\n\n    var legends = legendController.legends;\n    var legendRange = {\n      top: 0,\n      right: 0,\n      bottom: 0,\n      left: 0\n    };\n    Util.each(legends, function (legendItems, position) {\n      var padding = 0;\n      Util.each(legendItems, function (legend) {\n        var width = legend.getWidth();\n        var height = legend.getHeight();\n\n        if (position === 'top' || position === 'bottom') {\n          padding = Math.max(padding, height);\n\n          if (legend.offsetY > 0) {\n            padding += legend.offsetY;\n          }\n        } else {\n          padding = Math.max(padding, width);\n\n          if (legend.offsetX > 0) {\n            padding += legend.offsetX;\n          }\n        }\n      });\n      legendRange[position] = padding + getPaddingByPos(position, chart.get('appendPadding'));\n    });\n    chart.set('legendRange', legendRange);\n  },\n  afterGeomDraw: function afterGeomDraw(chart) {\n    var legendController = chart.get('legendController');\n    legendController.alignLegends();\n  },\n  clearInner: function clearInner(chart) {\n    var legendController = chart.get('legendController');\n    legendController.clear();\n    chart.set('legendRange', null);\n  }\n};\n\n/***/ }),\n/* 131 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Handle the detail animations\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Element = __webpack_require__(27);\n\nvar Timeline = __webpack_require__(132);\n\nvar Animator = __webpack_require__(133);\n\nvar Animate = __webpack_require__(102);\n\nvar ShapeAction = __webpack_require__(135);\n\nvar GroupAction = __webpack_require__(136);\n\nvar Chart = __webpack_require__(15);\n\nvar timeline;\n\nElement.prototype.animate = function () {\n  var attrs = Util.mix({}, this.get('attrs'));\n  return new Animator(this, attrs, timeline);\n};\n\nChart.prototype.animate = function (cfg) {\n  this.set('animate', cfg);\n  return this;\n};\n\nAnimate.Action = ShapeAction;\nAnimate.defaultCfg = {\n  interval: {\n    enter: function enter(coord) {\n      if (coord.isPolar && coord.transposed) {\n        // for pie chart\n        return function (shape) {\n          shape.set('zIndex', -1);\n          var container = shape.get('parent');\n          container.sort();\n        };\n      }\n\n      return ShapeAction.fadeIn;\n    }\n  },\n  area: {\n    enter: function enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n  },\n  line: {\n    enter: function enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n  },\n  path: {\n    enter: function enter(coord) {\n      if (coord.isPolar) return null;\n      return ShapeAction.fadeIn;\n    }\n  }\n};\nvar GROUP_ANIMATION = {\n  line: function line(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n  area: function area(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n  path: function path(coord) {\n    if (coord.isPolar) {\n      return GroupAction.groupScaleInXY;\n    }\n\n    return GroupAction.groupWaveIn;\n  },\n  point: function point() {\n    return GroupAction.shapesScaleInXY;\n  },\n  interval: function interval(coord) {\n    var result;\n\n    if (coord.isPolar) {\n      // polar coodinate\n      result = GroupAction.groupScaleInXY;\n\n      if (coord.transposed) {\n        // pie chart\n        result = GroupAction.groupWaveIn;\n      }\n    } else {\n      result = coord.transposed ? GroupAction.groupScaleInX : GroupAction.groupScaleInY;\n    }\n\n    return result;\n  },\n  schema: function schema() {\n    return GroupAction.groupWaveIn;\n  }\n};\n\nfunction diff(fromAttrs, toAttrs) {\n  var endState = {};\n\n  for (var k in toAttrs) {\n    if (Util.isNumber(fromAttrs[k]) && fromAttrs[k] !== toAttrs[k]) {\n      endState[k] = toAttrs[k];\n    } else if (Util.isArray(fromAttrs[k]) && JSON.stringify(fromAttrs[k]) !== JSON.stringify(toAttrs[k])) {\n      endState[k] = toAttrs[k];\n    }\n  }\n\n  return endState;\n} // Add a unique id identifier to each shape\n\n\nfunction _getShapeId(geom, dataObj, geomIdx) {\n  var type = geom.get('type');\n  var id = 'geom' + geomIdx + '-' + type;\n  var xScale = geom.getXScale();\n  var yScale = geom.getYScale();\n  var xField = xScale.field || 'x';\n  var yField = yScale.field || 'y';\n  var yVal = dataObj[yField];\n  var xVal;\n\n  if (xScale.isIdentity) {\n    xVal = xScale.value;\n  } else {\n    xVal = dataObj[xField];\n  }\n\n  if (type === 'interval' || type === 'schema') {\n    id += '-' + xVal;\n  } else if (type === 'line' || type === 'area' || type === 'path') {\n    id += '-' + type;\n  } else {\n    id += xScale.isCategory ? '-' + xVal : '-' + xVal + '-' + yVal;\n  }\n\n  var groupScales = geom._getGroupScales();\n\n  Util.each(groupScales, function (groupScale) {\n    var field = groupScale.field;\n\n    if (groupScale.type !== 'identity') {\n      id += '-' + dataObj[field];\n    }\n  });\n  return id;\n} // get geometry's shapes\n\n\nfunction getShapes(geoms, chart, coord) {\n  var shapes = [];\n  Util.each(geoms, function (geom, geomIdx) {\n    var geomContainer = geom.get('container');\n    var geomShapes = geomContainer.get('children');\n    var type = geom.get('type');\n    var animateCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n\n    if (animateCfg !== false) {\n      Util.each(geomShapes, function (shape, index) {\n        if (shape.get('className') === type) {\n          shape._id = _getShapeId(geom, shape.get('origin')._origin, geomIdx);\n          shape.set('coord', coord);\n          shape.set('animateCfg', animateCfg);\n          shape.set('index', index);\n          shapes.push(shape);\n        }\n      });\n    }\n\n    geom.set('shapes', geomShapes);\n  });\n  return shapes;\n}\n\nfunction cache(shapes) {\n  var rst = {};\n\n  for (var i = 0, len = shapes.length; i < len; i++) {\n    var shape = shapes[i];\n    if (!shape._id || shape.isClip) continue;\n    var id = shape._id;\n    rst[id] = {\n      _id: id,\n      type: shape.get('type'),\n      // the type of shape\n      attrs: Util.mix({}, shape._attrs.attrs),\n      // the graphics attributes of shape\n      className: shape.get('className'),\n      geomType: shape.get('className'),\n      index: shape.get('index'),\n      coord: shape.get('coord'),\n      animateCfg: shape.get('animateCfg')\n    };\n  }\n\n  return rst;\n}\n\nfunction getAnimate(geomType, coord, animationType, animationName) {\n  var result;\n\n  if (Util.isFunction(animationName)) {\n    result = animationName;\n  } else if (Util.isString(animationName)) {\n    result = Animate.Action[animationName];\n  } else {\n    result = Animate.getAnimation(geomType, coord, animationType);\n  }\n\n  return result;\n}\n\nfunction getAnimateCfg(geomType, animationType, animateCfg) {\n  if (animateCfg === false || Util.isObject(animateCfg) && animateCfg[animationType] === false) {\n    return false;\n  }\n\n  var defaultCfg = Animate.getAnimateCfg(geomType, animationType);\n\n  if (animateCfg && animateCfg[animationType]) {\n    return Util.deepMix({}, defaultCfg, animateCfg[animationType]);\n  }\n\n  return defaultCfg;\n}\n\nfunction addAnimate(cache, shapes, canvas) {\n  var animate;\n  var animateCfg; // the order of animation: leave -> update -> enter\n\n  var updateShapes = [];\n  var newShapes = [];\n  Util.each(shapes, function (shape) {\n    var result = cache[shape._id];\n\n    if (!result) {\n      newShapes.push(shape);\n    } else {\n      shape.set('cacheShape', result);\n      updateShapes.push(shape);\n      delete cache[shape._id];\n    }\n  }); // first do the leave animation\n\n  Util.each(cache, function (deletedShape) {\n    var className = deletedShape.className,\n        coord = deletedShape.coord,\n        _id = deletedShape._id,\n        attrs = deletedShape.attrs,\n        index = deletedShape.index,\n        type = deletedShape.type;\n    animateCfg = getAnimateCfg(className, 'leave', deletedShape.animateCfg);\n    if (animateCfg === false) return true;\n    animate = getAnimate(className, coord, 'leave', animateCfg.animation);\n\n    if (Util.isFunction(animate)) {\n      var tempShape = canvas.addShape(type, {\n        attrs: attrs,\n        index: index,\n        canvas: canvas,\n        className: className\n      });\n      tempShape._id = _id;\n      animate(tempShape, animateCfg, coord);\n    }\n  }); // then do the update animation\n\n  Util.each(updateShapes, function (updateShape) {\n    var className = updateShape.get('className');\n    animateCfg = getAnimateCfg(className, 'update', updateShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n    var coord = updateShape.get('coord');\n    var cacheAttrs = updateShape.get('cacheShape').attrs;\n    var endState = diff(cacheAttrs, updateShape._attrs.attrs); // 判断如果属性相同的话就不进行变换\n\n    if (Object.keys(endState).length) {\n      animate = getAnimate(className, coord, 'update', animateCfg.animation);\n\n      if (Util.isFunction(animate)) {\n        animate(updateShape, animateCfg, coord);\n      } else {\n        updateShape.attr(cacheAttrs);\n        updateShape.animate().to({\n          attrs: endState,\n          duration: animateCfg.duration,\n          easing: animateCfg.easing,\n          delay: animateCfg.delay\n        }).onEnd(function () {\n          updateShape.set('cacheShape', null);\n        });\n      }\n    }\n  }); // last, enter animation\n\n  Util.each(newShapes, function (newShape) {\n    // 新图形元素的进场元素\n    var className = newShape.get('className');\n    var coord = newShape.get('coord');\n    animateCfg = getAnimateCfg(className, 'enter', newShape.get('animateCfg'));\n    if (animateCfg === false) return true;\n    animate = getAnimate(className, coord, 'enter', animateCfg.animation);\n\n    if (Util.isFunction(animate)) {\n      if (className === 'interval' && coord.isPolar && coord.transposed) {\n        var index = newShape.get('index');\n        var lastShape = updateShapes[index - 1];\n        animate(newShape, animateCfg, lastShape);\n      } else {\n        animate(newShape, animateCfg, coord);\n      }\n    }\n  });\n}\n\nfunction _getAnimateCfgByShapeType(type, chart) {\n  if (!type) {\n    return null;\n  }\n\n  var animateCfg = chart.get('animate');\n\n  if (type.indexOf('guide-tag') > -1) {\n    type = 'guide-tag';\n  }\n\n  if (Util.isObject(animateCfg)) {\n    return animateCfg[type];\n  }\n\n  if (animateCfg === false) {\n    return false;\n  }\n\n  return null;\n}\n\nmodule.exports = {\n  afterCanvasInit: function afterCanvasInit()\n  /* chart */\n  {\n    timeline = new Timeline();\n    timeline.play();\n  },\n  beforeCanvasDraw: function beforeCanvasDraw(chart) {\n    if (chart.get('animate') === false) {\n      return;\n    }\n\n    var isUpdate = chart.get('isUpdate');\n    var canvas = chart.get('canvas');\n    var coord = chart.get('coord');\n    var geoms = chart.get('geoms');\n    var caches = canvas.get('caches') || [];\n\n    if (caches.length === 0) {\n      isUpdate = false;\n    }\n\n    var cacheShapes = getShapes(geoms, chart, coord);\n\n    var _chart$get = chart.get('axisController'),\n        frontPlot = _chart$get.frontPlot,\n        backPlot = _chart$get.backPlot;\n\n    var axisShapes = frontPlot.get('children').concat(backPlot.get('children'));\n    var guideShapes = [];\n\n    if (chart.get('guideController')) {\n      guideShapes = chart.get('guideController').guideShapes;\n    }\n\n    var componentShapes = [];\n    axisShapes.concat(guideShapes).forEach(function (s) {\n      var className = s.get('className');\n\n      var animateCfg = _getAnimateCfgByShapeType(className, chart);\n\n      s.set('coord', coord);\n      s.set('animateCfg', animateCfg);\n      componentShapes.push(s);\n      cacheShapes.push(s);\n    });\n    canvas.set('caches', cache(cacheShapes));\n\n    if (isUpdate) {\n      addAnimate(caches, cacheShapes, canvas);\n    } else {\n      // do the appear animation\n      var animateCfg;\n      var animate;\n      Util.each(geoms, function (geom) {\n        var type = geom.get('type');\n        var geomCfg = Util.isNil(geom.get('animateCfg')) ? _getAnimateCfgByShapeType(type, chart) : geom.get('animateCfg');\n\n        if (geomCfg !== false) {\n          animateCfg = getAnimateCfg(type, 'appear', geomCfg);\n          animate = getAnimate(type, coord, 'appear', animateCfg.animation);\n\n          if (Util.isFunction(animate)) {\n            var shapes = geom.get('shapes');\n            Util.each(shapes, function (shape) {\n              animate(shape, animateCfg, coord);\n            });\n          } else if (GROUP_ANIMATION[type]) {\n            // do the default animation\n            animate = GroupAction[animateCfg.animation] || GROUP_ANIMATION[type](coord);\n            var yScale = geom.getYScale();\n            var zeroY = coord.convertPoint({\n              x: 0,\n              y: yScale.scale(geom.getYMinValue())\n            });\n            var container = geom.get('container');\n            animate && animate(container, animateCfg, coord, zeroY);\n          }\n        }\n      }); // do the animation of components\n\n      Util.each(componentShapes, function (shape) {\n        var animateCfg = shape.get('animateCfg');\n        var className = shape.get('className');\n\n        if (animateCfg && animateCfg.appear) {\n          // if user configure\n          var defaultCfg = Animate.getAnimateCfg(className, 'appear');\n          var appearCfg = Util.deepMix({}, defaultCfg, animateCfg.appear);\n\n          var _animate = getAnimate(className, coord, 'appear', appearCfg.animation);\n\n          if (Util.isFunction(_animate)) {\n            _animate(shape, appearCfg, coord);\n          }\n        }\n      });\n    }\n  },\n  afterCanvasDestroyed: function afterCanvasDestroyed()\n  /* chart */\n  {\n    timeline.stop();\n  }\n};\n\n/***/ }),\n/* 132 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar _require = __webpack_require__(40),\n    requestAnimationFrame = _require.requestAnimationFrame;\n\nvar clock = typeof performance === 'object' && performance.now ? performance : Date;\n\nvar Timeline =\n/*#__PURE__*/\nfunction () {\n  function Timeline() {\n    this.anims = [];\n    this.time = null;\n    this.playing = false;\n    this.canvas = [];\n  }\n\n  var _proto = Timeline.prototype;\n\n  _proto.play = function play() {\n    var self = this;\n    self.time = clock.now();\n    self.playing = true;\n\n    function step() {\n      if (self.playing) {\n        requestAnimationFrame(step);\n        self.update();\n      }\n    }\n\n    requestAnimationFrame(step);\n  };\n\n  _proto.stop = function stop() {\n    this.playing = false;\n    this.time = null;\n    this.canvas = [];\n  };\n\n  _proto.update = function update() {\n    var currentTime = clock.now();\n    this.canvas = [];\n\n    for (var i = 0; i < this.anims.length; i++) {\n      var propertyAnim = this.anims[i];\n\n      if (currentTime < propertyAnim.startTime || propertyAnim.hasEnded) {\n        continue;\n      }\n\n      var shape = propertyAnim.shape; // shape\n\n      if (shape.get('destroyed')) {\n        this.anims.splice(i, 1);\n        i--;\n        continue;\n      }\n\n      var startState = propertyAnim.startState,\n          endState = propertyAnim.endState,\n          interpolate = propertyAnim.interpolate,\n          duration = propertyAnim.duration;\n\n      if (currentTime >= propertyAnim.startTime && !propertyAnim.hasStarted) {\n        propertyAnim.hasStarted = true;\n\n        if (propertyAnim.onStart) {\n          propertyAnim.onStart();\n        }\n      }\n\n      var t = (currentTime - propertyAnim.startTime) / duration;\n      t = Math.max(0, Math.min(t, 1));\n      t = propertyAnim.easing(t);\n\n      if (propertyAnim.onFrame) {\n        propertyAnim.onFrame(t);\n      } else {\n        for (var key in interpolate) {\n          var diff = interpolate[key];\n          var value = diff(t);\n          var newValue = void 0;\n\n          if (key === 'points') {\n            newValue = [];\n            var aLen = Math.max(startState.points.length, endState.points.length);\n\n            for (var j = 0; j < aLen; j += 2) {\n              newValue.push({\n                x: value[j],\n                y: value[j + 1]\n              });\n            }\n          } else {\n            newValue = value;\n          }\n\n          shape._attrs.attrs[key] = newValue;\n          shape._attrs.bbox = null; // should clear calculated bbox\n        }\n      }\n\n      var canvas = shape.get('canvas');\n\n      if (this.canvas.indexOf(canvas) === -1) {\n        this.canvas.push(canvas);\n      }\n\n      if (propertyAnim.onUpdate) {\n        propertyAnim.onUpdate(t);\n      }\n\n      if (currentTime >= propertyAnim.endTime && !propertyAnim.hasEnded) {\n        propertyAnim.hasEnded = true;\n\n        if (propertyAnim.onEnd) {\n          propertyAnim.onEnd();\n        }\n      }\n\n      if (t === 1) {\n        // end\n        this.anims.splice(i, 1);\n        i--;\n      }\n    }\n\n    this.canvas.map(function (c) {\n      c.draw();\n      return c;\n    });\n    this.time = clock.now();\n  };\n\n  return Timeline;\n}();\n\nmodule.exports = Timeline;\n\n/***/ }),\n/* 133 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar Easing = __webpack_require__(134);\n\nfunction plainArray(arr) {\n  var result = [];\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    if (arr[i]) {\n      result.push(arr[i].x);\n      result.push(arr[i].y);\n    }\n  }\n\n  return result;\n}\n\nfunction interpolateNumber(a, b) {\n  a = +a;\n  b -= a;\n  return function (t) {\n    return a + b * t;\n  };\n}\n\nfunction interpolateArray(a, b) {\n  var nb = b ? b.length : 0;\n  var na = a ? Math.min(nb, a.length) : 0;\n  var x = new Array(na);\n  var c = new Array(nb);\n  var i;\n\n  for (i = 0; i < na; ++i) {\n    x[i] = interpolateNumber(a[i], b[i]);\n  }\n\n  for (; i < nb; ++i) {\n    c[i] = b[i];\n  }\n\n  return function (t) {\n    for (i = 0; i < na; ++i) {\n      c[i] = x[i](t);\n    }\n\n    return c;\n  };\n}\n\nvar Animator =\n/*#__PURE__*/\nfunction () {\n  function Animator(shape, source, timeline) {\n    this.hasStarted = false;\n    this.hasEnded = false;\n    this.shape = shape;\n    this.source = source;\n    this.timeline = timeline;\n    this.animate = null;\n  } // delay, attrs, duration, easing\n\n\n  var _proto = Animator.prototype;\n\n  _proto.to = function to(cfg) {\n    if (cfg === void 0) {\n      cfg = {};\n    }\n\n    var delay = cfg.delay || 0;\n    var attrs = cfg.attrs || {};\n    var duration = cfg.duration || 1000;\n    var easing; // 缓动函数\n\n    if (typeof cfg.easing === 'function') {\n      easing = cfg.easing;\n    } else {\n      easing = Easing[cfg.easing] || Easing.linear;\n    }\n\n    var animInfo = {\n      shape: this.shape,\n      startTime: this.timeline.time + delay,\n      duration: duration,\n      easing: easing\n    };\n    var interpolate = {}; // 差值函数\n\n    for (var attrName in attrs) {\n      var startValue = this.source[attrName];\n      var endValue = attrs[attrName];\n\n      if (attrName === 'points') {\n        startValue = plainArray(startValue);\n        endValue = plainArray(endValue);\n        interpolate.points = interpolateArray(startValue, endValue);\n        this.source.points = startValue;\n        attrs.points = endValue;\n      } else if (attrName === 'matrix') {\n        interpolate.matrix = interpolateArray(startValue, endValue);\n      } else {\n        interpolate[attrName] = interpolateNumber(startValue, endValue);\n      }\n    }\n\n    animInfo.interpolate = interpolate;\n    animInfo.startState = this.source;\n    animInfo.endState = attrs;\n    animInfo.endTime = animInfo.startTime + duration;\n    this.timeline.anims.push(animInfo);\n    this.animate = animInfo;\n    return this;\n  };\n\n  _proto.onFrame = function onFrame(callback) {\n    // 自定义每一帧动画的动作\n    if (this.animate) {\n      this.animate.onFrame = function (frame) {\n        callback(frame);\n      };\n    }\n\n    return this;\n  };\n\n  _proto.onStart = function onStart(callback) {\n    if (this.animate) {\n      this.animate.onStart = function () {\n        callback();\n      };\n    }\n\n    return this;\n  };\n\n  _proto.onUpdate = function onUpdate(callback) {\n    if (this.animate) {\n      this.animate.onUpdate = function (frame) {\n        callback(frame);\n      };\n    }\n\n    return this;\n  };\n\n  _proto.onEnd = function onEnd(callback) {\n    if (this.animate) {\n      this.animate.onEnd = function () {\n        callback();\n      };\n    }\n\n    return this;\n  };\n\n  return Animator;\n}();\n\nmodule.exports = Animator;\n\n/***/ }),\n/* 134 */\n/***/ (function(module, exports) {\n\nvar Easing = {\n  linear: function linear(k) {\n    return k;\n  },\n  quadraticIn: function quadraticIn(k) {\n    return k * k;\n  },\n  quadraticOut: function quadraticOut(k) {\n    return k * (2 - k);\n  },\n  quadraticInOut: function quadraticInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  },\n  cubicIn: function cubicIn(k) {\n    return k * k * k;\n  },\n  cubicOut: function cubicOut(k) {\n    return --k * k * k + 1;\n  },\n  cubicInOut: function cubicInOut(k) {\n    if ((k *= 2) < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    return 0.5 * ((k -= 2) * k * k + 2);\n  },\n  elasticIn: function elasticIn(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n\n    if (!p) {\n      p = 0.3;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\n    }\n\n    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n  elasticOut: function elasticOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n\n    if (!p) {\n      p = 0.3;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n  elasticInOut: function elasticInOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n    if (k === 0) return 0;\n    if (k === 1) return 1;\n\n    if (!p) {\n      p = 0.3;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p / (2 * Math.PI) * Math.asin(1 / a);\n    }\n\n    if ((k *= 2) < 1) {\n      return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  },\n  backIn: function backIn(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n  backOut: function backOut(k) {\n    var s = 1.70158;\n    return (k = k - 1) * k * ((s + 1) * k + s) + 1;\n  },\n  backInOut: function backInOut(k) {\n    var s = 1.70158 * 1.525;\n\n    if ((k *= 2) < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);\n  },\n  bounceIn: function bounceIn(k) {\n    return 1 - Easing.bounceOut(1 - k);\n  },\n  bounceOut: function bounceOut(k) {\n    if ((k /= 1) < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n    }\n\n    return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n  },\n  bounceInOut: function bounceInOut(k) {\n    if (k < 0.5) {\n      return Easing.bounceIn(k * 2) * 0.5;\n    }\n\n    return Easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\nmodule.exports = Easing;\n\n/***/ }),\n/* 135 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Animation functions for shape\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(0);\n\nvar Helpers = __webpack_require__(103);\n/*\nfunction waveIn(shape, animateCfg, coord) {\n  const clip = Helpers.getClip(coord);\n  clip.set('canvas', shape.get('canvas'));\n  shape.attr('clip', clip);\n  const onEnd = function() {\n    shape.attr('clip', null);\n    clip.remove(true);\n  };\n  Helpers.doAnimation(clip, clip.endState, animateCfg, onEnd);\n}\n\nfunction scaleInX(shape, animateCfg) {\n  const box = shape.getBBox();\n  const points = shape.get('origin').points;\n  let x;\n  const y = (box.minY + box.maxY) / 2;\n\n  if (points[0].y - points[1].y > 0) { // 当顶点在零点之下\n    x = box.maxX;\n  } else {\n    x = box.minX;\n  }\n  const scaledMatrix = Helpers.getScaledMatrix(shape, [ x, y ], 'x');\n  Helpers.doAnimation(shape, { matrix: scaledMatrix }, animateCfg);\n}\n\nfunction scaleInY(shape, animateCfg) {\n  const box = shape.getBBox();\n  const points = shape.get('origin').points;\n  const x = (box.minX + box.maxX) / 2;\n  let y;\n\n  if (points[0].y - points[1].y <= 0) { // 当顶点在零点之下\n    y = box.maxY;\n  } else {\n    y = box.minY;\n  }\n  const scaledMatrix = Helpers.getScaledMatrix(shape, [ x, y ], 'x');\n  Helpers.doAnimation(shape, { matrix: scaledMatrix }, animateCfg);\n}\n*/\n\n\nfunction fadeIn(shape, animateCfg) {\n  var fillOpacity = Util.isNil(shape.attr('fillOpacity')) ? 1 : shape.attr('fillOpacity');\n  var strokeOpacity = Util.isNil(shape.attr('strokeOpacity')) ? 1 : shape.attr('strokeOpacity');\n  shape.attr('fillOpacity', 0);\n  shape.attr('strokeOpacity', 0);\n  var endState = {\n    fillOpacity: fillOpacity,\n    strokeOpacity: strokeOpacity\n  };\n  Helpers.doAnimation(shape, endState, animateCfg);\n}\n\nmodule.exports = {\n  // waveIn,\n  // scaleInX,\n  // scaleInY,\n  fadeIn: fadeIn\n};\n\n/***/ }),\n/* 136 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Group animate functions\n * @author sima.zhang1990@gmail.com\n */\nvar Util = __webpack_require__(103);\n\nvar Helper = __webpack_require__(28);\n\nvar _require = __webpack_require__(5),\n    Shape = _require.Shape;\n\nfunction _groupScaleIn(container, animateCfg, coord, zeroY, type) {\n  var _Util$getCoordInfo = Util.getCoordInfo(coord),\n      start = _Util$getCoordInfo.start,\n      end = _Util$getCoordInfo.end,\n      width = _Util$getCoordInfo.width,\n      height = _Util$getCoordInfo.height;\n\n  var x;\n  var y;\n  var clip = new Shape.Rect({\n    attrs: {\n      x: start.x,\n      y: end.y,\n      width: width,\n      height: height\n    }\n  });\n\n  if (type === 'y') {\n    x = start.x + width / 2;\n    y = zeroY.y < start.y ? zeroY.y : start.y;\n  } else if (type === 'x') {\n    x = zeroY.x > start.x ? zeroY.x : start.x;\n    y = start.y + height / 2;\n  } else if (type === 'xy') {\n    if (coord.isPolar) {\n      x = coord.center.x;\n      y = coord.center.y;\n    } else {\n      x = (start.x + end.x) / 2;\n      y = (start.y + end.y) / 2;\n    }\n  }\n\n  var endMatrix = Util.getScaledMatrix(clip, [x, y], type);\n  clip.isClip = true;\n  clip.endState = {\n    matrix: endMatrix\n  };\n  clip.set('canvas', container.get('canvas'));\n  container.attr('clip', clip);\n\n  var onEnd = function onEnd() {\n    container.attr('clip', null);\n    clip.remove(true);\n  };\n\n  Util.doAnimation(clip, clip.endState, animateCfg, onEnd);\n}\n\nfunction _shapeScale(container, animateCfg, type) {\n  var shapes = container.get('children');\n  var x;\n  var y;\n  var endMatrix;\n\n  for (var i = 0, len = shapes.length; i < len; i++) {\n    var shape = shapes[i];\n    var box = shape.getBBox();\n    x = (box.minX + box.maxX) / 2;\n    y = (box.minY + box.maxY) / 2;\n    endMatrix = Util.getScaledMatrix(shape, [x, y], type);\n    Util.doAnimation(shape, {\n      matrix: endMatrix\n    }, animateCfg);\n  }\n}\n\nfunction groupScaleInX(container, animateCfg, coord, zeroY) {\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'x');\n}\n\nfunction groupScaleInY(container, animateCfg, coord, zeroY) {\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'y');\n}\n\nfunction groupScaleInXY(container, animateCfg, coord, zeroY) {\n  _groupScaleIn(container, animateCfg, coord, zeroY, 'xy');\n}\n\nfunction shapesScaleInX(container, animateCfg) {\n  _shapeScale(container, animateCfg, 'x');\n}\n\nfunction shapesScaleInY(container, animateCfg) {\n  _shapeScale(container, animateCfg, 'y');\n}\n\nfunction shapesScaleInXY(container, animateCfg) {\n  _shapeScale(container, animateCfg, 'xy');\n}\n\nfunction groupWaveIn(container, animateCfg, coord) {\n  var clip = Helper.getClip(coord);\n  clip.set('canvas', container.get('canvas'));\n  container.attr('clip', clip);\n\n  var onEnd = function onEnd() {\n    container.attr('clip', null);\n    clip.remove(true);\n  };\n\n  var endState = {};\n\n  if (coord.isPolar) {\n    var startAngle = coord.startAngle,\n        endAngle = coord.endAngle;\n    endState.endAngle = endAngle;\n    clip.attr('endAngle', startAngle);\n  } else {\n    var start = coord.start,\n        end = coord.end;\n    var width = Math.abs(start.x - end.x);\n    var height = Math.abs(start.y - end.y);\n\n    if (coord.isTransposed) {\n      clip.attr('height', 0);\n      endState.height = height;\n    } else {\n      clip.attr('width', 0);\n      endState.width = width;\n    }\n  }\n\n  Util.doAnimation(clip, endState, animateCfg, onEnd);\n}\n\nmodule.exports = {\n  groupWaveIn: groupWaveIn,\n  groupScaleInX: groupScaleInX,\n  groupScaleInY: groupScaleInY,\n  groupScaleInXY: groupScaleInXY,\n  shapesScaleInX: shapesScaleInX,\n  shapesScaleInY: shapesScaleInY,\n  shapesScaleInXY: shapesScaleInXY\n};\n\n/***/ }),\n/* 137 */,\n/* 138 */,\n/* 139 */,\n/* 140 */,\n/* 141 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Default, without interactins\n */\nvar F2 = __webpack_require__(45);\n\n__webpack_require__(105);\n\n__webpack_require__(93);\n\n__webpack_require__(98); // polar coordinate\n\n\n__webpack_require__(114); // the axis for polar coordinate\n\n\n__webpack_require__(115); // timeCat scale\n\n\n__webpack_require__(119);\n\n__webpack_require__(120);\n\n__webpack_require__(121);\n\n__webpack_require__(122);\n\n__webpack_require__(123);\n\n__webpack_require__(124);\n\n__webpack_require__(125);\n\nvar Tooltip = __webpack_require__(126);\n\nvar Guide = __webpack_require__(129);\n\nvar Legend = __webpack_require__(130);\n\nvar Animation = __webpack_require__(131);\n\nF2.Animate = __webpack_require__(102); // register plugins\n\nF2.Chart.plugins.register([Tooltip, Legend, Guide, Animation]);\nmodule.exports = F2;\n\n/***/ })\n/******/ ]);\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzk5LmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2YyL2J1aWxkL2YyLmpzPzIwOTUiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiRjJcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiRjJcIl0gPSBmYWN0b3J5KCk7XG59KSh0aGlzLCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4vKioqKioqLyBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4vKioqKioqLyBcdFx0XHRcdGdldDogZ2V0dGVyXG4vKioqKioqLyBcdFx0XHR9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMTQxKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFV0aWxpdHkgZm9yIEYyXG4gKiBAYXV0aG9yIGR4cTYxMyBAZ21haWwuY29tXG4gKiBAYXV0aG9yIHNpbWEuemhhbmcxOTkwQGdtYWlsLmNvbVxuICovXG52YXIgRG9tVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oNDcpO1xuXG52YXIgVXRpbCA9IHtcbiAgdXBwZXJGaXJzdDogX193ZWJwYWNrX3JlcXVpcmVfXyg0OCksXG4gIGxvd2VyRmlyc3Q6IF9fd2VicGFja19yZXF1aXJlX18oNDkpLFxuICBpc1N0cmluZzogX193ZWJwYWNrX3JlcXVpcmVfXyg1MCksXG4gIGlzTnVtYmVyOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUxKSxcbiAgaXNCb29sZWFuOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKSxcbiAgaXNGdW5jdGlvbjogX193ZWJwYWNrX3JlcXVpcmVfXyg1MyksXG4gIGlzRGF0ZTogX193ZWJwYWNrX3JlcXVpcmVfXyg1NCksXG4gIGlzQXJyYXk6IF9fd2VicGFja19yZXF1aXJlX18oMjApLFxuICBpc05pbDogX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gIGlzT2JqZWN0OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSxcbiAgaXNQbGFpbk9iamVjdDogX193ZWJwYWNrX3JlcXVpcmVfXygzMiksXG4gIGRlZXBNaXg6IF9fd2VicGFja19yZXF1aXJlX18oNTYpLFxuICBtaXg6IF9fd2VicGFja19yZXF1aXJlX18oNTcpLFxuICBlYWNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKSxcbiAgdW5pcTogX193ZWJwYWNrX3JlcXVpcmVfXyg1OCksXG4gIGlzT2JqZWN0VmFsdWVFcXVhbDogZnVuY3Rpb24gaXNPYmplY3RWYWx1ZUVxdWFsKGEsIGIpIHtcbiAgICAvLyBmb3IgdnVlLmpzXG4gICAgYSA9IE9iamVjdC5hc3NpZ24oe30sIGEpO1xuICAgIGIgPSBPYmplY3QuYXNzaWduKHt9LCBiKTtcbiAgICB2YXIgYVByb3BzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSk7XG4gICAgdmFyIGJQcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIpO1xuXG4gICAgaWYgKGFQcm9wcy5sZW5ndGggIT09IGJQcm9wcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYVByb3BzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcHJvcE5hbWUgPSBhUHJvcHNbaV07XG5cbiAgICAgIGlmIChhW3Byb3BOYW1lXSAhPT0gYltwcm9wTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICB3cmFwQmVoYXZpb3I6IGZ1bmN0aW9uIHdyYXBCZWhhdmlvcihvYmosIGFjdGlvbikge1xuICAgIGlmIChvYmpbJ193cmFwXycgKyBhY3Rpb25dKSB7XG4gICAgICByZXR1cm4gb2JqWydfd3JhcF8nICsgYWN0aW9uXTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kID0gZnVuY3Rpb24gbWV0aG9kKGUpIHtcbiAgICAgIG9ialthY3Rpb25dKGUpO1xuICAgIH07XG5cbiAgICBvYmpbJ193cmFwXycgKyBhY3Rpb25dID0gbWV0aG9kO1xuICAgIHJldHVybiBtZXRob2Q7XG4gIH0sXG4gIGdldFdyYXBCZWhhdmlvcjogZnVuY3Rpb24gZ2V0V3JhcEJlaGF2aW9yKG9iaiwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIG9ialsnX3dyYXBfJyArIGFjdGlvbl07XG4gIH0sXG4gIHBhcnNlUGFkZGluZzogZnVuY3Rpb24gcGFyc2VQYWRkaW5nKHBhZGRpbmcpIHtcbiAgICB2YXIgdG9wO1xuICAgIHZhciByaWdodDtcbiAgICB2YXIgYm90dG9tO1xuICAgIHZhciBsZWZ0O1xuXG4gICAgaWYgKFV0aWwuaXNOdW1iZXIocGFkZGluZykgfHwgVXRpbC5pc1N0cmluZyhwYWRkaW5nKSkge1xuICAgICAgdG9wID0gYm90dG9tID0gbGVmdCA9IHJpZ2h0ID0gcGFkZGluZztcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNBcnJheShwYWRkaW5nKSkge1xuICAgICAgdG9wID0gcGFkZGluZ1swXTtcbiAgICAgIHJpZ2h0ID0gIVV0aWwuaXNOaWwocGFkZGluZ1sxXSkgPyBwYWRkaW5nWzFdIDogcGFkZGluZ1swXTtcbiAgICAgIGJvdHRvbSA9ICFVdGlsLmlzTmlsKHBhZGRpbmdbMl0pID8gcGFkZGluZ1syXSA6IHBhZGRpbmdbMF07XG4gICAgICBsZWZ0ID0gIVV0aWwuaXNOaWwocGFkZGluZ1szXSkgPyBwYWRkaW5nWzNdIDogcmlnaHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdO1xuICB9LFxuICBkaXJlY3Rpb25FbmFibGVkOiBmdW5jdGlvbiBkaXJlY3Rpb25FbmFibGVkKG1vZGUsIGRpcikge1xuICAgIGlmIChtb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbW9kZS5pbmRleE9mKGRpcikgIT09IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblV0aWwuQXJyYXkgPSB7XG4gIG1lcmdlOiBmdW5jdGlvbiBtZXJnZShkYXRhQXJyYXkpIHtcbiAgICB2YXIgcnN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YUFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByc3QgPSByc3QuY29uY2F0KGRhdGFBcnJheVtpXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfSxcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoZGF0YSwgbmFtZSkge1xuICAgIHZhciByc3QgPSBbXTtcbiAgICB2YXIgdG1wTWFwID0ge307XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpbbmFtZV07XG5cbiAgICAgIGlmICghVXRpbC5pc05pbCh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKCFVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgaWYgKCF0bXBNYXBbdmFsdWVdKSB7XG4gICAgICAgICAgICByc3QucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICB0bXBNYXBbdmFsdWVdID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVXRpbC5lYWNoKHZhbHVlLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICBpZiAoIXRtcE1hcFt2YWxdKSB7XG4gICAgICAgICAgICAgIHJzdC5wdXNoKHZhbCk7XG4gICAgICAgICAgICAgIHRtcE1hcFt2YWxdID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGZpcnN0VmFsdWU6IGZ1bmN0aW9uIGZpcnN0VmFsdWUoZGF0YSwgbmFtZSkge1xuICAgIHZhciByc3QgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBvYmogPSBkYXRhW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW25hbWVdO1xuXG4gICAgICBpZiAoIVV0aWwuaXNOaWwodmFsdWUpKSB7XG4gICAgICAgIGlmIChVdGlsLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcnN0ID0gdmFsdWVbMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnN0ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9LFxuICBncm91cDogZnVuY3Rpb24gZ3JvdXAoZGF0YSwgZmllbGRzLCBhcHBlbmRDb25kaXRpb25zKSB7XG4gICAgaWYgKGFwcGVuZENvbmRpdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgYXBwZW5kQ29uZGl0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICghZmllbGRzKSB7XG4gICAgICByZXR1cm4gW2RhdGFdO1xuICAgIH1cblxuICAgIHZhciBncm91cHMgPSBVdGlsLkFycmF5Lmdyb3VwVG9NYXAoZGF0YSwgZmllbGRzKTtcbiAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgIGlmIChmaWVsZHMubGVuZ3RoID09PSAxICYmIGFwcGVuZENvbmRpdGlvbnNbZmllbGRzWzBdXSkge1xuICAgICAgdmFyIHZhbHVlcyA9IGFwcGVuZENvbmRpdGlvbnNbZmllbGRzWzBdXTtcbiAgICAgIFV0aWwuZWFjaCh2YWx1ZXMsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9ICdfJyArIHZhbHVlO1xuICAgICAgICBhcnJheS5wdXNoKGdyb3Vwc1t2YWx1ZV0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgaW4gZ3JvdXBzKSB7XG4gICAgICAgIGFycmF5LnB1c2goZ3JvdXBzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXk7XG4gIH0sXG4gIGdyb3VwVG9NYXA6IGZ1bmN0aW9uIGdyb3VwVG9NYXAoZGF0YSwgZmllbGRzKSB7XG4gICAgaWYgKCFmaWVsZHMpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIDA6IGRhdGFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2socm93KSB7XG4gICAgICB2YXIgdW5pcXVlID0gJ18nO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGZpZWxkcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdW5pcXVlICs9IHJvd1tmaWVsZHNbaV1dICYmIHJvd1tmaWVsZHNbaV1dLnRvU3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1bmlxdWU7XG4gICAgfTtcblxuICAgIHZhciBncm91cHMgPSB7fTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcm93ID0gZGF0YVtpXTtcbiAgICAgIHZhciBrZXkgPSBjYWxsYmFjayhyb3cpO1xuXG4gICAgICBpZiAoZ3JvdXBzW2tleV0pIHtcbiAgICAgICAgZ3JvdXBzW2tleV0ucHVzaChyb3cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBzW2tleV0gPSBbcm93XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ3JvdXBzO1xuICB9LFxuICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhcnIsIG9iaikge1xuICAgIGlmICghYXJyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2Yob2JqKTtcblxuICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgIGFyci5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgfSxcbiAgZ2V0UmFuZ2U6IGZ1bmN0aW9uIGdldFJhbmdlKHZhbHVlcykge1xuICAgIGlmICghdmFsdWVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiAwLFxuICAgICAgICBtYXg6IDBcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluLmFwcGx5KG51bGwsIHZhbHVlcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9XG59O1xuVXRpbC5taXgoVXRpbCwgRG9tVXRpbCk7XG5tb2R1bGUuZXhwb3J0cyA9IFV0aWw7XG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVGhlbWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR2xvYmFsID0ge1xuICB2ZXJzaW9uOiAnMy40LjAnLFxuICBzY2FsZXM6IHt9LFxuICB3aWR0aFJhdGlvOiB7XG4gICAgY29sdW1uOiAxIC8gMixcbiAgICByb3NlOiAwLjk5OTk5OSxcbiAgICBtdWx0aXBsZVBpZTogMyAvIDRcbiAgfSxcbiAgbGluZURhc2g6IFs0LCA0XVxufTtcblxuR2xvYmFsLnNldFRoZW1lID0gZnVuY3Rpb24gKHRoZW1lKSB7XG4gIFV0aWwuZGVlcE1peCh0aGlzLCB0aGVtZSk7XG59O1xuXG5HbG9iYWwuc2V0VGhlbWUoVGhlbWUpO1xubW9kdWxlLmV4cG9ydHMgPSBHbG9iYWw7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgU2hhcGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9FbGVtZW50KSB7XG4gIF9pbmhlcml0c0xvb3NlKFNoYXBlLCBfRWxlbWVudCk7XG5cbiAgZnVuY3Rpb24gU2hhcGUoKSB7XG4gICAgcmV0dXJuIF9FbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTaGFwZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICB0aGlzLl9hdHRycyA9IHtcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBkZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNTaGFwZTogdHJ1ZSxcbiAgICAgIGF0dHJzOiB7fVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFR5cGUgPSBmdW5jdGlvbiBnZXRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRycy50eXBlO1xuICB9O1xuXG4gIF9wcm90by5kcmF3SW5uZXIgPSBmdW5jdGlvbiBkcmF3SW5uZXIoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLmdldCgnYXR0cnMnKTtcbiAgICBzZWxmLmNyZWF0ZVBhdGgoY29udGV4dCk7XG4gICAgdmFyIG9yaWdpbk9wYWNpdHkgPSBjb250ZXh0Lmdsb2JhbEFscGhhO1xuXG4gICAgaWYgKHNlbGYuaGFzRmlsbCgpKSB7XG4gICAgICB2YXIgZmlsbE9wYWNpdHkgPSBhdHRycy5maWxsT3BhY2l0eTtcblxuICAgICAgaWYgKCFVdGlsLmlzTmlsKGZpbGxPcGFjaXR5KSAmJiBmaWxsT3BhY2l0eSAhPT0gMSkge1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gZmlsbE9wYWNpdHk7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gb3JpZ2luT3BhY2l0eTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxmLmhhc1N0cm9rZSgpKSB7XG4gICAgICB2YXIgbGluZVdpZHRoID0gYXR0cnMubGluZVdpZHRoO1xuXG4gICAgICBpZiAobGluZVdpZHRoID4gMCkge1xuICAgICAgICB2YXIgc3Ryb2tlT3BhY2l0eSA9IGF0dHJzLnN0cm9rZU9wYWNpdHk7XG5cbiAgICAgICAgaWYgKCFVdGlsLmlzTmlsKHN0cm9rZU9wYWNpdHkpICYmIHN0cm9rZU9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgICBjb250ZXh0Lmdsb2JhbEFscGhhID0gc3Ryb2tlT3BhY2l0eTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5nZXRCQm94ID0gZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICB2YXIgYmJveCA9IHRoaXMuX2F0dHJzLmJib3g7XG5cbiAgICBpZiAoIWJib3gpIHtcbiAgICAgIGJib3ggPSB0aGlzLmNhbGN1bGF0ZUJveCgpO1xuXG4gICAgICBpZiAoYmJveCkge1xuICAgICAgICBiYm94LnggPSBiYm94Lm1pblg7XG4gICAgICAgIGJib3gueSA9IGJib3gubWluWTtcbiAgICAgICAgYmJveC53aWR0aCA9IGJib3gubWF4WCAtIGJib3gubWluWDtcbiAgICAgICAgYmJveC5oZWlnaHQgPSBiYm94Lm1heFkgLSBiYm94Lm1pblk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2F0dHJzLmJib3ggPSBiYm94O1xuICAgIH1cblxuICAgIHJldHVybiBiYm94O1xuICB9O1xuXG4gIF9wcm90by5jYWxjdWxhdGVCb3ggPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKCkge307XG5cbiAgcmV0dXJuIFNoYXBlO1xufShFbGVtZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaGFwZTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8qKlxuICogMiBEaW1lbnNpb25hbCBWZWN0b3JcbiAqIEBtb2R1bGUgdmVjdG9yMlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcsIGVtcHR5IHZlY3RvcjJcbiAgICpcbiAgICogQHJldHVybiB7dmVjdG9yMn0gYSBuZXcgMkQgdmVjdG9yXG4gICAqL1xuICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICByZXR1cm4gWzAsIDBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWN0b3IyXG4gICAqXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdiB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiB2XG4gICAqL1xuICBsZW5ndGg6IGZ1bmN0aW9uIGxlbmd0aCh2KSB7XG4gICAgdmFyIHggPSB2WzBdO1xuICAgIHZhciB5ID0gdlsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgYSB2ZWN0b3IyXG4gICAqXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdiB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gICAqIEByZXR1cm4ge3ZlY3RvcjJ9IG91dFxuICAgKi9cbiAgbm9ybWFsaXplOiBmdW5jdGlvbiBub3JtYWxpemUob3V0LCB2KSB7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoKHYpO1xuXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgb3V0WzBdID0gMDtcbiAgICAgIG91dFsxXSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dFswXSA9IHZbMF0gLyBsZW47XG4gICAgICBvdXRbMV0gPSB2WzFdIC8gbGVuO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgdHdvIHZlY3RvcjInc1xuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge3ZlY3RvcjJ9IG91dFxuICAgKi9cbiAgYWRkOiBmdW5jdGlvbiBhZGQob3V0LCB2MSwgdjIpIHtcbiAgICBvdXRbMF0gPSB2MVswXSArIHYyWzBdO1xuICAgIG91dFsxXSA9IHYxWzFdICsgdjJbMV07XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogU3VidHJhY3RzIHZlY3RvciB2MiBmcm9tIHZlY3RvciB2MVxuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge3ZlY3RvcjJ9IG91dFxuICAgKi9cbiAgc3ViOiBmdW5jdGlvbiBzdWIob3V0LCB2MSwgdjIpIHtcbiAgICBvdXRbMF0gPSB2MVswXSAtIHYyWzBdO1xuICAgIG91dFsxXSA9IHYxWzFdIC0gdjJbMV07XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogU2NhbGVzIGEgdmVjdG9yMiBieSBhIHNjYWxhciBudW1iZXJcbiAgICpcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2IHRoZSB2ZWN0b3IgdG8gc2NhbGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHMgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAgICogQHJldHVybiB7dmVjdG9yMn0gb3V0XG4gICAqL1xuICBzY2FsZTogZnVuY3Rpb24gc2NhbGUob3V0LCB2LCBzKSB7XG4gICAgb3V0WzBdID0gdlswXSAqIHM7XG4gICAgb3V0WzFdID0gdlsxXSAqIHM7XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlY3RvcjInc1xuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgdjEgYW5kIHYyXG4gICAqL1xuICBkb3Q6IGZ1bmN0aW9uIGRvdCh2MSwgdjIpIHtcbiAgICByZXR1cm4gdjFbMF0gKiB2MlswXSArIHYxWzFdICogdjJbMV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGRpcmVjdGlvbiBvZiB0d28gdmVjdG9yMidzXG4gICAqXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjEgdGhlIGZpcnN0IG9wZXJhbmRcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2MiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gdGhlIGRpcmVjdGlvbiBvZiB2MSBhbmQgdjJcbiAgICovXG4gIGRpcmVjdGlvbjogZnVuY3Rpb24gZGlyZWN0aW9uKHYxLCB2Mikge1xuICAgIHJldHVybiB2MVswXSAqIHYyWzFdIC0gdjJbMF0gKiB2MVsxXTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgYW5nbGUgb2YgdHdvIHZlY3RvcjInc1xuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgb2YgdjEgYW5kIHYyXG4gICAqL1xuICBhbmdsZTogZnVuY3Rpb24gYW5nbGUodjEsIHYyKSB7XG4gICAgdmFyIHRoZXRhID0gdGhpcy5kb3QodjEsIHYyKSAvICh0aGlzLmxlbmd0aCh2MSkgKiB0aGlzLmxlbmd0aCh2MikpO1xuICAgIHJldHVybiBNYXRoLmFjb3ModGhldGEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBhbmdsZSBvZiB0d28gdmVjdG9yMidzIHdpdGggZGlyZWN0aW9uXG4gICAqXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjEgdGhlIGZpcnN0IG9wZXJhbmRcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2MiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBkaXJlY3Rpb24gdGhlIGRpcmVjdGlvbiBvZiB0d28gdmVjdG9yMidzXG4gICAqIEByZXR1cm4ge051bWJlcn0gYW5nbGUgb2YgdjEgYW5kIHYyXG4gICAqL1xuICBhbmdsZVRvOiBmdW5jdGlvbiBhbmdsZVRvKHYxLCB2MiwgZGlyZWN0aW9uKSB7XG4gICAgdmFyIGFuZ2xlID0gdGhpcy5hbmdsZSh2MSwgdjIpO1xuICAgIHZhciBhbmdsZUxhcmdlVGhhblBJID0gdGhpcy5kaXJlY3Rpb24odjEsIHYyKSA+PSAwO1xuXG4gICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgaWYgKGFuZ2xlTGFyZ2VUaGFuUEkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguUEkgKiAyIC0gYW5nbGU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhbmdsZTtcbiAgICB9XG5cbiAgICBpZiAoYW5nbGVMYXJnZVRoYW5QSSkge1xuICAgICAgcmV0dXJuIGFuZ2xlO1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLlBJICogMiAtIGFuZ2xlO1xuICB9LFxuXG4gIC8qKlxuICAgKiB3aGV0aGVyIGEgdmVjdG9yMiBpcyB6ZXJvIHZlY3RvclxuICAgKlxuICAgKiBAcGFyYW0gIHt2ZWN0b3IyfSB2IHZlY3RvciB0byBjYWxjdWxhdGVcbiAgICogQHJldHVybiB7Qm9vbGVhbn0gICBpcyBvciBub3QgYSB6ZXJvIHZlY3RvclxuICAgKi9cbiAgemVybzogZnVuY3Rpb24gemVybyh2KSB7XG4gICAgcmV0dXJuIHZbMF0gPT09IDAgJiYgdlsxXSA9PT0gMDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlY3RvcjInc1xuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge051bWJlcn0gZGlzdGFuY2UgYmV0d2VlbiBhIGFuZCBiXG4gICAqL1xuICBkaXN0YW5jZTogZnVuY3Rpb24gZGlzdGFuY2UodjEsIHYyKSB7XG4gICAgdmFyIHggPSB2MlswXSAtIHYxWzBdO1xuICAgIHZhciB5ID0gdjJbMV0gLSB2MVsxXTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHZlY3RvcjIgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2IHZlY3RvciB0byBjbG9uZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gYSBuZXcgMkQgdmVjdG9yXG4gICAqL1xuICBjbG9uZTogZnVuY3Rpb24gY2xvbmUodikge1xuICAgIHJldHVybiBbdlswXSwgdlsxXV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbWluaW11bSBvZiB0d28gdmVjdG9yMidzXG4gICAqXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjEgdGhlIGZpcnN0IG9wZXJhbmRcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2MiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAgICogQHJldHVybiB7dmVjdG9yMn0gb3V0XG4gICAqL1xuICBtaW46IGZ1bmN0aW9uIG1pbihvdXQsIHYxLCB2Mikge1xuICAgIG91dFswXSA9IE1hdGgubWluKHYxWzBdLCB2MlswXSk7XG4gICAgb3V0WzFdID0gTWF0aC5taW4odjFbMV0sIHYyWzFdKTtcbiAgICByZXR1cm4gb3V0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIG1heGltdW0gb2YgdHdvIHZlY3RvcjInc1xuICAgKlxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICAgKiBAcGFyYW0ge3ZlY3RvcjJ9IHYxIHRoZSBmaXJzdCBvcGVyYW5kXG4gICAqIEBwYXJhbSB7dmVjdG9yMn0gdjIgdGhlIHNlY29uZCBvcGVyYW5kXG4gICAqIEByZXR1cm4ge3ZlY3RvcjJ9IG91dFxuICAgKi9cbiAgbWF4OiBmdW5jdGlvbiBtYXgob3V0LCB2MSwgdjIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heCh2MVswXSwgdjJbMF0pO1xuICAgIG91dFsxXSA9IE1hdGgubWF4KHYxWzFdLCB2MlsxXSk7XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGUgdmVjdG9yMiB3aXRoIGEgbWF0MmRcbiAgICpcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAgICogQHBhcmFtIHt2ZWN0b3IyfSB2IHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gICAqIEBwYXJhbSB7bWF0MmR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gICAqIEByZXR1cm4ge3ZlY3RvcjJ9IG91dFxuICAgKi9cbiAgdHJhbnNmb3JtTWF0MmQ6IGZ1bmN0aW9uIHRyYW5zZm9ybU1hdDJkKG91dCwgdiwgbSkge1xuICAgIHZhciB4ID0gdlswXTtcbiAgICB2YXIgeSA9IHZbMV07XG4gICAgb3V0WzBdID0gbVswXSAqIHggKyBtWzJdICogeSArIG1bNF07XG4gICAgb3V0WzFdID0gbVsxXSAqIHggKyBtWzNdICogeSArIG1bNV07XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgZWFjaCA9IGZ1bmN0aW9uIGVhY2goZWxlbWVudHMsIGZ1bmMpIHtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByc3QgPSB2b2lkIDA7XG5cbiAgaWYgKGlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2ldLCBpKTtcblxuICAgICAgaWYgKHJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGVsZW1lbnRzKSkge1xuICAgIGZvciAodmFyIGsgaW4gZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2tdLCBrKTtcblxuICAgICAgICBpZiAocnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhY2g7XG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRyA9IHtcbiAgQ2FudmFzOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KSxcbiAgR3JvdXA6IF9fd2VicGFja19yZXF1aXJlX18oMzYpLFxuICBTaGFwZTogX193ZWJwYWNrX3JlcXVpcmVfXygyKSxcbiAgTWF0cml4OiBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSxcbiAgVmVjdG9yMjogX193ZWJwYWNrX3JlcXVpcmVfXygzKVxufTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg4MSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oODIpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDgzKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg4NCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oODUpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDg2KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg4Nyk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oODgpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDg5KTtcblxubW9kdWxlLmV4cG9ydHMgPSBHO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KTtcblxudmFyIEdST1VQX0FUVFJTID0gWydjb2xvcicsICdzaXplJywgJ3NoYXBlJ107XG52YXIgRklFTERfT1JJR0lOID0gJ19vcmlnaW4nO1xudmFyIEZJRUxEX09SSUdJTl9ZID0gJ19vcmlnaW5ZJztcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBBdHRyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2NCk7XG5cbnZhciBHZW9tZXRyeVNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIEFkanVzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xuXG5mdW5jdGlvbiBwYXJzZUZpZWxkcyhmaWVsZCkge1xuICBpZiAoVXRpbC5pc0FycmF5KGZpZWxkKSkge1xuICAgIHJldHVybiBmaWVsZDtcbiAgfVxuXG4gIGlmIChVdGlsLmlzU3RyaW5nKGZpZWxkKSkge1xuICAgIHJldHVybiBmaWVsZC5zcGxpdCgnKicpO1xuICB9XG5cbiAgcmV0dXJuIFtmaWVsZF07XG59XG4vKipcbiAqIFRoZSBwYXJlbnQgY2xhc3MgZm9yIEdlb21ldHJ5XG4gKiBAY2xhc3MgR2VvbVxuICovXG5cblxudmFyIEdlb20gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEdlb20sIF9CYXNlKTtcblxuICBmdW5jdGlvbiBHZW9tKCkge1xuICAgIHJldHVybiBfQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gR2VvbS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIGdlb21ldHJ5IHR5cGVcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHR5cGU6IG51bGwsXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGRhdGEgb2YgZ2VvbWV0cnlcbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgZGF0YTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgYXR0cnMgb2YgZ2VvLGV0cnlcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGF0dHJzOiB7fSxcbiAgICAgIHNjYWxlczoge30sXG5cbiAgICAgIC8qKlxuICAgICAgICogZ3JvdXAgZm9yIHN0b3JpbmcgdGhlIHNoYXBlc1xuICAgICAgICogQHR5cGUge0NhbnZhc31cbiAgICAgICAqL1xuICAgICAgY29udGFpbmVyOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0eWxlIG9wdGlvbnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHN0eWxlT3B0aW9uczogbnVsbCxcbiAgICAgIGNoYXJ0OiBudWxsLFxuICAgICAgc2hhcGVUeXBlOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiB3ZXRoZXIgdG8gZ2VuZXJhdGUga2V5IHBvaW50cyBmb3IgZWFjaCBzaGFwZVxuICAgICAgICogQHByb3RlY3RlZFxuICAgICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGdlbmVyYXRlUG9pbnRzOiBmYWxzZSxcbiAgICAgIGF0dHJPcHRpb25zOiB7fSxcbiAgICAgIHNvcnRhYmxlOiBmYWxzZSxcbiAgICAgIHN0YXJ0T25aZXJvOiB0cnVlLFxuICAgICAgdmlzaWJsZTogdHJ1ZSxcbiAgICAgIGNvbm5lY3ROdWxsczogZmFsc2VcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9pbml0QXR0cnMoKTtcblxuICAgIHZhciBkYXRhQXJyYXkgPSBzZWxmLl9wcm9jZXNzRGF0YSgpO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdhZGp1c3QnKSkge1xuICAgICAgc2VsZi5fYWRqdXN0RGF0YShkYXRhQXJyYXkpO1xuICAgIH1cblxuICAgIHNlbGYuc2V0KCdkYXRhQXJyYXknLCBkYXRhQXJyYXkpO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0R3JvdXBTY2FsZXMgPSBmdW5jdGlvbiBfZ2V0R3JvdXBTY2FsZXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzY2FsZXMgPSBbXTtcbiAgICBVdGlsLmVhY2goR1JPVVBfQVRUUlMsIGZ1bmN0aW9uIChhdHRyTmFtZSkge1xuICAgICAgdmFyIGF0dHIgPSBzZWxmLmdldEF0dHIoYXR0ck5hbWUpO1xuXG4gICAgICBpZiAoYXR0cikge1xuICAgICAgICB2YXIgYXR0clNjYWxlcyA9IGF0dHIuc2NhbGVzO1xuICAgICAgICBVdGlsLmVhY2goYXR0clNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICAgICAgaWYgKHNjYWxlICYmIHNjYWxlLmlzQ2F0ZWdvcnkgJiYgc2NhbGVzLmluZGV4T2Yoc2NhbGUpID09PSAtMSkge1xuICAgICAgICAgICAgc2NhbGVzLnB1c2goc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNjYWxlcztcbiAgfTtcblxuICBfcHJvdG8uX2dyb3VwRGF0YSA9IGZ1bmN0aW9uIF9ncm91cERhdGEoZGF0YSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29sRGVmcyA9IHNlbGYuZ2V0KCdjb2xEZWZzJyk7XG5cbiAgICB2YXIgZ3JvdXBTY2FsZXMgPSBzZWxmLl9nZXRHcm91cFNjYWxlcygpO1xuXG4gICAgaWYgKGdyb3VwU2NhbGVzLmxlbmd0aCkge1xuICAgICAgdmFyIGFwcGVuZENvbmRpdGlvbnMgPSB7fTtcbiAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgVXRpbC5lYWNoKGdyb3VwU2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgICAgIG5hbWVzLnB1c2goZmllbGQpO1xuXG4gICAgICAgIGlmIChjb2xEZWZzICYmIGNvbERlZnNbZmllbGRdICYmIGNvbERlZnNbZmllbGRdLnZhbHVlcykge1xuICAgICAgICAgIC8vIHVzZXJzIGhhdmUgZGVmaW5lZFxuICAgICAgICAgIGFwcGVuZENvbmRpdGlvbnNbc2NhbGUuZmllbGRdID0gY29sRGVmc1tmaWVsZF0udmFsdWVzO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBVdGlsLkFycmF5Lmdyb3VwKGRhdGEsIG5hbWVzLCBhcHBlbmRDb25kaXRpb25zKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW2RhdGFdO1xuICB9O1xuXG4gIF9wcm90by5fc2V0QXR0ck9wdGlvbnMgPSBmdW5jdGlvbiBfc2V0QXR0ck9wdGlvbnMoYXR0ck5hbWUsIGF0dHJDZmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0KCdhdHRyT3B0aW9ucycpO1xuICAgIG9wdGlvbnNbYXR0ck5hbWVdID0gYXR0ckNmZztcbiAgfTtcblxuICBfcHJvdG8uX2NyZWF0ZUF0dHJPcHRpb24gPSBmdW5jdGlvbiBfY3JlYXRlQXR0ck9wdGlvbihhdHRyTmFtZSwgZmllbGQsIGNmZywgZGVmYXVsdFZhbHVlcykge1xuICAgIHZhciBhdHRyQ2ZnID0ge307XG4gICAgYXR0ckNmZy5maWVsZCA9IGZpZWxkO1xuXG4gICAgaWYgKGNmZykge1xuICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjZmcpKSB7XG4gICAgICAgIGF0dHJDZmcuY2FsbGJhY2sgPSBjZmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRyQ2ZnLnZhbHVlcyA9IGNmZztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYXR0ckNmZy52YWx1ZXMgPSBkZWZhdWx0VmFsdWVzO1xuICAgIH1cblxuICAgIHRoaXMuX3NldEF0dHJPcHRpb25zKGF0dHJOYW1lLCBhdHRyQ2ZnKTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRBdHRycyA9IGZ1bmN0aW9uIF9pbml0QXR0cnMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuZ2V0KCdhdHRycycpO1xuICAgIHZhciBhdHRyT3B0aW9ucyA9IHNlbGYuZ2V0KCdhdHRyT3B0aW9ucycpO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuXG4gICAgZm9yICh2YXIgdHlwZSBpbiBhdHRyT3B0aW9ucykge1xuICAgICAgaWYgKGF0dHJPcHRpb25zLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgICAgIHZhciBvcHRpb24gPSBhdHRyT3B0aW9uc1t0eXBlXTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZSA9IFV0aWwudXBwZXJGaXJzdCh0eXBlKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHBhcnNlRmllbGRzKG9wdGlvbi5maWVsZCk7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICBvcHRpb24uY29vcmQgPSBjb29yZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY2FsZXMgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmllbGRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIGZpZWxkID0gZmllbGRzW2ldO1xuXG4gICAgICAgICAgdmFyIHNjYWxlID0gc2VsZi5fY3JlYXRlU2NhbGUoZmllbGQpO1xuXG4gICAgICAgICAgc2NhbGVzLnB1c2goc2NhbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdwb3NpdGlvbicpIHtcbiAgICAgICAgICB2YXIgeVNjYWxlID0gc2NhbGVzWzFdO1xuXG4gICAgICAgICAgaWYgKGNvb3JkLnR5cGUgPT09ICdwb2xhcicgJiYgY29vcmQudHJhbnNwb3NlZCAmJiBzZWxmLmhhc0FkanVzdCgnc3RhY2snKSkge1xuICAgICAgICAgICAgaWYgKHlTY2FsZS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHlTY2FsZS5jaGFuZ2Uoe1xuICAgICAgICAgICAgICAgIG5pY2U6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgICAgICBtYXg6IE1hdGgubWF4LmFwcGx5KG51bGwsIHlTY2FsZS52YWx1ZXMpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbi5zY2FsZXMgPSBzY2FsZXM7XG4gICAgICAgIHZhciBhdHRyID0gbmV3IEF0dHJbY2xhc3NOYW1lXShvcHRpb24pO1xuICAgICAgICBhdHRyc1t0eXBlXSA9IGF0dHI7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fY3JlYXRlU2NhbGUgPSBmdW5jdGlvbiBfY3JlYXRlU2NhbGUoZmllbGQpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5nZXQoJ3NjYWxlcycpO1xuICAgIHZhciBzY2FsZSA9IHNjYWxlc1tmaWVsZF07XG5cbiAgICBpZiAoIXNjYWxlKSB7XG4gICAgICBzY2FsZSA9IHRoaXMuZ2V0KCdjaGFydCcpLmNyZWF0ZVNjYWxlKGZpZWxkKTtcbiAgICAgIHNjYWxlc1tmaWVsZF0gPSBzY2FsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGU7XG4gIH07XG5cbiAgX3Byb3RvLl9wcm9jZXNzRGF0YSA9IGZ1bmN0aW9uIF9wcm9jZXNzRGF0YSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldCgnZGF0YScpO1xuICAgIHZhciBkYXRhQXJyYXkgPSBbXTtcblxuICAgIHZhciBncm91cGVkQXJyYXkgPSB0aGlzLl9ncm91cERhdGEoZGF0YSk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBlZEFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgc3ViRGF0YSA9IGdyb3VwZWRBcnJheVtpXTtcblxuICAgICAgdmFyIHRlbXBEYXRhID0gc2VsZi5fc2F2ZU9yaWdpbihzdWJEYXRhKTtcblxuICAgICAgaWYgKHRoaXMuaGFzQWRqdXN0KCdkb2RnZScpKSB7XG4gICAgICAgIHNlbGYuX251bWJlcmljKHRlbXBEYXRhKTtcbiAgICAgIH1cblxuICAgICAgZGF0YUFycmF5LnB1c2godGVtcERhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhQXJyYXk7XG4gIH07XG5cbiAgX3Byb3RvLl9zYXZlT3JpZ2luID0gZnVuY3Rpb24gX3NhdmVPcmlnaW4oZGF0YSkge1xuICAgIHZhciByc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgb3JpZ2luID0gZGF0YVtpXTtcbiAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgZm9yICh2YXIgayBpbiBvcmlnaW4pIHtcbiAgICAgICAgb2JqW2tdID0gb3JpZ2luW2tdO1xuICAgICAgfVxuXG4gICAgICBvYmpbRklFTERfT1JJR0lOXSA9IG9yaWdpbjtcbiAgICAgIHJzdC5wdXNoKG9iaik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uX251bWJlcmljID0gZnVuY3Rpb24gX251bWJlcmljKGRhdGEpIHtcbiAgICB2YXIgcG9zaXRpb25BdHRyID0gdGhpcy5nZXRBdHRyKCdwb3NpdGlvbicpO1xuICAgIHZhciBzY2FsZXMgPSBwb3NpdGlvbkF0dHIuc2NhbGVzO1xuXG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBvYmogPSBkYXRhW2pdO1xuICAgICAgdmFyIGNvdW50ID0gTWF0aC5taW4oMiwgc2NhbGVzLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZXNbaV07XG5cbiAgICAgICAgaWYgKHNjYWxlLmlzQ2F0ZWdvcnkpIHtcbiAgICAgICAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICAgICAgICBvYmpbZmllbGRdID0gc2NhbGUudHJhbnNsYXRlKG9ialtmaWVsZF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fYWRqdXN0RGF0YSA9IGZ1bmN0aW9uIF9hZGp1c3REYXRhKGRhdGFBcnJheSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYWRqdXN0ID0gc2VsZi5nZXQoJ2FkanVzdCcpO1xuXG4gICAgaWYgKGFkanVzdCkge1xuICAgICAgdmFyIGFkanVzdFR5cGUgPSBVdGlsLnVwcGVyRmlyc3QoYWRqdXN0LnR5cGUpO1xuXG4gICAgICBpZiAoIUFkanVzdFthZGp1c3RUeXBlXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBzdXBwb3J0IHN1Y2ggYWRqdXN0IDogJyArIGFkanVzdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB4U2NhbGUgPSBzZWxmLmdldFhTY2FsZSgpO1xuICAgICAgdmFyIHlTY2FsZSA9IHNlbGYuZ2V0WVNjYWxlKCk7XG4gICAgICB2YXIgY2ZnID0gVXRpbC5taXgoe1xuICAgICAgICB4RmllbGQ6IHhTY2FsZS5maWVsZCxcbiAgICAgICAgeUZpZWxkOiB5U2NhbGUuZmllbGRcbiAgICAgIH0sIGFkanVzdCk7XG4gICAgICB2YXIgYWRqdXN0T2JqZWN0ID0gbmV3IEFkanVzdFthZGp1c3RUeXBlXShjZmcpO1xuICAgICAgYWRqdXN0T2JqZWN0LnByb2Nlc3NBZGp1c3QoZGF0YUFycmF5KTtcblxuICAgICAgaWYgKGFkanVzdFR5cGUgPT09ICdTdGFjaycpIHtcbiAgICAgICAgc2VsZi5fdXBkYXRlU3RhY2tSYW5nZSh5U2NhbGUuZmllbGQsIHlTY2FsZSwgZGF0YUFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVTdGFja1JhbmdlID0gZnVuY3Rpb24gX3VwZGF0ZVN0YWNrUmFuZ2UoZmllbGQsIHNjYWxlLCBkYXRhQXJyYXkpIHtcbiAgICB2YXIgbWVyZ2VBcnJheSA9IFV0aWwuQXJyYXkubWVyZ2UoZGF0YUFycmF5KTtcbiAgICB2YXIgbWluID0gc2NhbGUubWluO1xuICAgIHZhciBtYXggPSBzY2FsZS5tYXg7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWVyZ2VBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIG9iaiA9IG1lcmdlQXJyYXlbaV07XG4gICAgICB2YXIgdG1wTWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgb2JqW2ZpZWxkXSk7XG4gICAgICB2YXIgdG1wTWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgb2JqW2ZpZWxkXSk7XG5cbiAgICAgIGlmICh0bXBNaW4gPCBtaW4pIHtcbiAgICAgICAgbWluID0gdG1wTWluO1xuICAgICAgfVxuXG4gICAgICBpZiAodG1wTWF4ID4gbWF4KSB7XG4gICAgICAgIG1heCA9IHRtcE1heDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobWluIDwgc2NhbGUubWluIHx8IG1heCA+IHNjYWxlLm1heCkge1xuICAgICAgc2NhbGUuY2hhbmdlKHtcbiAgICAgICAgbWluOiBtaW4sXG4gICAgICAgIG1heDogbWF4XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9zb3J0ID0gZnVuY3Rpb24gX3NvcnQobWFwcGVkQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHhTY2FsZSA9IHNlbGYuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIGZpZWxkID0geFNjYWxlLmZpZWxkLFxuICAgICAgICB0eXBlID0geFNjYWxlLnR5cGU7XG5cbiAgICBpZiAodHlwZSAhPT0gJ2lkZW50aXR5JyAmJiB4U2NhbGUudmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIFV0aWwuZWFjaChtYXBwZWRBcnJheSwgZnVuY3Rpb24gKGl0ZW1BcnIpIHtcbiAgICAgICAgaXRlbUFyci5zb3J0KGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICd0aW1lQ2F0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHhTY2FsZS5fdG9UaW1lU3RhbXAob2JqMVtGSUVMRF9PUklHSU5dW2ZpZWxkXSkgLSB4U2NhbGUuX3RvVGltZVN0YW1wKG9iajJbRklFTERfT1JJR0lOXVtmaWVsZF0pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB4U2NhbGUudHJhbnNsYXRlKG9iajFbRklFTERfT1JJR0lOXVtmaWVsZF0pIC0geFNjYWxlLnRyYW5zbGF0ZShvYmoyW0ZJRUxEX09SSUdJTl1bZmllbGRdKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxmLnNldCgnaGFzU29ydGVkJywgdHJ1ZSk7XG4gICAgc2VsZi5zZXQoJ2RhdGFBcnJheScsIG1hcHBlZEFycmF5KTtcbiAgfTtcblxuICBfcHJvdG8ucGFpbnQgPSBmdW5jdGlvbiBwYWludCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGRhdGFBcnJheSA9IHNlbGYuZ2V0KCdkYXRhQXJyYXknKTtcbiAgICB2YXIgbWFwcGVkQXJyYXkgPSBbXTtcbiAgICB2YXIgc2hhcGVGYWN0b3J5ID0gc2VsZi5nZXRTaGFwZUZhY3RvcnkoKTtcbiAgICBzaGFwZUZhY3Rvcnkuc2V0Q29vcmQoc2VsZi5nZXQoJ2Nvb3JkJykpO1xuXG4gICAgc2VsZi5fYmVmb3JlTWFwcGluZyhkYXRhQXJyYXkpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGFBcnJheS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGRhdGEgPSBkYXRhQXJyYXlbaV07XG5cbiAgICAgIGlmIChkYXRhLmxlbmd0aCkge1xuICAgICAgICBkYXRhID0gc2VsZi5fbWFwcGluZyhkYXRhKTtcbiAgICAgICAgbWFwcGVkQXJyYXkucHVzaChkYXRhKTtcbiAgICAgICAgc2VsZi5kcmF3KGRhdGEsIHNoYXBlRmFjdG9yeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VsZi5zZXQoJ2RhdGFBcnJheScsIG1hcHBlZEFycmF5KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0U2hhcGVGYWN0b3J5ID0gZnVuY3Rpb24gZ2V0U2hhcGVGYWN0b3J5KCkge1xuICAgIHZhciBzaGFwZUZhY3RvcnkgPSB0aGlzLmdldCgnc2hhcGVGYWN0b3J5Jyk7XG5cbiAgICBpZiAoIXNoYXBlRmFjdG9yeSkge1xuICAgICAgdmFyIHNoYXBlVHlwZSA9IHRoaXMuZ2V0KCdzaGFwZVR5cGUnKTtcbiAgICAgIHNoYXBlRmFjdG9yeSA9IEdlb21ldHJ5U2hhcGUuZ2V0U2hhcGVGYWN0b3J5KHNoYXBlVHlwZSk7XG4gICAgICB0aGlzLnNldCgnc2hhcGVGYWN0b3J5Jywgc2hhcGVGYWN0b3J5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGVGYWN0b3J5O1xuICB9O1xuXG4gIF9wcm90by5fbWFwcGluZyA9IGZ1bmN0aW9uIF9tYXBwaW5nKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHlGaWVsZCA9IHNlbGYuZ2V0WVNjYWxlKCkuZmllbGQ7XG4gICAgdmFyIG1hcHBlZERhdGEgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3JkID0gZGF0YVtpXTtcbiAgICAgIHZhciBuZXdSZWNvcmQgPSB7fTtcbiAgICAgIG5ld1JlY29yZFtGSUVMRF9PUklHSU5dID0gcmVjb3JkW0ZJRUxEX09SSUdJTl07XG4gICAgICBuZXdSZWNvcmQucG9pbnRzID0gcmVjb3JkLnBvaW50czsgLy8g6YG/5YWNXG5cbiAgICAgIG5ld1JlY29yZFtGSUVMRF9PUklHSU5fWV0gPSByZWNvcmRbeUZpZWxkXTtcblxuICAgICAgZm9yICh2YXIgayBpbiBhdHRycykge1xuICAgICAgICBpZiAoYXR0cnMuaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICB2YXIgYXR0ciA9IGF0dHJzW2tdO1xuICAgICAgICAgIHZhciBuYW1lcyA9IGF0dHIubmFtZXM7XG5cbiAgICAgICAgICB2YXIgdmFsdWVzID0gc2VsZi5fZ2V0QXR0clZhbHVlcyhhdHRyLCByZWNvcmQpO1xuXG4gICAgICAgICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwLCBfbGVuID0gdmFsdWVzLmxlbmd0aDsgaiA8IF9sZW47IGorKykge1xuICAgICAgICAgICAgICB2YXIgdmFsID0gdmFsdWVzW2pdO1xuICAgICAgICAgICAgICB2YXIgbmFtZSA9IG5hbWVzW2pdO1xuICAgICAgICAgICAgICBuZXdSZWNvcmRbbmFtZV0gPSBVdGlsLmlzQXJyYXkodmFsKSAmJiB2YWwubGVuZ3RoID09PSAxID8gdmFsWzBdIDogdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdSZWNvcmRbbmFtZXNbMF1dID0gdmFsdWVzLmxlbmd0aCA9PT0gMSA/IHZhbHVlc1swXSA6IHZhbHVlcztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbWFwcGVkRGF0YS5wdXNoKG5ld1JlY29yZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBlZERhdGE7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRBdHRyVmFsdWVzID0gZnVuY3Rpb24gX2dldEF0dHJWYWx1ZXMoYXR0ciwgcmVjb3JkKSB7XG4gICAgdmFyIHNjYWxlcyA9IGF0dHIuc2NhbGVzO1xuICAgIHZhciBwYXJhbXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzY2FsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBzY2FsZSA9IHNjYWxlc1tpXTtcbiAgICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuXG4gICAgICBpZiAoc2NhbGUudHlwZSA9PT0gJ2lkZW50aXR5Jykge1xuICAgICAgICBwYXJhbXMucHVzaChzY2FsZS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucHVzaChyZWNvcmRbZmllbGRdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gYXR0ci5tYXBwaW5nLmFwcGx5KGF0dHIsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXR0clZhbHVlID0gZnVuY3Rpb24gZ2V0QXR0clZhbHVlKGF0dHJOYW1lLCByZWNvcmQpIHtcbiAgICB2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cihhdHRyTmFtZSk7XG4gICAgdmFyIHJzdCA9IG51bGw7XG5cbiAgICBpZiAoYXR0cikge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMuX2dldEF0dHJWYWx1ZXMoYXR0ciwgcmVjb3JkKTtcblxuICAgICAgcnN0ID0gdmFsdWVzWzBdO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLl9iZWZvcmVNYXBwaW5nID0gZnVuY3Rpb24gX2JlZm9yZU1hcHBpbmcoZGF0YUFycmF5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYuZ2V0KCdzb3J0YWJsZScpKSB7XG4gICAgICBzZWxmLl9zb3J0KGRhdGFBcnJheSk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZ2V0KCdnZW5lcmF0ZVBvaW50cycpKSB7XG4gICAgICBVdGlsLmVhY2goZGF0YUFycmF5LCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBzZWxmLl9nZW5lcmF0ZVBvaW50cyhkYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uaXNJbkNpcmNsZSA9IGZ1bmN0aW9uIGlzSW5DaXJjbGUoKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgcmV0dXJuIGNvb3JkICYmIGNvb3JkLmlzUG9sYXI7XG4gIH07XG5cbiAgX3Byb3RvLmdldENhbGxiYWNrQ2ZnID0gZnVuY3Rpb24gZ2V0Q2FsbGJhY2tDZmcoZmllbGRzLCBjZmcsIG9yaWdpbikge1xuICAgIGlmICghZmllbGRzKSB7XG4gICAgICByZXR1cm4gY2ZnO1xuICAgIH1cblxuICAgIHZhciB0bXBDZmcgPSB7fTtcbiAgICB2YXIgcGFyYW1zID0gZmllbGRzLm1hcChmdW5jdGlvbiAoZmllbGQpIHtcbiAgICAgIHJldHVybiBvcmlnaW5bZmllbGRdO1xuICAgIH0pO1xuICAgIFV0aWwuZWFjaChjZmcsIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHYpKSB7XG4gICAgICAgIHRtcENmZ1trXSA9IHYuYXBwbHkobnVsbCwgcGFyYW1zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRtcENmZ1trXSA9IHY7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRtcENmZztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RHJhd0NmZyA9IGZ1bmN0aW9uIGdldERyYXdDZmcob2JqKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpc0luQ2lyY2xlID0gc2VsZi5pc0luQ2lyY2xlKCk7XG4gICAgdmFyIGNmZyA9IHtcbiAgICAgIG9yaWdpbjogb2JqLFxuICAgICAgeDogb2JqLngsXG4gICAgICB5OiBvYmoueSxcbiAgICAgIGNvbG9yOiBvYmouY29sb3IsXG4gICAgICBzaXplOiBvYmouc2l6ZSxcbiAgICAgIHNoYXBlOiBvYmouc2hhcGUsXG4gICAgICBpc0luQ2lyY2xlOiBpc0luQ2lyY2xlLFxuICAgICAgb3BhY2l0eTogb2JqLm9wYWNpdHlcbiAgICB9O1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSBzZWxmLmdldCgnc3R5bGVPcHRpb25zJyk7XG5cbiAgICBpZiAoc3R5bGVPcHRpb25zICYmIHN0eWxlT3B0aW9ucy5zdHlsZSkge1xuICAgICAgY2ZnLnN0eWxlID0gc2VsZi5nZXRDYWxsYmFja0NmZyhzdHlsZU9wdGlvbnMuZmllbGRzLCBzdHlsZU9wdGlvbnMuc3R5bGUsIG9ialtGSUVMRF9PUklHSU5dKTtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5nZXQoJ2dlbmVyYXRlUG9pbnRzJykpIHtcbiAgICAgIGNmZy5wb2ludHMgPSBvYmoucG9pbnRzO1xuICAgIH1cblxuICAgIGlmIChpc0luQ2lyY2xlKSB7XG4gICAgICBjZmcuY2VudGVyID0gc2VsZi5nZXQoJ2Nvb3JkJykuY2VudGVyO1xuICAgIH1cblxuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGRhdGEsIHNoYXBlRmFjdG9yeSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZSgpO1xuICAgIFV0aWwuZWFjaChkYXRhLCBmdW5jdGlvbiAob2JqLCBpbmRleCkge1xuICAgICAgaWYgKHlTY2FsZSAmJiBVdGlsLmlzTmlsKG9iai5fb3JpZ2luW3lTY2FsZS5maWVsZF0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgb2JqLmluZGV4ID0gaW5kZXg7XG4gICAgICB2YXIgY2ZnID0gc2VsZi5nZXREcmF3Q2ZnKG9iaik7XG4gICAgICB2YXIgc2hhcGUgPSBvYmouc2hhcGU7XG4gICAgICBzZWxmLmRyYXdTaGFwZShzaGFwZSwgb2JqLCBjZmcsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5KTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZHJhd1NoYXBlID0gZnVuY3Rpb24gZHJhd1NoYXBlKHNoYXBlLCBzaGFwZURhdGEsIGNmZywgY29udGFpbmVyLCBzaGFwZUZhY3RvcnkpIHtcbiAgICB2YXIgZ1NoYXBlID0gc2hhcGVGYWN0b3J5LmRyYXdTaGFwZShzaGFwZSwgY2ZnLCBjb250YWluZXIpO1xuXG4gICAgaWYgKGdTaGFwZSkge1xuICAgICAgVXRpbC5lYWNoKFtdLmNvbmNhdChnU2hhcGUpLCBmdW5jdGlvbiAocykge1xuICAgICAgICBzLnNldCgnb3JpZ2luJywgc2hhcGVEYXRhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2dlbmVyYXRlUG9pbnRzID0gZnVuY3Rpb24gX2dlbmVyYXRlUG9pbnRzKGRhdGEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNoYXBlRmFjdG9yeSA9IHNlbGYuZ2V0U2hhcGVGYWN0b3J5KCk7XG4gICAgdmFyIHNoYXBlQXR0ciA9IHNlbGYuZ2V0QXR0cignc2hhcGUnKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgb2JqID0gZGF0YVtpXTtcbiAgICAgIHZhciBjZmcgPSBzZWxmLmNyZWF0ZVNoYXBlUG9pbnRzQ2ZnKG9iaik7XG4gICAgICB2YXIgc2hhcGUgPSBzaGFwZUF0dHIgPyBzZWxmLl9nZXRBdHRyVmFsdWVzKHNoYXBlQXR0ciwgb2JqKSA6IG51bGw7XG4gICAgICB2YXIgcG9pbnRzID0gc2hhcGVGYWN0b3J5LmdldFNoYXBlUG9pbnRzKHNoYXBlLCBjZmcpO1xuICAgICAgb2JqLnBvaW50cyA9IHBvaW50cztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgaW5mbyBvZiBlYWNoIHNoYXBlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBvYmogdGhlIGRhdGEgaXRlbVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGNmZyByZXR1cm4gdGhlIHJlc3VsdFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jcmVhdGVTaGFwZVBvaW50c0NmZyA9IGZ1bmN0aW9uIGNyZWF0ZVNoYXBlUG9pbnRzQ2ZnKG9iaikge1xuICAgIHZhciB4U2NhbGUgPSB0aGlzLmdldFhTY2FsZSgpO1xuICAgIHZhciB5U2NhbGUgPSB0aGlzLmdldFlTY2FsZSgpO1xuXG4gICAgdmFyIHggPSB0aGlzLl9ub3JtYWxpemVWYWx1ZXMob2JqW3hTY2FsZS5maWVsZF0sIHhTY2FsZSk7XG5cbiAgICB2YXIgeTtcblxuICAgIGlmICh5U2NhbGUpIHtcbiAgICAgIHkgPSB0aGlzLl9ub3JtYWxpemVWYWx1ZXMob2JqW3lTY2FsZS5maWVsZF0sIHlTY2FsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHkgPSBvYmoueSA/IG9iai55IDogMC4xO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSxcbiAgICAgIHkwOiB5U2NhbGUgPyB5U2NhbGUuc2NhbGUodGhpcy5nZXRZTWluVmFsdWUoKSkgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRZTWluVmFsdWUgPSBmdW5jdGlvbiBnZXRZTWluVmFsdWUoKSB7XG4gICAgdmFyIHlTY2FsZSA9IHRoaXMuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIG1pbiA9IHlTY2FsZS5taW4sXG4gICAgICAgIG1heCA9IHlTY2FsZS5tYXg7XG4gICAgdmFyIHZhbHVlO1xuXG4gICAgaWYgKHRoaXMuZ2V0KCdzdGFydE9uWmVybycpKSB7XG4gICAgICBpZiAobWF4IDw9IDAgJiYgbWluIDw9IDApIHtcbiAgICAgICAgdmFsdWUgPSBtYXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG1pbiA+PSAwID8gbWluIDogMDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBtaW47XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5fbm9ybWFsaXplVmFsdWVzID0gZnVuY3Rpb24gX25vcm1hbGl6ZVZhbHVlcyh2YWx1ZXMsIHNjYWxlKSB7XG4gICAgdmFyIHJzdCA9IFtdO1xuXG4gICAgaWYgKFV0aWwuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICByc3QucHVzaChzY2FsZS5zY2FsZSh2KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdCA9IHNjYWxlLnNjYWxlKHZhbHVlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJzdDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0QXR0ciA9IGZ1bmN0aW9uIGdldEF0dHIobmFtZSkge1xuICAgIHJldHVybiB0aGlzLmdldCgnYXR0cnMnKVtuYW1lXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0WFNjYWxlID0gZnVuY3Rpb24gZ2V0WFNjYWxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHIoJ3Bvc2l0aW9uJykuc2NhbGVzWzBdO1xuICB9O1xuXG4gIF9wcm90by5nZXRZU2NhbGUgPSBmdW5jdGlvbiBnZXRZU2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cigncG9zaXRpb24nKS5zY2FsZXNbMV07XG4gIH07XG5cbiAgX3Byb3RvLmhhc0FkanVzdCA9IGZ1bmN0aW9uIGhhc0FkanVzdChhZGp1c3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2FkanVzdCcpICYmIHRoaXMuZ2V0KCdhZGp1c3QnKS50eXBlID09PSBhZGp1c3Q7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRTbmFwID0gZnVuY3Rpb24gX2dldFNuYXAoc2NhbGUsIGl0ZW0sIGFycikge1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdmFsdWVzO1xuICAgIHZhciB5RmllbGQgPSB0aGlzLmdldFlTY2FsZSgpLmZpZWxkOyAvLyDlj6DliqDnmoTnu7TluqZcblxuICAgIGlmICh0aGlzLmhhc0FkanVzdCgnc3RhY2snKSAmJiBzY2FsZS5maWVsZCA9PT0geUZpZWxkKSB7XG4gICAgICB2YWx1ZXMgPSBbXTtcbiAgICAgIGFyci5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFsdWVzLnB1c2gob2JqW0ZJRUxEX09SSUdJTl9ZXSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgbGVuID0gdmFsdWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmICh2YWx1ZXNbMF1bMF0gPiBpdGVtKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXVsxXSA8PSBpdGVtKSB7XG4gICAgICAgICAgaSA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlc1tpXVswXSA8PSBpdGVtICYmIHZhbHVlc1tpXVsxXSA+IGl0ZW0pIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBzY2FsZS52YWx1ZXM7XG4gICAgICB2YWx1ZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSAtIGI7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgX2xlbjIgPSB2YWx1ZXMubGVuZ3RoOyBpIDwgX2xlbjI7IGkrKykge1xuICAgICAgICBpZiAoKHZhbHVlc1swXSArIHZhbHVlc1sxXSkgLyAyID4gaXRlbSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh2YWx1ZXNbaSAtIDFdICsgdmFsdWVzW2ldKSAvIDIgPD0gaXRlbSAmJiAodmFsdWVzW2kgKyAxXSArIHZhbHVlc1tpXSkgLyAyID4gaXRlbSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDJdICsgdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSkgLyAyIDw9IGl0ZW0pIHtcbiAgICAgICAgICBpID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gdmFsdWVzW2ldO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgX3Byb3RvLmdldFNuYXBSZWNvcmRzID0gZnVuY3Rpb24gZ2V0U25hcFJlY29yZHMocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHhTY2FsZSA9IHNlbGYuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIHlTY2FsZSA9IHNlbGYuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIHhmaWVsZCA9IHhTY2FsZS5maWVsZDtcbiAgICB2YXIgZGF0YUFycmF5ID0gc2VsZi5nZXQoJ2RhdGFBcnJheScpO1xuXG4gICAgaWYgKCF0aGlzLmdldCgnaGFzU29ydGVkJykpIHtcbiAgICAgIHRoaXMuX3NvcnQoZGF0YUFycmF5KTtcbiAgICB9XG5cbiAgICB2YXIgcnN0ID0gW107XG4gICAgdmFyIGludmVydFBvaW50ID0gY29vcmQuaW52ZXJ0UG9pbnQocG9pbnQpO1xuICAgIHZhciBpbnZlcnRQb2ludFggPSBpbnZlcnRQb2ludC54O1xuXG4gICAgaWYgKHNlbGYuaXNJbkNpcmNsZSgpICYmICFjb29yZC50cmFuc3Bvc2VkICYmIGludmVydFBvaW50WCA+ICgxICsgeFNjYWxlLnJhbmdlTWF4KCkpIC8gMikge1xuICAgICAgaW52ZXJ0UG9pbnRYID0geFNjYWxlLnJhbmdlTWluKCk7XG4gICAgfVxuXG4gICAgdmFyIHhWYWx1ZSA9IHhTY2FsZS5pbnZlcnQoaW52ZXJ0UG9pbnRYKTtcblxuICAgIGlmICgheFNjYWxlLmlzQ2F0ZWdvcnkpIHtcbiAgICAgIHhWYWx1ZSA9IHNlbGYuX2dldFNuYXAoeFNjYWxlLCB4VmFsdWUpO1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBbXTtcbiAgICBkYXRhQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgdmFyIG9yaWdpblZhbHVlID0gVXRpbC5pc05pbChvYmpbRklFTERfT1JJR0lOXSkgPyBvYmpbeGZpZWxkXSA6IG9ialtGSUVMRF9PUklHSU5dW3hmaWVsZF07XG5cbiAgICAgICAgaWYgKHNlbGYuX2lzRXF1YWwob3JpZ2luVmFsdWUsIHhWYWx1ZSwgeFNjYWxlKSkge1xuICAgICAgICAgIHRtcC5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pOyAvLyBzcGVjaWFsIGZvciBwaWUgY2hhcnRcblxuICAgIGlmICh0aGlzLmhhc0FkanVzdCgnc3RhY2snKSAmJiBjb29yZC5pc1BvbGFyICYmIGNvb3JkLnRyYW5zcG9zZWQgJiYgeFNjYWxlLnZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChpbnZlcnRQb2ludFggPj0gMCAmJiBpbnZlcnRQb2ludFggPD0gMSkge1xuICAgICAgICB2YXIgeVZhbHVlID0geVNjYWxlLmludmVydChpbnZlcnRQb2ludC55KTtcbiAgICAgICAgeVZhbHVlID0gc2VsZi5fZ2V0U25hcCh5U2NhbGUsIHlWYWx1ZSwgdG1wKTtcbiAgICAgICAgdG1wLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgIGlmIChVdGlsLmlzQXJyYXkoeVZhbHVlKSA/IG9ialtGSUVMRF9PUklHSU5fWV0udG9TdHJpbmcoKSA9PT0geVZhbHVlLnRvU3RyaW5nKCkgOiBvYmpbRklFTERfT1JJR0lOX1ldID09PSB5VmFsdWUpIHtcbiAgICAgICAgICAgIHJzdC5wdXNoKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcnN0ID0gdG1wO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLl9pc0VxdWFsID0gZnVuY3Rpb24gX2lzRXF1YWwob3JpZ2luVmFsdWUsIHZhbHVlLCBzY2FsZSkge1xuICAgIGlmIChzY2FsZS50eXBlID09PSAndGltZUNhdCcpIHtcbiAgICAgIHJldHVybiBzY2FsZS5fdG9UaW1lU3RhbXAob3JpZ2luVmFsdWUpID09PSB2YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUgPT09IG9yaWdpblZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5wb3NpdGlvbiA9IGZ1bmN0aW9uIHBvc2l0aW9uKGZpZWxkKSB7XG4gICAgdGhpcy5fc2V0QXR0ck9wdGlvbnMoJ3Bvc2l0aW9uJywge1xuICAgICAgZmllbGQ6IGZpZWxkXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uY29sb3IgPSBmdW5jdGlvbiBjb2xvcihmaWVsZCwgdmFsdWVzKSB7XG4gICAgdGhpcy5fY3JlYXRlQXR0ck9wdGlvbignY29sb3InLCBmaWVsZCwgdmFsdWVzLCBHbG9iYWwuY29sb3JzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5zaXplID0gZnVuY3Rpb24gc2l6ZShmaWVsZCwgdmFsdWVzKSB7XG4gICAgdGhpcy5fY3JlYXRlQXR0ck9wdGlvbignc2l6ZScsIGZpZWxkLCB2YWx1ZXMsIEdsb2JhbC5zaXplcyk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc2hhcGUgPSBmdW5jdGlvbiBzaGFwZShmaWVsZCwgdmFsdWVzKSB7XG4gICAgdmFyIHR5cGUgPSB0aGlzLmdldCgndHlwZScpO1xuICAgIHZhciBzaGFwZXMgPSBHbG9iYWwuc2hhcGVzW3R5cGVdIHx8IFtdO1xuXG4gICAgdGhpcy5fY3JlYXRlQXR0ck9wdGlvbignc2hhcGUnLCBmaWVsZCwgdmFsdWVzLCBzaGFwZXMpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnN0eWxlID0gZnVuY3Rpb24gc3R5bGUoZmllbGQsIGNmZykge1xuICAgIHZhciBzdHlsZU9wdGlvbnMgPSB0aGlzLmdldCgnc3R5bGVPcHRpb25zJyk7XG5cbiAgICBpZiAoIXN0eWxlT3B0aW9ucykge1xuICAgICAgc3R5bGVPcHRpb25zID0ge307XG4gICAgICB0aGlzLnNldCgnc3R5bGVPcHRpb25zJywgc3R5bGVPcHRpb25zKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdChmaWVsZCkpIHtcbiAgICAgIGNmZyA9IGZpZWxkO1xuICAgICAgZmllbGQgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBmaWVsZHM7XG5cbiAgICBpZiAoZmllbGQpIHtcbiAgICAgIGZpZWxkcyA9IHBhcnNlRmllbGRzKGZpZWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZU9wdGlvbnMuZmllbGRzID0gZmllbGRzO1xuICAgIHN0eWxlT3B0aW9ucy5zdHlsZSA9IGNmZztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uYWRqdXN0ID0gZnVuY3Rpb24gYWRqdXN0KHR5cGUpIHtcbiAgICBpZiAoVXRpbC5pc1N0cmluZyh0eXBlKSkge1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgdHlwZTogdHlwZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB0aGlzLnNldCgnYWRqdXN0JywgdHlwZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmFuaW1hdGUgPSBmdW5jdGlvbiBhbmltYXRlKGNmZykge1xuICAgIHRoaXMuc2V0KCdhbmltYXRlQ2ZnJywgY2ZnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB0aGlzLnNldCgnYXR0ck9wdGlvbnMnLCB7fSk7XG4gICAgdGhpcy5zZXQoJ2FkanVzdCcsIG51bGwpO1xuICAgIHRoaXMuY2xlYXJJbm5lcigpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhcklubmVyID0gZnVuY3Rpb24gY2xlYXJJbm5lcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXQoJ2NvbnRhaW5lcicpO1xuXG4gICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgY29udGFpbmVyLmNsZWFyKCk7XG4gICAgICBjb250YWluZXIuc2V0TWF0cml4KFsxLCAwLCAwLCAxLCAwLCAwXSk7XG4gICAgfVxuXG4gICAgY29udGFpbmVyICYmIGNvbnRhaW5lci5jbGVhcigpO1xuICAgIHRoaXMuc2V0KCdhdHRycycsIHt9KTtcbiAgICB0aGlzLnNldCgnZ3JvdXBTY2FsZXMnLCBudWxsKTtcbiAgICB0aGlzLnNldCgneERpc3RhbmNlJywgbnVsbCk7XG4gICAgdGhpcy5zZXQoJ193aWR0aCcsIG51bGwpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHRoaXMuY2xlYXJJbm5lcigpO1xuICAgIHRoaXMuc2V0KCdzY2FsZXMnLCB7fSk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIF9CYXNlLnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9kaXNwbGF5ID0gZnVuY3Rpb24gX2Rpc3BsYXkodmlzaWJsZSkge1xuICAgIHRoaXMuc2V0KCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgY2FudmFzID0gY29udGFpbmVyLmdldCgnY2FudmFzJyk7XG4gICAgY29udGFpbmVyLnNldCgndmlzaWJsZScsIHZpc2libGUpO1xuICAgIGNhbnZhcy5kcmF3KCk7XG4gIH07XG5cbiAgX3Byb3RvLnNob3cgPSBmdW5jdGlvbiBzaG93KCkge1xuICAgIHRoaXMuX2Rpc3BsYXkodHJ1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuX2Rpc3BsYXkoZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiBHZW9tO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHZW9tO1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciBpc1R5cGUgPSBmdW5jdGlvbiBpc1R5cGUodmFsdWUsIHR5cGUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCAnICsgdHlwZSArICddJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUeXBlO1xuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlID0ge307XG52YXIgU2hhcGVCYXNlID0ge1xuICBfY29vcmQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIGRyYXcgdGhlIHNoYXBlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGFpbmVyIGNvbnRhaW5lciB0byBzdG9yZSB0aGUgc2hhcGVzXG4gICAqL1xuICBkcmF3OiBmdW5jdGlvbiBkcmF3KGNmZywgY29udGFpbmVyKSB7XG4gICAgaWYgKHRoaXMuZHJhd1NoYXBlKSB7XG4gICAgICB0aGlzLmRyYXdTaGFwZShjZmcsIGNvbnRhaW5lcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBzZXQgdGhlIGNvb3JkaW5hdGUgaW5zdGFuY2VcbiAgICogQHBhcmFtIHtDb29yZH0gY29vcmQgY29vcmRpbmF0ZSBpbnN0YW5jZVxuICAgKi9cbiAgc2V0Q29vcmQ6IGZ1bmN0aW9uIHNldENvb3JkKGNvb3JkKSB7XG4gICAgdGhpcy5fY29vcmQgPSBjb29yZDtcbiAgfSxcblxuICAvKipcbiAgICogY29udmVydCB0aGUgbm9ybWFsaXplZCB2YWx1ZSB0byB0aGUgY2FudmFzIHBvc2l0aW9uXG4gICAqIEBwYXJhbSAge3BvaW50fSBwb2ludCB0aGUgcG9pbnQgdG8gY29udmVydFxuICAgKiBAcmV0dXJuIHtwb2ludH0gcG9pbnQgcmV0dXJuIHRoZSByZXN1bHRcbiAgICovXG4gIHBhcnNlUG9pbnQ6IGZ1bmN0aW9uIHBhcnNlUG9pbnQocG9pbnQpIHtcbiAgICB2YXIgY29vcmQgPSB0aGlzLl9jb29yZDtcblxuICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICBpZiAocG9pbnQueCA9PT0gMSkgcG9pbnQueCA9IDAuOTk5OTk5OTtcbiAgICAgIGlmIChwb2ludC55ID09PSAxKSBwb2ludC55ID0gMC45OTk5OTk5O1xuICAgIH1cblxuICAgIHJldHVybiBjb29yZC5jb252ZXJ0UG9pbnQocG9pbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBjb252ZXJ0IHRoZSBub3JtYWxpemVkIHZhbHVlIHRvIHRoZSBjYW52YXMgcG9zaXRpb25cbiAgICogQHBhcmFtICB7cG9pbnRzfSBwb2ludHMgdGhlIGFycmF5IHRoYXQgc3RvcmUgdGhlIHBvaW50c1xuICAgKiBAcmV0dXJuIHtwb2ludHN9IHBvaW50cyByZXR1cm4gdGhlIHJlc3VsdFxuICAgKi9cbiAgcGFyc2VQb2ludHM6IGZ1bmN0aW9uIHBhcnNlUG9pbnRzKHBvaW50cykge1xuICAgIGlmICghcG9pbnRzKSByZXR1cm4gZmFsc2U7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByc3QgPSBbXTtcbiAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgIHJzdC5wdXNoKHNlbGYucGFyc2VQb2ludChwb2ludCkpO1xuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH1cbn07XG52YXIgU2hhcGVGYWN0b3J5QmFzZSA9IHtcbiAgZGVmYXVsdFNoYXBlVHlwZTogbnVsbCxcbiAgc2V0Q29vcmQ6IGZ1bmN0aW9uIHNldENvb3JkKGNvb3JkKSB7XG4gICAgdGhpcy5fY29vcmQgPSBjb29yZDtcbiAgfSxcbiAgZ2V0U2hhcGU6IGZ1bmN0aW9uIGdldFNoYXBlKHR5cGUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHR5cGUpKSB7XG4gICAgICB0eXBlID0gdHlwZVswXTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBzZWxmW3R5cGVdIHx8IHNlbGZbc2VsZi5kZWZhdWx0U2hhcGVUeXBlXTtcbiAgICBzaGFwZS5fY29vcmQgPSBzZWxmLl9jb29yZDtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH0sXG4gIGdldFNoYXBlUG9pbnRzOiBmdW5jdGlvbiBnZXRTaGFwZVBvaW50cyh0eXBlLCBjZmcpIHtcbiAgICB2YXIgc2hhcGUgPSB0aGlzLmdldFNoYXBlKHR5cGUpO1xuICAgIHZhciBmbiA9IHNoYXBlLmdldFBvaW50cyB8fCBzaGFwZS5nZXRTaGFwZVBvaW50cyB8fCB0aGlzLmdldERlZmF1bHRQb2ludHM7XG4gICAgdmFyIHBvaW50cyA9IGZuKGNmZyk7XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfSxcbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cygpXG4gIC8qIGNmZyAqL1xuICB7XG4gICAgcmV0dXJuIFtdO1xuICB9LFxuICBkcmF3U2hhcGU6IGZ1bmN0aW9uIGRyYXdTaGFwZSh0eXBlLCBjZmcsIGNvbnRhaW5lcikge1xuICAgIHZhciBzaGFwZSA9IHRoaXMuZ2V0U2hhcGUodHlwZSk7XG5cbiAgICBpZiAoIWNmZy5jb2xvcikge1xuICAgICAgY2ZnLmNvbG9yID0gR2xvYmFsLmNvbG9yc1swXTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2hhcGUuZHJhdyhjZmcsIGNvbnRhaW5lcik7XG4gIH1cbn07XG5cblNoYXBlLnJlZ2lzdGVyRmFjdG9yeSA9IGZ1bmN0aW9uIChmYWN0b3J5TmFtZSwgY2ZnKSB7XG4gIHZhciBjbGFzc05hbWUgPSBVdGlsLnVwcGVyRmlyc3QoZmFjdG9yeU5hbWUpO1xuICB2YXIgZ2VvbU9iaiA9IFV0aWwubWl4KHt9LCBTaGFwZUZhY3RvcnlCYXNlLCBjZmcpO1xuICBTaGFwZVtjbGFzc05hbWVdID0gZ2VvbU9iajtcbiAgZ2VvbU9iai5uYW1lID0gZmFjdG9yeU5hbWU7XG4gIHJldHVybiBnZW9tT2JqO1xufTtcblxuU2hhcGUucmVnaXN0ZXJTaGFwZSA9IGZ1bmN0aW9uIChmYWN0b3J5TmFtZSwgc2hhcGVUeXBlLCBjZmcpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IFV0aWwudXBwZXJGaXJzdChmYWN0b3J5TmFtZSk7XG4gIHZhciBmYWN0b3J5ID0gU2hhcGVbY2xhc3NOYW1lXTtcbiAgdmFyIHNoYXBlT2JqID0gVXRpbC5taXgoe30sIFNoYXBlQmFzZSwgY2ZnKTtcbiAgZmFjdG9yeVtzaGFwZVR5cGVdID0gc2hhcGVPYmo7XG4gIHJldHVybiBzaGFwZU9iajtcbn07XG5cblNoYXBlLnJlZ2lzdFNoYXBlID0gU2hhcGUucmVnaXN0ZXJTaGFwZTtcblxuU2hhcGUuZ2V0U2hhcGVGYWN0b3J5ID0gZnVuY3Rpb24gKGZhY3RvcnlOYW1lKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgZmFjdG9yeU5hbWUgPSBmYWN0b3J5TmFtZSB8fCAncG9pbnQnO1xuICB2YXIgY2xhc3NOYW1lID0gVXRpbC51cHBlckZpcnN0KGZhY3RvcnlOYW1lKTtcbiAgcmV0dXJuIHNlbGZbY2xhc3NOYW1lXTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2hhcGU7XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBpc0Zpbml0ZSxcbnZhciBpc05pbCA9IGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIC8qKlxuICAgKiBpc05pbChudWxsKSA9PiB0cnVlXG4gICAqIGlzTmlsKCkgPT4gdHJ1ZVxuICAgKi9cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmlsO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBWZWN0b3IyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIHN0YXJ0ID0gVmVjdG9yMi5jcmVhdGUoKTtcbnZhciBlbmQgPSBWZWN0b3IyLmNyZWF0ZSgpO1xudmFyIGV4dHJlbWl0eSA9IFZlY3RvcjIuY3JlYXRlKCk7XG5cbmZ1bmN0aW9uIGdldEN1YmljQmV6aWVyWFlhdFQoc3RhcnRQdCwgY29udHJvbFB0MSwgY29udHJvbFB0MiwgZW5kUHQsIFQpIHtcbiAgdmFyIHggPSBDdWJpY04oVCwgc3RhcnRQdC54LCBjb250cm9sUHQxLngsIGNvbnRyb2xQdDIueCwgZW5kUHQueCk7XG4gIHZhciB5ID0gQ3ViaWNOKFQsIHN0YXJ0UHQueSwgY29udHJvbFB0MS55LCBjb250cm9sUHQyLnksIGVuZFB0LnkpO1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufSAvLyBjdWJpYyBoZWxwZXIgZm9ybXVsYSBhdCBUIGRpc3RhbmNlXG5cblxuZnVuY3Rpb24gQ3ViaWNOKFQsIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHQyID0gVCAqIFQ7XG4gIHZhciB0MyA9IHQyICogVDtcbiAgcmV0dXJuIGEgKyAoLWEgKiAzICsgVCAqICgzICogYSAtIGEgKiBUKSkgKiBUICsgKDMgKiBiICsgVCAqICgtNiAqIGIgKyBiICogMyAqIFQpKSAqIFQgKyAoYyAqIDMgLSBjICogMyAqIFQpICogdDIgKyBkICogdDM7XG59XG5cbmZ1bmN0aW9uIGN1YmljQmV6aWVyQm91bmRzKGMpIHtcbiAgdmFyIG1pblggPSBJbmZpbml0eTtcbiAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gIHZhciBtYXhZID0gLUluZmluaXR5O1xuICB2YXIgcyA9IHtcbiAgICB4OiBjWzBdLFxuICAgIHk6IGNbMV1cbiAgfTtcbiAgdmFyIGMxID0ge1xuICAgIHg6IGNbMl0sXG4gICAgeTogY1szXVxuICB9O1xuICB2YXIgYzIgPSB7XG4gICAgeDogY1s0XSxcbiAgICB5OiBjWzVdXG4gIH07XG4gIHZhciBlID0ge1xuICAgIHg6IGNbNl0sXG4gICAgeTogY1s3XVxuICB9O1xuXG4gIGZvciAodmFyIHQgPSAwOyB0IDwgMTAwOyB0KyspIHtcbiAgICB2YXIgcHQgPSBnZXRDdWJpY0JlemllclhZYXRUKHMsIGMxLCBjMiwgZSwgdCAvIDEwMCk7XG5cbiAgICBpZiAocHQueCA8IG1pblgpIHtcbiAgICAgIG1pblggPSBwdC54O1xuICAgIH1cblxuICAgIGlmIChwdC54ID4gbWF4WCkge1xuICAgICAgbWF4WCA9IHB0Lng7XG4gICAgfVxuXG4gICAgaWYgKHB0LnkgPCBtaW5ZKSB7XG4gICAgICBtaW5ZID0gcHQueTtcbiAgICB9XG5cbiAgICBpZiAocHQueSA+IG1heFkpIHtcbiAgICAgIG1heFkgPSBwdC55O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluWDogbWluWCxcbiAgICBtaW5ZOiBtaW5ZLFxuICAgIG1heFg6IG1heFgsXG4gICAgbWF4WTogbWF4WVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0QkJveEZyb21Qb2ludHM6IGZ1bmN0aW9uIGdldEJCb3hGcm9tUG9pbnRzKHBvaW50cywgbGluZVdpZHRoKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHBvaW50c1swXTtcbiAgICB2YXIgbGVmdCA9IHAueDtcbiAgICB2YXIgcmlnaHQgPSBwLng7XG4gICAgdmFyIHRvcCA9IHAueTtcbiAgICB2YXIgYm90dG9tID0gcC55O1xuICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBsZW47IGkrKykge1xuICAgICAgcCA9IHBvaW50c1tpXTtcbiAgICAgIGxlZnQgPSBNYXRoLm1pbihsZWZ0LCBwLngpO1xuICAgICAgcmlnaHQgPSBNYXRoLm1heChyaWdodCwgcC54KTtcbiAgICAgIHRvcCA9IE1hdGgubWluKHRvcCwgcC55KTtcbiAgICAgIGJvdHRvbSA9IE1hdGgubWF4KGJvdHRvbSwgcC55KTtcbiAgICB9XG5cbiAgICBsaW5lV2lkdGggPSBsaW5lV2lkdGggLyAyIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IGxlZnQgLSBsaW5lV2lkdGgsXG4gICAgICBtaW5ZOiB0b3AgLSBsaW5lV2lkdGgsXG4gICAgICBtYXhYOiByaWdodCArIGxpbmVXaWR0aCxcbiAgICAgIG1heFk6IGJvdHRvbSArIGxpbmVXaWR0aFxuICAgIH07XG4gIH0sXG4gIGdldEJCb3hGcm9tTGluZTogZnVuY3Rpb24gZ2V0QkJveEZyb21MaW5lKHgwLCB5MCwgeDEsIHkxLCBsaW5lV2lkdGgpIHtcbiAgICBsaW5lV2lkdGggPSBsaW5lV2lkdGggLyAyIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IE1hdGgubWluKHgwLCB4MSkgLSBsaW5lV2lkdGgsXG4gICAgICBtaW5ZOiBNYXRoLm1pbih5MCwgeTEpIC0gbGluZVdpZHRoLFxuICAgICAgbWF4WDogTWF0aC5tYXgoeDAsIHgxKSArIGxpbmVXaWR0aCxcbiAgICAgIG1heFk6IE1hdGgubWF4KHkwLCB5MSkgKyBsaW5lV2lkdGhcbiAgICB9O1xuICB9LFxuICBnZXRCQm94RnJvbUFyYzogZnVuY3Rpb24gZ2V0QkJveEZyb21BcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGljbG9ja3dpc2UpIHtcbiAgICB2YXIgZGlmZiA9IE1hdGguYWJzKHN0YXJ0QW5nbGUgLSBlbmRBbmdsZSk7XG5cbiAgICBpZiAoZGlmZiAlIChNYXRoLlBJICogMikgPCAxZS00ICYmIGRpZmYgPiAxZS00KSB7XG4gICAgICAvLyBJcyBhIGNpcmNsZVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWluWDogeCAtIHIsXG4gICAgICAgIG1pblk6IHkgLSByLFxuICAgICAgICBtYXhYOiB4ICsgcixcbiAgICAgICAgbWF4WTogeSArIHJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgc3RhcnRbMF0gPSBNYXRoLmNvcyhzdGFydEFuZ2xlKSAqIHIgKyB4O1xuICAgIHN0YXJ0WzFdID0gTWF0aC5zaW4oc3RhcnRBbmdsZSkgKiByICsgeTtcbiAgICBlbmRbMF0gPSBNYXRoLmNvcyhlbmRBbmdsZSkgKiByICsgeDtcbiAgICBlbmRbMV0gPSBNYXRoLnNpbihlbmRBbmdsZSkgKiByICsgeTtcbiAgICB2YXIgbWluID0gWzAsIDBdO1xuICAgIHZhciBtYXggPSBbMCwgMF07XG4gICAgVmVjdG9yMi5taW4obWluLCBzdGFydCwgZW5kKTtcbiAgICBWZWN0b3IyLm1heChtYXgsIHN0YXJ0LCBlbmQpOyAvLyBUaHJlc2ggdG8gWzAsIE1hdGguUEkgKiAyXVxuXG4gICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgJSAoTWF0aC5QSSAqIDIpO1xuXG4gICAgaWYgKHN0YXJ0QW5nbGUgPCAwKSB7XG4gICAgICBzdGFydEFuZ2xlID0gc3RhcnRBbmdsZSArIE1hdGguUEkgKiAyO1xuICAgIH1cblxuICAgIGVuZEFuZ2xlID0gZW5kQW5nbGUgJSAoTWF0aC5QSSAqIDIpO1xuXG4gICAgaWYgKGVuZEFuZ2xlIDwgMCkge1xuICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSArIE1hdGguUEkgKiAyO1xuICAgIH1cblxuICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUgJiYgIWFudGljbG9ja3dpc2UpIHtcbiAgICAgIGVuZEFuZ2xlICs9IE1hdGguUEkgKiAyO1xuICAgIH0gZWxzZSBpZiAoc3RhcnRBbmdsZSA8IGVuZEFuZ2xlICYmIGFudGljbG9ja3dpc2UpIHtcbiAgICAgIHN0YXJ0QW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgfVxuXG4gICAgaWYgKGFudGljbG9ja3dpc2UpIHtcbiAgICAgIHZhciB0bXAgPSBlbmRBbmdsZTtcbiAgICAgIGVuZEFuZ2xlID0gc3RhcnRBbmdsZTtcbiAgICAgIHN0YXJ0QW5nbGUgPSB0bXA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgYW5nbGUgPSAwOyBhbmdsZSA8IGVuZEFuZ2xlOyBhbmdsZSArPSBNYXRoLlBJIC8gMikge1xuICAgICAgaWYgKGFuZ2xlID4gc3RhcnRBbmdsZSkge1xuICAgICAgICBleHRyZW1pdHlbMF0gPSBNYXRoLmNvcyhhbmdsZSkgKiByICsgeDtcbiAgICAgICAgZXh0cmVtaXR5WzFdID0gTWF0aC5zaW4oYW5nbGUpICogciArIHk7XG4gICAgICAgIFZlY3RvcjIubWluKG1pbiwgZXh0cmVtaXR5LCBtaW4pO1xuICAgICAgICBWZWN0b3IyLm1heChtYXgsIGV4dHJlbWl0eSwgbWF4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogbWluWzBdLFxuICAgICAgbWluWTogbWluWzFdLFxuICAgICAgbWF4WDogbWF4WzBdLFxuICAgICAgbWF4WTogbWF4WzFdXG4gICAgfTtcbiAgfSxcbiAgZ2V0QkJveEZyb21CZXppZXJHcm91cDogZnVuY3Rpb24gZ2V0QkJveEZyb21CZXppZXJHcm91cChwb2ludHMsIGxpbmVXaWR0aCkge1xuICAgIHZhciBtaW5YID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFggPSAtSW5maW5pdHk7XG4gICAgdmFyIG1pblkgPSBJbmZpbml0eTtcbiAgICB2YXIgbWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBiYm94ID0gY3ViaWNCZXppZXJCb3VuZHMocG9pbnRzW2ldKTtcblxuICAgICAgaWYgKGJib3gubWluWCA8IG1pblgpIHtcbiAgICAgICAgbWluWCA9IGJib3gubWluWDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJib3gubWF4WCA+IG1heFgpIHtcbiAgICAgICAgbWF4WCA9IGJib3gubWF4WDtcbiAgICAgIH1cblxuICAgICAgaWYgKGJib3gubWluWSA8IG1pblkpIHtcbiAgICAgICAgbWluWSA9IGJib3gubWluWTtcbiAgICAgIH1cblxuICAgICAgaWYgKGJib3gubWF4WSA+IG1heFkpIHtcbiAgICAgICAgbWF4WSA9IGJib3gubWF4WTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsaW5lV2lkdGggPSBsaW5lV2lkdGggLyAyIHx8IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IG1pblggLSBsaW5lV2lkdGgsXG4gICAgICBtaW5ZOiBtaW5ZIC0gbGluZVdpZHRoLFxuICAgICAgbWF4WDogbWF4WCArIGxpbmVXaWR0aCxcbiAgICAgIG1heFk6IG1heFkgKyBsaW5lV2lkdGhcbiAgICB9O1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEtFWVdPUkRTX1BFUkNFTlQgPSB7XG4gIG1pbjogMCxcbiAgbWVkaWFuOiAwLjUsXG4gIG1heDogMVxufTtcblxudmFyIEd1aWRlQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBHdWlkZUJhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7fTtcblxuICBmdW5jdGlvbiBHdWlkZUJhc2UoY2ZnKSB7XG4gICAgdGhpcy5faW5pdERlZmF1bHRDZmcoKTtcblxuICAgIFV0aWwuZGVlcE1peCh0aGlzLCBjZmcpO1xuICB9XG5cbiAgX3Byb3RvLl9nZXROb3JtYWxpemVkVmFsdWUgPSBmdW5jdGlvbiBfZ2V0Tm9ybWFsaXplZFZhbHVlKHZhbCwgc2NhbGUpIHtcbiAgICB2YXIgcnN0O1xuXG4gICAgaWYgKFV0aWwuaXNOaWwoS0VZV09SRFNfUEVSQ0VOVFt2YWxdKSkge1xuICAgICAgcnN0ID0gc2NhbGUuc2NhbGUodmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN0ID0gS0VZV09SRFNfUEVSQ0VOVFt2YWxdO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUGVyY2VudFBvaW50ID0gZnVuY3Rpb24gcGFyc2VQZXJjZW50UG9pbnQoY29vcmQsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHhQZXJjZW50ID0gcGFyc2VGbG9hdChwb3NpdGlvblswXSkgLyAxMDA7XG4gICAgdmFyIHlQZXJjZW50ID0gcGFyc2VGbG9hdChwb3NpdGlvblsxXSkgLyAxMDA7XG4gICAgdmFyIHN0YXJ0ID0gY29vcmQuc3RhcnQ7XG4gICAgdmFyIGVuZCA9IGNvb3JkLmVuZDtcbiAgICB2YXIgd2lkdGggPSBNYXRoLmFicyhzdGFydC54IC0gZW5kLngpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyhzdGFydC55IC0gZW5kLnkpO1xuICAgIHZhciB4ID0gd2lkdGggKiB4UGVyY2VudCArIE1hdGgubWluKHN0YXJ0LngsIGVuZC54KTtcbiAgICB2YXIgeSA9IGhlaWdodCAqIHlQZXJjZW50ICsgTWF0aC5taW4oc3RhcnQueSwgZW5kLnkpO1xuICAgIHJldHVybiB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnBhcnNlUG9pbnQgPSBmdW5jdGlvbiBwYXJzZVBvaW50KGNvb3JkLCBwb3NpdGlvbikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgeFNjYWxlID0gc2VsZi54U2NhbGU7XG4gICAgdmFyIHlTY2FsZXMgPSBzZWxmLnlTY2FsZXM7XG5cbiAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbih4U2NhbGUsIHlTY2FsZXMpOyAvLyBwb3NpdGlvbiDlv4XpobvmmK/lr7nosaFcbiAgICB9IC8vIOWmguaenOaVsOaNruagvOW8j+aYryBbJzUwJScsICc1MCUnXSDnmoTmoLzlvI9cblxuXG4gICAgaWYgKFV0aWwuaXNTdHJpbmcocG9zaXRpb25bMF0pICYmIHBvc2l0aW9uWzBdLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGVyY2VudFBvaW50KGNvb3JkLCBwb3NpdGlvbik7XG4gICAgfVxuXG4gICAgdmFyIHggPSBzZWxmLl9nZXROb3JtYWxpemVkVmFsdWUocG9zaXRpb25bMF0sIHhTY2FsZSk7XG5cbiAgICB2YXIgeSA9IHNlbGYuX2dldE5vcm1hbGl6ZWRWYWx1ZShwb3NpdGlvblsxXSwgeVNjYWxlc1swXSk7XG5cbiAgICB2YXIgcG9pbnQgPSBjb29yZC5jb252ZXJ0UG9pbnQoe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9KTtcblxuICAgIGlmIChzZWxmLmxpbWl0SW5QbG90KSB7XG4gICAgICAvLyBsaW1pdCBpbiBjaGFydCBwbG90UmFuZ2VcbiAgICAgIGlmICh4ID49IDAgJiYgeCA8PSAxICYmIHkgPj0gMCAmJiB5IDw9IDEpIHtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cbiAgLyoqXG4gICAqIHJlbmRlciB0aGUgZ3VpZGUgY29tcG9uZW50XG4gICAqIEBwYXJhbSAge0Nvb3JkfSBjb29yZCAgY29vcmRpbmF0ZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gIHtDYW52YXMuR3JvdXB9IGdyb3VwIHRoZSBjb250YWluZXJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKClcbiAgLyogY29vcmQsZ3JvdXAgKi9cbiAge307XG5cbiAgX3Byb3RvLnJlcGFpbnQgPSBmdW5jdGlvbiByZXBhaW50KCkge1xuICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5jb29yZCxcbiAgICAgICAgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzO1xuXG4gICAgaWYgKGNvbnRhaW5lciAmJiAhY29udGFpbmVyLmlzRGVzdHJveWVkKCkpIHtcbiAgICAgIHRoaXMucmVuZGVyKGNvb3JkLCBjb250YWluZXIpO1xuICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnJlbW92ZSA9IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudDtcbiAgICBlbGVtZW50ICYmIGVsZW1lbnQucmVtb3ZlKHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5jaGFuZ2VWaXNpYmxlID0gZnVuY3Rpb24gY2hhbmdlVmlzaWJsZSh2aXNpYmxlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudmlzaWJsZSA9IHZpc2libGU7XG4gICAgdmFyIGVsZW1lbnQgPSBzZWxmLmVsZW1lbnQ7XG4gICAgaWYgKCFlbGVtZW50KSByZXR1cm47XG5cbiAgICBpZiAoZWxlbWVudC5zZXQpIHtcbiAgICAgIGVsZW1lbnQuc2V0KCd2aXNpYmxlJywgdmlzaWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuZGlzcGxheSA9IHZpc2libGUgPyAnJyA6ICdub25lJztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEd1aWRlQmFzZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBHdWlkZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIG1peCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgU2NhbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gU2NhbGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ2Jhc2UnO1xuICAgIC8qKlxuICAgICAqIOagvOW8j+WMluWHveaVsCzovpPlh7rmlofmnKzmiJbogIV0aWNr5pe255qE5qC85byP5YyW5Ye95pWwXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgICAqL1xuXG4gICAgdGhpcy5mb3JtYXR0ZXIgPSBudWxsO1xuICAgIC8qKlxuICAgICAqIOi+k+WHuueahOWAvOWfn1xuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKi9cblxuICAgIHRoaXMucmFuZ2UgPSBbMCwgMV07XG4gICAgLyoqXG4gICAgICog5bqm6YeP55qE5qCH6K6wXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy50aWNrcyA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5Y+C5LiO5bqm6YeP6K6h566X55qE5YC877yM5Y+v6YCJ6aG5XG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgfTtcblxuICBmdW5jdGlvbiBTY2FsZShjZmcpIHtcbiAgICB0aGlzLl9pbml0RGVmYXVsdENmZygpO1xuXG4gICAgbWl4KHRoaXMsIGNmZyk7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgLyoqXG4gICAqIOW6pumHj+WIneWni+WMllxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuXG5cbiAgX3Byb3RvLmluaXQgPSBmdW5jdGlvbiBpbml0KCkge31cbiAgLyoqXG4gICAqIOiOt+WPluivpeW6pumHj+eahHRpY2tzLOi/lOWbnueahOaYr+WkmuS4quWvueixoe+8jFxuICAgKiAgIC0gdGV4dDogdGljayDnmoTmlofmnKxcbiAgICogICAtIHZhbHVlOiDlr7nlupTnmoTluqbph4/ovazmjaLlkI7nmoTlgLxcbiAgICogPGNvZGU+XG4gICAqICAgW1xuICAgKiAgICAge3RleHQ6IDAsdmFsdWU6MH1cbiAgICogICAgIHt0ZXh0OiAxLHZhbHVlOjAuMn1cbiAgICogICAgIHt0ZXh0OiAyLHZhbHVlOjAuNH1cbiAgICogICAgIHt0ZXh0OiAzLHZhbHVlOjAuNn1cbiAgICogICAgIHt0ZXh0OiA0LHZhbHVlOjAuOH1cbiAgICogICAgIHt0ZXh0OiA1LHZhbHVlOjF9XG4gICAqICAgXVxuICAgKiA8L2NvZGU+XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCDovpPlh7p0aWNr55qE5Liq5pWw55qE6L+R5Ly85YC877yM6buY6K6k5pivIDEwXG4gICAqIEByZXR1cm4ge0FycmF5fSDov5Tlm54gdGlja3Mg5pWw57uEXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFRpY2tzID0gZnVuY3Rpb24gZ2V0VGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrcyA9IHNlbGYudGlja3M7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgb2JqO1xuXG4gICAgICBpZiAoaXNPYmplY3QodGljaykpIHtcbiAgICAgICAgb2JqID0gdGljaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICB0ZXh0OiBzZWxmLmdldFRleHQodGljayksXG4gICAgICAgICAgdGlja1ZhbHVlOiB0aWNrLFxuICAgICAgICAgIHZhbHVlOiBzZWxmLnNjYWxlKHRpY2spXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJzdC5wdXNoKG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfVxuICAvKipcbiAgICog6I635Y+W5qC85byP5YyW5ZCO55qE5paH5pysXG4gICAqIEBwYXJhbSAgeyp9IHZhbHVlIOi+k+WFpeeahOaVsOaNrlxuICAgKiBAcGFyYW0gIHsqfSBrZXkg5a2X5q6155qEIGtleVxuICAgKiBAcmV0dXJuIHtTdHJpbmd9IOagvOW8j+WMlueahOaWh+acrFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCh2YWx1ZSwga2V5KSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuZm9ybWF0dGVyO1xuICAgIHZhbHVlID0gZm9ybWF0dGVyID8gZm9ybWF0dGVyKHZhbHVlLCBrZXkpIDogdmFsdWU7XG5cbiAgICBpZiAoaXNOaWwodmFsdWUpIHx8ICF2YWx1ZS50b1N0cmluZykge1xuICAgICAgdmFsdWUgPSAnJztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICog6L6T5Ye655qE5YC85Z+f5pyA5bCP5YC8XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7TnVtYmVyfSDov5Tlm57mnIDlsI/nmoTlgLxcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmFuZ2VNaW4gPSBmdW5jdGlvbiByYW5nZU1pbigpIHtcbiAgICByZXR1cm4gdGhpcy5yYW5nZVswXTtcbiAgfVxuICAvKipcbiAgICog6L6T5Ye655qE5YC85Z+f5pyA5aSn5YC8XG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQHJldHVybiB7TnVtYmVyfSDov5Tlm57mnIDlpKfnmoTlgLxcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmFuZ2VNYXggPSBmdW5jdGlvbiByYW5nZU1heCgpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlO1xuICAgIHJldHVybiByYW5nZVtyYW5nZS5sZW5ndGggLSAxXTtcbiAgfVxuICAvKipcbiAgICog5bqm6YeP6L2s5o2i5ZCO55qE57uT5p6c77yM57+76L2s5Zue6L6T5YWl5Z+fXG4gICAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUg6ZyA6KaB57+76L2s55qE5pWw5YC8XG4gICAqIEByZXR1cm4geyp9IOW6pumHj+eahOi+k+WFpeWAvFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgLyoqXG4gICAqIOWwhuS8oOWFpeeahOWAvOS7jumdnuaVsOWAvOi9rOaNouaIkOaVsOWAvOagvOW8j++8jOWmguWIhuexu+Wtl+espuS4suOAgeaXtumXtOWtl+espuS4suetiVxuICAgKiBAcGFyYW0gIHsqfSB2YWx1ZSDkvKDlhaXnmoTlgLxcbiAgICogQHJldHVybiB7TnVtYmVyfSDovazmjaLnmoTlgLxcbiAgICovXG4gIDtcblxuICBfcHJvdG8udHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIC8qKlxuICAgKiDov5vooYzluqbph4/ovazmjaJcbiAgICogQHBhcmFtICB7Kn0gdmFsdWUg6L6T5YWl5YC8XG4gICAqIEByZXR1cm4ge051bWJlcn0g6L6T5Ye65YC877yM5Zyo6K6+5a6a55qE6L6T5Ye65YC85Z+f5LmL6Ze077yM6buY6K6kWzAsMV1cbiAgICovXG4gIDtcblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICAvKipcbiAgICog5YWL6ZqG5LiA5Liq5paw55qEc2NhbGUs5oul5pyJ6Lef5b2T5YmNc2NhbGXnm7jlkIznmoTovpPlhaXln5/jgIHovpPlh7rln5/nrYlcbiAgICogQHJldHVybiB7U2NhbGV9IOWFi+mahueahOW6pumHj1xuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29uc3RyID0gc2VsZi5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY2ZnID0ge307XG4gICAgZWFjaChzZWxmLCBmdW5jdGlvbiAodiwgaykge1xuICAgICAgY2ZnW2tdID0gc2VsZltrXTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IGNvbnN0cihjZmcpO1xuICB9XG4gIC8qKlxuICAgKiDmm7TmlLnluqbph4/nmoTlsZ7mgKfkv6Hmga9cbiAgICogQHBhcmFtICB7T2JqZWN0fSBpbmZvIOWxnuaAp+S/oeaBr1xuICAgKiBAY2hhaW5hYmxlXG4gICAqIEByZXR1cm4ge1NjYWxlfSDov5Tlm57oh6rouqvnmoTlvJXnlKhcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2hhbmdlID0gZnVuY3Rpb24gY2hhbmdlKGluZm8pIHtcbiAgICB0aGlzLnRpY2tzID0gbnVsbDtcbiAgICBtaXgodGhpcywgaW5mbyk7XG4gICAgdGhpcy5pbml0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcmV0dXJuIFNjYWxlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlO1xuXG4vKioqLyB9KSxcbi8qIDEzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnQXJyYXknKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IHRoZSBBdHRyaWJ1dGUgYmFzZSBjbGFzc1xuICovXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIGlzQXJyYXkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcblxudmFyIGlzTmlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxudmFyIG1peCA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbmZ1bmN0aW9uIHRvU2NhbGVTdHJpbmcoc2NhbGUsIHZhbHVlKSB7XG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gc2NhbGUuaW52ZXJ0KHNjYWxlLnNjYWxlKHZhbHVlKSk7XG59XG4vKipcbiAqIOaJgOacieinhuiniemAmumBk+WxnuaAp+eahOWfuuexu1xuICogQGNsYXNzIEF0dHJcbiAqL1xuXG5cbnZhciBBdHRyaWJ1dGVCYXNlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXR0cmlidXRlQmFzZShjZmcpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIC8qKlxuICAgICAqIOWxnuaAp+eahOexu+Wei1xuICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICovXG5cblxuICAgIHRoaXMudHlwZSA9ICdiYXNlJztcbiAgICAvKipcbiAgICAgKiDlsZ7mgKfnmoTlkI3np7BcbiAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAqL1xuXG4gICAgdGhpcy5uYW1lID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiDlm57osIPlh73mlbBcbiAgICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAgICovXG5cbiAgICB0aGlzLm1ldGhvZCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5aSH6YCJ55qE5YC85pWw57uEXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICAvKipcbiAgICAgKiDlsZ7mgKflhoXpg6jnmoTluqbph49cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICovXG5cbiAgICB0aGlzLnNjYWxlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIOaYr+WQpumAmui/h+e6v+aAp+WPluWAvCwg5aaC5p6c5pyq5oyH5a6a77yM5YiZ5qC55o2u5pWw5YC855qE57G75Z6L5Yik5a6aXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICB0aGlzLmxpbmVhciA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5b2T55So5oi36K6+572u55qEIGNhbGxiYWNrIOi/lOWbniBudWxsIOaXtiwg5bqU6K+l6L+U5Zue6buY6K6kIGNhbGxiYWNrIOS4reeahOWAvFxuICAgICAqL1xuXG4gICAgdmFyIG1peGVkQ2FsbGJhY2sgPSBudWxsO1xuICAgIHZhciBkZWZhdWx0Q2FsbGJhY2sgPSB0aGlzLmNhbGxiYWNrO1xuXG4gICAgaWYgKGNmZy5jYWxsYmFjaykge1xuICAgICAgdmFyIHVzZXJDYWxsYmFjayA9IGNmZy5jYWxsYmFjaztcblxuICAgICAgbWl4ZWRDYWxsYmFjayA9IGZ1bmN0aW9uIG1peGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwYXJhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgcGFyYW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IHVzZXJDYWxsYmFjay5hcHBseSh2b2lkIDAsIHBhcmFtcyk7XG5cbiAgICAgICAgaWYgKGlzTmlsKHJldCkpIHtcbiAgICAgICAgICByZXQgPSBkZWZhdWx0Q2FsbGJhY2suYXBwbHkoX3RoaXMsIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBtaXgodGhpcywgY2ZnKTtcblxuICAgIGlmIChtaXhlZENhbGxiYWNrKSB7XG4gICAgICBtaXgodGhpcywge1xuICAgICAgICBjYWxsYmFjazogbWl4ZWRDYWxsYmFja1xuICAgICAgfSk7XG4gICAgfVxuICB9IC8vIOiOt+WPluWxnuaAp+WAvO+8jOWwhuWAvOaYoOWwhOWIsOinhuiniemAmumBk1xuXG5cbiAgdmFyIF9wcm90byA9IEF0dHJpYnV0ZUJhc2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5fZ2V0QXR0clZhbHVlID0gZnVuY3Rpb24gX2dldEF0dHJWYWx1ZShzY2FsZSwgdmFsdWUpIHtcbiAgICB2YXIgdmFsdWVzID0gdGhpcy52YWx1ZXM7XG5cbiAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSAmJiAhdGhpcy5saW5lYXIpIHtcbiAgICAgIHZhciBpbmRleCA9IHNjYWxlLnRyYW5zbGF0ZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWVzW2luZGV4ICUgdmFsdWVzLmxlbmd0aF07XG4gICAgfVxuXG4gICAgdmFyIHBlcmNlbnQgPSBzY2FsZS5zY2FsZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TGluZWFyVmFsdWUocGVyY2VudCk7XG4gIH07XG4gIC8qKlxuICAgKiDlpoLmnpzov5vooYznur/mgKfmmKDlsITvvIzov5Tlm57lr7nlupTnmoTmmKDlsITlgLxcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHBlcmNlbnQg55m+5YiG5q+UXG4gICAqIEByZXR1cm4geyp9ICDpopzoibLlgLzjgIHlvaLnirbjgIHlpKflsI/nrYlcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0TGluZWFyVmFsdWUgPSBmdW5jdGlvbiBnZXRMaW5lYXJWYWx1ZShwZXJjZW50KSB7XG4gICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgIHZhciBzdGVwcyA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgIHZhciBzdGVwID0gTWF0aC5mbG9vcihzdGVwcyAqIHBlcmNlbnQpO1xuICAgIHZhciBsZWZ0UGVyY2VudCA9IHN0ZXBzICogcGVyY2VudCAtIHN0ZXA7XG4gICAgdmFyIHN0YXJ0ID0gdmFsdWVzW3N0ZXBdO1xuICAgIHZhciBlbmQgPSBzdGVwID09PSBzdGVwcyA/IHN0YXJ0IDogdmFsdWVzW3N0ZXAgKyAxXTtcbiAgICB2YXIgcnN0VmFsdWUgPSBzdGFydCArIChlbmQgLSBzdGFydCkgKiBsZWZ0UGVyY2VudDtcbiAgICByZXR1cm4gcnN0VmFsdWU7XG4gIH07XG4gIC8qKlxuICAgKiDpu5jorqTnmoTlm57osIPlh73mlbBcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSDlm57osIPlh73mlbDnmoTlgLxcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKiBAcmV0dXJuIHtBcnJheX0g6L+U5Zue5pig5bCE5ZCO55qE5YC8XG4gICAqL1xuXG5cbiAgX3Byb3RvLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2sodmFsdWUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHNjYWxlID0gc2VsZi5zY2FsZXNbMF07XG4gICAgdmFyIHJzdFZhbHVlID0gbnVsbDtcblxuICAgIGlmIChzY2FsZS50eXBlID09PSAnaWRlbnRpdHknKSB7XG4gICAgICByc3RWYWx1ZSA9IHNjYWxlLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByc3RWYWx1ZSA9IHNlbGYuX2dldEF0dHJWYWx1ZShzY2FsZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiByc3RWYWx1ZTtcbiAgfTtcbiAgLyoqXG4gICAqIOagueaNruW6pumHj+iOt+WPluWxnuaAp+WQjVxuICAgKiBAcmV0dXJuIHtBcnJheX0gZGltcyBvZiB0aGlzIEF0dHJpYnV0ZVxuICAgKi9cblxuXG4gIF9wcm90by5nZXROYW1lcyA9IGZ1bmN0aW9uIGdldE5hbWVzKCkge1xuICAgIHZhciBzY2FsZXMgPSB0aGlzLnNjYWxlcztcbiAgICB2YXIgbmFtZXMgPSB0aGlzLm5hbWVzO1xuICAgIHZhciBsZW5ndGggPSBNYXRoLm1pbihzY2FsZXMubGVuZ3RoLCBuYW1lcy5sZW5ndGgpO1xuICAgIHZhciByc3QgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJzdC5wdXNoKG5hbWVzW2ldKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5bqm6YeP6I635Y+W57u05bqm5ZCNXG4gICAqIEByZXR1cm4ge0FycmF5fSBkaW1zIG9mIHRoaXMgQXR0cmlidXRlXG4gICAqL1xuXG5cbiAgX3Byb3RvLmdldEZpZWxkcyA9IGZ1bmN0aW9uIGdldEZpZWxkcygpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGVhY2goc2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIHJzdC5wdXNoKHNjYWxlLmZpZWxkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuICAvKipcbiAgICog5qC55o2u5ZCN56ew6I635Y+W5bqm6YePXG4gICAqIEBwYXJhbSAge1N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiBzY2FsZVxuICAgKiBAcmV0dXJuIHtTY2FsZX0gc2NhbGVcbiAgICovXG5cblxuICBfcHJvdG8uZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZShuYW1lKSB7XG4gICAgdmFyIHNjYWxlcyA9IHRoaXMuc2NhbGVzO1xuICAgIHZhciBuYW1lcyA9IHRoaXMubmFtZXM7XG4gICAgdmFyIGluZGV4ID0gbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICByZXR1cm4gc2NhbGVzW2luZGV4XTtcbiAgfTtcbiAgLyoqXG4gICAqIOaYoOWwhOaVsOaNrlxuICAgKiBAcGFyYW0geyp9IHBhcmFtMS4uLnBhcmFtbiDlpJrkuKrmlbDlgLxcbiAgICogQHJldHVybiB7QXJyYXl9IOaYoOWwhOeahOWAvOe7hOaIkOeahOaVsOe7hFxuICAgKi9cblxuXG4gIF9wcm90by5tYXBwaW5nID0gZnVuY3Rpb24gbWFwcGluZygpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgdmFyIGNhbGxiYWNrID0gdGhpcy5jYWxsYmFjaztcblxuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgcGFyYW1zID0gbmV3IEFycmF5KF9sZW4yKSwgX2tleTIgPSAwOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBwYXJhbXNbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICB9XG5cbiAgICB2YXIgdmFsdWVzID0gcGFyYW1zO1xuXG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGFyYW1zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBhcmFtc1tpXSA9IHRoaXMuX3RvT3JpZ2luUGFyYW0ocGFyYW1zW2ldLCBzY2FsZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICB2YWx1ZXMgPSBjYWxsYmFjay5hcHBseSh0aGlzLCBwYXJhbXMpO1xuICAgIH1cblxuICAgIHZhbHVlcyA9IFtdLmNvbmNhdCh2YWx1ZXMpO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07IC8vIOWOn+Wni+eahOWPguaVsFxuXG5cbiAgX3Byb3RvLl90b09yaWdpblBhcmFtID0gZnVuY3Rpb24gX3RvT3JpZ2luUGFyYW0ocGFyYW0sIHNjYWxlKSB7XG4gICAgdmFyIHJzdCA9IHBhcmFtO1xuXG4gICAgaWYgKCFzY2FsZS5pc0xpbmVhcikge1xuICAgICAgaWYgKGlzQXJyYXkocGFyYW0pKSB7XG4gICAgICAgIHJzdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJhbS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHJzdC5wdXNoKHRvU2NhbGVTdHJpbmcoc2NhbGUsIHBhcmFtW2ldKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJzdCA9IHRvU2NhbGVTdHJpbmcoc2NhbGUsIHBhcmFtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIHJldHVybiBBdHRyaWJ1dGVCYXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF0dHJpYnV0ZUJhc2U7XG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xuXG52YXIgUGxvdCA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBDb29yZCA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xuXG52YXIgR2VvbSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBTY2FsZUNvbnRyb2xsZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcwKTtcblxudmFyIEF4aXNDb250cm9sbGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nik7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxuICAgIENhbnZhcyA9IF9yZXF1aXJlLkNhbnZhcztcblxudmFyIEhlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5mdW5jdGlvbiBpc0Z1bGxDaXJjbGUoY29vcmQpIHtcbiAgdmFyIHN0YXJ0QW5nbGUgPSBjb29yZC5zdGFydEFuZ2xlO1xuICB2YXIgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcblxuICBpZiAoIVV0aWwuaXNOaWwoc3RhcnRBbmdsZSkgJiYgIVV0aWwuaXNOaWwoZW5kQW5nbGUpICYmIGVuZEFuZ2xlIC0gc3RhcnRBbmdsZSA8IE1hdGguUEkgKiAyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIF9pc1NjYWxlRXhpc3Qoc2NhbGVzLCBjb21wYXJlU2NhbGUpIHtcbiAgdmFyIGZsYWcgPSBmYWxzZTtcbiAgVXRpbC5lYWNoKHNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgdmFyIHNjYWxlVmFsdWVzID0gW10uY29uY2F0KHNjYWxlLnZhbHVlcyk7XG4gICAgdmFyIGNvbXBhcmVTY2FsZVZhbHVlcyA9IFtdLmNvbmNhdChjb21wYXJlU2NhbGUudmFsdWVzKTtcblxuICAgIGlmIChzY2FsZS50eXBlID09PSBjb21wYXJlU2NhbGUudHlwZSAmJiBzY2FsZS5maWVsZCA9PT0gY29tcGFyZVNjYWxlLmZpZWxkICYmIHNjYWxlVmFsdWVzLnNvcnQoY29tcGFyZSkudG9TdHJpbmcoKSA9PT0gY29tcGFyZVNjYWxlVmFsdWVzLnNvcnQoY29tcGFyZSkudG9TdHJpbmcoKSkge1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGZsYWc7XG59XG5cbnZhciBDaGFydCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2hhcnQsIF9CYXNlKTtcblxuICBDaGFydC5pbml0UGx1Z2lucyA9IGZ1bmN0aW9uIGluaXRQbHVnaW5zKCkge1xuICAgIHJldHVybiB7XG4gICAgICBfcGx1Z2luczogW10sXG4gICAgICBfY2FjaGVJZDogMCxcbiAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihwbHVnaW5zKSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5fcGx1Z2lucztcbiAgICAgICAgW10uY29uY2F0KHBsdWdpbnMpLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgIGlmIChwLmluZGV4T2YocGx1Z2luKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHAucHVzaChwbHVnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NhY2hlSWQrKztcbiAgICAgIH0sXG4gICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbiB1bnJlZ2lzdGVyKHBsdWdpbnMpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLl9wbHVnaW5zO1xuICAgICAgICBbXS5jb25jYXQocGx1Z2lucykuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgICAgdmFyIGlkeCA9IHAuaW5kZXhPZihwbHVnaW4pO1xuXG4gICAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHAuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY2FjaGVJZCsrO1xuICAgICAgfSxcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fcGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLl9jYWNoZUlkKys7XG4gICAgICB9LFxuICAgICAgY291bnQ6IGZ1bmN0aW9uIGNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGx1Z2lucy5sZW5ndGg7XG4gICAgICB9LFxuICAgICAgZ2V0QWxsOiBmdW5jdGlvbiBnZXRBbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wbHVnaW5zO1xuICAgICAgfSxcbiAgICAgIG5vdGlmeTogZnVuY3Rpb24gbm90aWZ5KGNoYXJ0LCBob29rLCBhcmdzKSB7XG4gICAgICAgIHZhciBkZXNjcmlwdG9ycyA9IHRoaXMuZGVzY3JpcHRvcnMoY2hhcnQpO1xuICAgICAgICB2YXIgaWxlbiA9IGRlc2NyaXB0b3JzLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBkZXNjcmlwdG9yO1xuICAgICAgICB2YXIgcGx1Z2luO1xuICAgICAgICB2YXIgcGFyYW1zO1xuICAgICAgICB2YXIgbWV0aG9kO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbGVuOyArK2kpIHtcbiAgICAgICAgICBkZXNjcmlwdG9yID0gZGVzY3JpcHRvcnNbaV07XG4gICAgICAgICAgcGx1Z2luID0gZGVzY3JpcHRvci5wbHVnaW47XG4gICAgICAgICAgbWV0aG9kID0gcGx1Z2luW2hvb2tdO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBtZXRob2QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IFtjaGFydF0uY29uY2F0KGFyZ3MgfHwgW10pO1xuXG4gICAgICAgICAgICBpZiAobWV0aG9kLmFwcGx5KHBsdWdpbiwgcGFyYW1zKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSxcbiAgICAgIGRlc2NyaXB0b3JzOiBmdW5jdGlvbiBkZXNjcmlwdG9ycyhjaGFydCkge1xuICAgICAgICB2YXIgY2FjaGUgPSBjaGFydC5fcGx1Z2lucyB8fCAoY2hhcnQuX3BsdWdpbnMgPSB7fSk7XG5cbiAgICAgICAgaWYgKGNhY2hlLmlkID09PSB0aGlzLl9jYWNoZUlkKSB7XG4gICAgICAgICAgcmV0dXJuIGNhY2hlLmRlc2NyaXB0b3JzO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsdWdpbnMgPSBbXTtcbiAgICAgICAgdmFyIGRlc2NyaXB0b3JzID0gW107XG5cbiAgICAgICAgdGhpcy5fcGx1Z2lucy5jb25jYXQoY2hhcnQgJiYgY2hhcnQuZ2V0KCdwbHVnaW5zJykgfHwgW10pLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICAgIHZhciBpZHggPSBwbHVnaW5zLmluZGV4T2YocGx1Z2luKTtcblxuICAgICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgZGVzY3JpcHRvcnMucHVzaCh7XG4gICAgICAgICAgICBwbHVnaW46IHBsdWdpblxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYWNoZS5kZXNjcmlwdG9ycyA9IGRlc2NyaXB0b3JzO1xuICAgICAgICBjYWNoZS5pZCA9IHRoaXMuX2NhY2hlSWQ7XG4gICAgICAgIHJldHVybiBkZXNjcmlwdG9ycztcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBfcHJvdG8gPSBDaGFydC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICAvKipcbiAgICAgICAqIHRoZSBpZCBvZiBjYW52YXNcbiAgICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIGlkOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIHBhZGRpbmdcbiAgICAgICAqIEB0eXBlIHtBcnJheXxOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHBhZGRpbmc6IEdsb2JhbC5wYWRkaW5nLFxuXG4gICAgICAvKipcbiAgICAgICAqIGRhdGFcbiAgICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgICAqL1xuICAgICAgZGF0YTogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBzY2FsZXMgb2YgY2hhcnRcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHNjYWxlczoge30sXG5cbiAgICAgIC8qKlxuICAgICAgICogQHByaXZhdGVcbiAgICAgICAqIGdlb21ldHJ5IGluc3RhbmNlc1xuICAgICAgICogQHR5cGUge0FycmF5fVxuICAgICAgICovXG4gICAgICBnZW9tczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBzY2FsZSBjb25maWd1cmF0aW9uXG4gICAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBjb2xEZWZzOiBudWxsLFxuICAgICAgcGl4ZWxSYXRpbzogR2xvYmFsLnBpeGVsUmF0aW8sXG5cbiAgICAgIC8qKlxuICAgICAgICogZmlsdGVyIG9wdGlvbnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGZpbHRlcnM6IG51bGwsXG4gICAgICBhcHBlbmRQYWRkaW5nOiBHbG9iYWwuYXBwZW5kUGFkZGluZ1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9zeW5jWVNjYWxlcyA9IGZ1bmN0aW9uIF9zeW5jWVNjYWxlcygpIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgc3luY1NjYWxlcyA9IFtdO1xuICAgIHZhciBtaW4gPSBbXTtcbiAgICB2YXIgbWF4ID0gW107XG4gICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgdmFyIHlTY2FsZSA9IGdlb20uZ2V0WVNjYWxlKCk7XG5cbiAgICAgIGlmICh5U2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgICAgc3luY1NjYWxlcy5wdXNoKHlTY2FsZSk7XG4gICAgICAgIG1pbi5wdXNoKHlTY2FsZS5taW4pO1xuICAgICAgICBtYXgucHVzaCh5U2NhbGUubWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCBtaW4pO1xuICAgIG1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIG1heCk7XG4gICAgVXRpbC5lYWNoKHN5bmNTY2FsZXMsIGZ1bmN0aW9uIChzY2FsZSkge1xuICAgICAgc2NhbGUuY2hhbmdlKHtcbiAgICAgICAgbWluOiBtaW5cbiAgICAgIH0pO1xuICAgICAgc2NhbGUuY2hhbmdlKHtcbiAgICAgICAgbWF4OiBtYXhcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0RmllbGRzRm9yTGVnZW5kID0gZnVuY3Rpb24gX2dldEZpZWxkc0ZvckxlZ2VuZCgpIHtcbiAgICB2YXIgZmllbGRzID0gW107XG4gICAgdmFyIGdlb21zID0gdGhpcy5nZXQoJ2dlb21zJyk7XG4gICAgVXRpbC5lYWNoKGdlb21zLCBmdW5jdGlvbiAoZ2VvbSkge1xuICAgICAgdmFyIGF0dHJPcHRpb25zID0gZ2VvbS5nZXQoJ2F0dHJPcHRpb25zJyk7XG4gICAgICB2YXIgYXR0ckNmZyA9IGF0dHJPcHRpb25zLmNvbG9yO1xuXG4gICAgICBpZiAoYXR0ckNmZyAmJiBhdHRyQ2ZnLmZpZWxkICYmIFV0aWwuaXNTdHJpbmcoYXR0ckNmZy5maWVsZCkpIHtcbiAgICAgICAgdmFyIGFyciA9IGF0dHJDZmcuZmllbGQuc3BsaXQoJyonKTtcbiAgICAgICAgVXRpbC5lYWNoKGFyciwgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICBpZiAoZmllbGRzLmluZGV4T2YoaXRlbSkgPT09IC0xKSB7XG4gICAgICAgICAgICBmaWVsZHMucHVzaChpdGVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBmaWVsZHM7XG4gIH07XG5cbiAgX3Byb3RvLl9jcmVhdGVTY2FsZSA9IGZ1bmN0aW9uIF9jcmVhdGVTY2FsZShmaWVsZCwgZGF0YSkge1xuICAgIHZhciBzY2FsZUNvbnRyb2xsZXIgPSB0aGlzLmdldCgnc2NhbGVDb250cm9sbGVyJyk7XG4gICAgcmV0dXJuIHNjYWxlQ29udHJvbGxlci5jcmVhdGVTY2FsZShmaWVsZCwgZGF0YSk7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGp1c3RTY2FsZSA9IGZ1bmN0aW9uIF9hZGp1c3RTY2FsZSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkID0gc2VsZi5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHhTY2FsZSA9IHNlbGYuZ2V0WFNjYWxlKCk7XG4gICAgdmFyIHlTY2FsZXMgPSBzZWxmLmdldFlTY2FsZXMoKTtcbiAgICB2YXIgc2NhbGVzID0gW107XG4gICAgeFNjYWxlICYmIHNjYWxlcy5wdXNoKHhTY2FsZSk7XG4gICAgc2NhbGVzID0gc2NhbGVzLmNvbmNhdCh5U2NhbGVzKTtcbiAgICB2YXIgaW5GdWxsQ2lyY2xlID0gY29vcmQuaXNQb2xhciAmJiBpc0Z1bGxDaXJjbGUoY29vcmQpO1xuICAgIHZhciBzY2FsZUNvbnRyb2xsZXIgPSBzZWxmLmdldCgnc2NhbGVDb250cm9sbGVyJyk7XG4gICAgdmFyIGNvbERlZnMgPSBzY2FsZUNvbnRyb2xsZXIuZGVmcztcbiAgICBVdGlsLmVhY2goc2NhbGVzLCBmdW5jdGlvbiAoc2NhbGUpIHtcbiAgICAgIGlmICgoc2NhbGUuaXNDYXRlZ29yeSB8fCBzY2FsZS5pc0lkZW50aXR5KSAmJiBzY2FsZS52YWx1ZXMgJiYgIShjb2xEZWZzW3NjYWxlLmZpZWxkXSAmJiBjb2xEZWZzW3NjYWxlLmZpZWxkXS5yYW5nZSkpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gc2NhbGUudmFsdWVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJhbmdlO1xuXG4gICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgIHJhbmdlID0gWzAuNSwgMV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHdpZHRoUmF0aW8gPSAxO1xuICAgICAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICAgICAgaWYgKGluRnVsbENpcmNsZSkge1xuICAgICAgICAgICAgaWYgKCFjb29yZC50cmFuc3Bvc2VkKSB7XG4gICAgICAgICAgICAgIHJhbmdlID0gWzAsIDEgLSAxIC8gY291bnRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2lkdGhSYXRpbyA9IEdsb2JhbC53aWR0aFJhdGlvLm11bHRpcGxlUGllO1xuICAgICAgICAgICAgICBvZmZzZXQgPSAxIC8gY291bnQgKiB3aWR0aFJhdGlvO1xuICAgICAgICAgICAgICByYW5nZSA9IFtvZmZzZXQgLyAyLCAxIC0gb2Zmc2V0IC8gMl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDEgLyBjb3VudCAqIDEgLyAyO1xuICAgICAgICAgICAgcmFuZ2UgPSBbb2Zmc2V0LCAxIC0gb2Zmc2V0XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZS5yYW5nZSA9IHJhbmdlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcblxuICAgICAgaWYgKGdlb20uZ2V0KCd0eXBlJykgPT09ICdpbnRlcnZhbCcpIHtcbiAgICAgICAgdmFyIHlTY2FsZSA9IGdlb20uZ2V0WVNjYWxlKCk7XG4gICAgICAgIHZhciBmaWVsZCA9IHlTY2FsZS5maWVsZCxcbiAgICAgICAgICAgIG1pbiA9IHlTY2FsZS5taW4sXG4gICAgICAgICAgICBtYXggPSB5U2NhbGUubWF4LFxuICAgICAgICAgICAgdHlwZSA9IHlTY2FsZS50eXBlO1xuXG4gICAgICAgIGlmICghKGNvbERlZnNbZmllbGRdICYmIGNvbERlZnNbZmllbGRdLm1pbikgJiYgdHlwZSAhPT0gJ3RpbWUnKSB7XG4gICAgICAgICAgaWYgKG1pbiA+IDApIHtcbiAgICAgICAgICAgIHlTY2FsZS5jaGFuZ2Uoe1xuICAgICAgICAgICAgICBtaW46IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWF4IDw9IDApIHtcbiAgICAgICAgICAgIHlTY2FsZS5jaGFuZ2Uoe1xuICAgICAgICAgICAgICBtYXg6IDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX3JlbW92ZUdlb21zID0gZnVuY3Rpb24gX3JlbW92ZUdlb21zKCkge1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuXG4gICAgd2hpbGUgKGdlb21zLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBnZW9tID0gZ2VvbXMuc2hpZnQoKTtcbiAgICAgIGdlb20uZGVzdHJveSgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2NsZWFyR2VvbXMgPSBmdW5jdGlvbiBfY2xlYXJHZW9tcygpIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW9tcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcbiAgICAgIGdlb20uY2xlYXIoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9jbGVhcklubmVyID0gZnVuY3Rpb24gX2NsZWFySW5uZXIoKSB7XG4gICAgdGhpcy5zZXQoJ3NjYWxlcycsIHt9KTtcbiAgICB0aGlzLnNldCgnbGVnZW5kSXRlbXMnLCBudWxsKTtcblxuICAgIHRoaXMuX2NsZWFyR2VvbXMoKTtcblxuICAgIENoYXJ0LnBsdWdpbnMubm90aWZ5KHRoaXMsICdjbGVhcklubmVyJyk7XG4gICAgdGhpcy5nZXQoJ2F4aXNDb250cm9sbGVyJykgJiYgdGhpcy5nZXQoJ2F4aXNDb250cm9sbGVyJykuY2xlYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uX2V4ZWNGaWx0ZXIgPSBmdW5jdGlvbiBfZXhlY0ZpbHRlcihkYXRhKSB7XG4gICAgdmFyIGZpbHRlcnMgPSB0aGlzLmdldCgnZmlsdGVycycpO1xuXG4gICAgaWYgKGZpbHRlcnMpIHtcbiAgICAgIGRhdGEgPSBkYXRhLmZpbHRlcihmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciByc3QgPSB0cnVlO1xuICAgICAgICBVdGlsLmVhY2goZmlsdGVycywgZnVuY3Rpb24gKGZuLCBrKSB7XG4gICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICByc3QgPSBmbihvYmpba10sIG9iaik7XG5cbiAgICAgICAgICAgIGlmICghcnN0KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnN0O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0R2VvbXMgPSBmdW5jdGlvbiBfaW5pdEdlb21zKGdlb21zKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGRhdGEgPSB0aGlzLmdldCgnZmlsdGVyZWREYXRhJyk7XG4gICAgdmFyIGNvbERlZnMgPSB0aGlzLmdldCgnY29sRGVmcycpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdlb21zLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZ2VvbSA9IGdlb21zW2ldO1xuICAgICAgZ2VvbS5zZXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgIGdlb20uc2V0KCdjb29yZCcsIGNvb3JkKTtcbiAgICAgIGdlb20uc2V0KCdjb2xEZWZzJywgY29sRGVmcyk7XG4gICAgICBnZW9tLmluaXQoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0Q29vcmQgPSBmdW5jdGlvbiBfaW5pdENvb3JkKCkge1xuICAgIHZhciBwbG90ID0gdGhpcy5nZXQoJ3Bsb3RSYW5nZScpO1xuICAgIHZhciBjb29yZENmZyA9IFV0aWwubWl4KHtcbiAgICAgIHR5cGU6ICdjYXJ0ZXNpYW4nXG4gICAgfSwgdGhpcy5nZXQoJ2Nvb3JkQ2ZnJyksIHtcbiAgICAgIHBsb3Q6IHBsb3RcbiAgICB9KTtcbiAgICB2YXIgdHlwZSA9IGNvb3JkQ2ZnLnR5cGU7XG4gICAgdmFyIEMgPSBDb29yZFtVdGlsLnVwcGVyRmlyc3QodHlwZSldO1xuICAgIHZhciBjb29yZCA9IG5ldyBDKGNvb3JkQ2ZnKTtcbiAgICB0aGlzLnNldCgnY29vcmQnLCBjb29yZCk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0TGF5b3V0ID0gZnVuY3Rpb24gX2luaXRMYXlvdXQoKSB7XG4gICAgdmFyIHBhZGRpbmcgPSB0aGlzLmdldCgnX3BhZGRpbmcnKTtcblxuICAgIGlmICghcGFkZGluZykge1xuICAgICAgcGFkZGluZyA9IHRoaXMuZ2V0KCdtYXJnaW4nKSB8fCB0aGlzLmdldCgncGFkZGluZycpO1xuICAgICAgcGFkZGluZyA9IFV0aWwucGFyc2VQYWRkaW5nKHBhZGRpbmcpO1xuICAgIH1cblxuICAgIHZhciB0b3AgPSBwYWRkaW5nWzBdID09PSAnYXV0bycgPyAwIDogcGFkZGluZ1swXTtcbiAgICB2YXIgcmlnaHQgPSBwYWRkaW5nWzFdID09PSAnYXV0bycgPyAwIDogcGFkZGluZ1sxXTtcbiAgICB2YXIgYm90dG9tID0gcGFkZGluZ1syXSA9PT0gJ2F1dG8nID8gMCA6IHBhZGRpbmdbMl07XG4gICAgdmFyIGxlZnQgPSBwYWRkaW5nWzNdID09PSAnYXV0bycgPyAwIDogcGFkZGluZ1szXTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciBwbG90ID0gbmV3IFBsb3Qoe1xuICAgICAgc3RhcnQ6IHtcbiAgICAgICAgeDogbGVmdCxcbiAgICAgICAgeTogdG9wXG4gICAgICB9LFxuICAgICAgZW5kOiB7XG4gICAgICAgIHg6IHdpZHRoIC0gcmlnaHQsXG4gICAgICAgIHk6IGhlaWdodCAtIGJvdHRvbVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdwbG90UmFuZ2UnLCBwbG90KTtcbiAgICB0aGlzLnNldCgncGxvdCcsIHBsb3QpO1xuICB9O1xuXG4gIF9wcm90by5faW5pdENhbnZhcyA9IGZ1bmN0aW9uIF9pbml0Q2FudmFzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgY2FudmFzID0gbmV3IENhbnZhcyh7XG4gICAgICAgIGVsOiBzZWxmLmdldCgnZWwnKSB8fCBzZWxmLmdldCgnaWQnKSxcbiAgICAgICAgY29udGV4dDogc2VsZi5nZXQoJ2NvbnRleHQnKSxcbiAgICAgICAgcGl4ZWxSYXRpbzogc2VsZi5nZXQoJ3BpeGVsUmF0aW8nKSxcbiAgICAgICAgd2lkdGg6IHNlbGYuZ2V0KCd3aWR0aCcpLFxuICAgICAgICBoZWlnaHQ6IHNlbGYuZ2V0KCdoZWlnaHQnKSxcbiAgICAgICAgZm9udEZhbWlseTogR2xvYmFsLmZvbnRGYW1pbHlcbiAgICAgIH0pO1xuICAgICAgc2VsZi5zZXQoJ2NhbnZhcycsIGNhbnZhcyk7XG4gICAgICBzZWxmLnNldCgnd2lkdGgnLCBjYW52YXMuZ2V0KCd3aWR0aCcpKTtcbiAgICAgIHNlbGYuc2V0KCdoZWlnaHQnLCBjYW52YXMuZ2V0KCdoZWlnaHQnKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIENoYXJ0LnBsdWdpbnMubm90aWZ5KHNlbGYsICdhZnRlckNhbnZhc0luaXQnKTtcblxuICAgIHNlbGYuX2luaXRMYXlvdXQoKTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXRMYXllcnMgPSBmdW5jdGlvbiBfaW5pdExheWVycygpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIHRoaXMuc2V0KCdiYWNrUGxvdCcsIGNhbnZhcy5hZGRHcm91cCgpKTtcbiAgICB0aGlzLnNldCgnbWlkZGxlUGxvdCcsIGNhbnZhcy5hZGRHcm91cCh7XG4gICAgICB6SW5kZXg6IDEwXG4gICAgfSkpO1xuICAgIHRoaXMuc2V0KCdmcm9udFBsb3QnLCBjYW52YXMuYWRkR3JvdXAoe1xuICAgICAgekluZGV4OiAyMFxuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8uX2luaXQgPSBmdW5jdGlvbiBfaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBzZWxmLl9pbml0Q2FudmFzKCk7XG5cbiAgICBzZWxmLl9pbml0TGF5ZXJzKCk7XG5cbiAgICBzZWxmLnNldCgnZ2VvbXMnLCBbXSk7XG4gICAgc2VsZi5zZXQoJ3NjYWxlQ29udHJvbGxlcicsIG5ldyBTY2FsZUNvbnRyb2xsZXIoKSk7XG4gICAgc2VsZi5zZXQoJ2F4aXNDb250cm9sbGVyJywgbmV3IEF4aXNDb250cm9sbGVyKHtcbiAgICAgIGZyb250UGxvdDogc2VsZi5nZXQoJ2Zyb250UGxvdCcpLmFkZEdyb3VwKHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXhpc0NvbnRhaW5lcidcbiAgICAgIH0pLFxuICAgICAgYmFja1Bsb3Q6IHNlbGYuZ2V0KCdiYWNrUGxvdCcpLmFkZEdyb3VwKHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXhpc0NvbnRhaW5lcidcbiAgICAgIH0pLFxuICAgICAgY2hhcnQ6IHNlbGZcbiAgICB9KSk7XG4gICAgQ2hhcnQucGx1Z2lucy5ub3RpZnkoc2VsZiwgJ2luaXQnKTtcbiAgfTtcblxuICBmdW5jdGlvbiBDaGFydChjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuXG4gICAgdmFyIHNlbGYgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcblxuICAgIFV0aWwuZWFjaChHZW9tLCBmdW5jdGlvbiAoZ2VvbUNvbnN0cnVjdG9yLCBjbGFzc05hbWUpIHtcbiAgICAgIHZhciBtZXRob2ROYW1lID0gVXRpbC5sb3dlckZpcnN0KGNsYXNzTmFtZSk7XG5cbiAgICAgIHNlbGZbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoY2ZnKSB7XG4gICAgICAgIHZhciBnZW9tID0gbmV3IGdlb21Db25zdHJ1Y3RvcihjZmcpO1xuICAgICAgICBzZWxmLmFkZEdlb20oZ2VvbSk7XG4gICAgICAgIHJldHVybiBnZW9tO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIHNlbGYuX2luaXQoKTtcblxuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICAvKipcbiAgICogc2V0IGRhdGEgYW5kIHNvbWUgc2NhbGUgY29uZmlndXJhdGlvblxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSAge0FycmF5fSBkYXRhIHRoZSBkYXRhc2V0IHRvIHZpc3VhbGl6ZVxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGNvbERlZnMgdGhlIGNvbmZpZ3VyYXRpb24gZm9yIHNjYWxlc1xuICAgKiBAcmV0dXJuIHtDaGFydH0gcmV0dXJuIHRoZSBjaGFydCBpbnN0YW5jZVxuICAgKi9cblxuXG4gIF9wcm90by5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoZGF0YSwgY29sRGVmcykge1xuICAgIHRoaXMuc2V0KCdkYXRhJywgZGF0YSk7XG5cbiAgICBpZiAoY29sRGVmcykge1xuICAgICAgdGhpcy5zY2FsZShjb2xEZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShmaWVsZCwgY2ZnKSB7XG4gICAgdmFyIGNvbERlZnMgPSB0aGlzLmdldCgnY29sRGVmcycpIHx8IHt9O1xuXG4gICAgaWYgKFV0aWwuaXNPYmplY3QoZmllbGQpKSB7XG4gICAgICBVdGlsLm1peChjb2xEZWZzLCBmaWVsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbERlZnNbZmllbGRdID0gY2ZnO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdjb2xEZWZzJywgY29sRGVmcyk7XG4gICAgdmFyIHNjYWxlQ29udHJvbGxlciA9IHRoaXMuZ2V0KCdzY2FsZUNvbnRyb2xsZXInKTtcbiAgICBzY2FsZUNvbnRyb2xsZXIuZGVmcyA9IGNvbERlZnM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIGNvbmZpZ3VyZSB0aGUgYXhpc1xuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSAge1N0cmluZ3xCb29sZWFufSBmaWVsZCB0aGUgZmllbGQgbmFtZSBvZiBkYXRhXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gZm9yIGF4aXNcbiAgICogQHJldHVybiB7Q2hhcnR9IHJldHVybiB0aGUgY2hhcnQgaW5zdGFuY2VcbiAgICovXG4gIDtcblxuICBfcHJvdG8uYXhpcyA9IGZ1bmN0aW9uIGF4aXMoZmllbGQsIGNmZykge1xuICAgIHZhciBheGlzQ29udHJvbGxlciA9IHRoaXMuZ2V0KCdheGlzQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFmaWVsZCkge1xuICAgICAgYXhpc0NvbnRyb2xsZXIuYXhpc0NmZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4aXNDb250cm9sbGVyLmF4aXNDZmcgPSBheGlzQ29udHJvbGxlci5heGlzQ2ZnIHx8IHt9O1xuICAgICAgYXhpc0NvbnRyb2xsZXIuYXhpc0NmZ1tmaWVsZF0gPSBjZmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIGNvbmZpZ3VyZSB0aGUgY29vcmRpbmF0ZVxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSBzZXQgdGhlIHR5cGUgb2YgY29vZGluYXRlXG4gICAqIEBwYXJhbSAge09iamVjdH0gY2ZnIGNvbmZpZ3VyYXRpb24gZm9yIGNvb3JkaW5hdGVcbiAgICogQHJldHVybiB7Q2hhcnR9IHJldHVybiB0aGUgY2hhcnQgaW5zdGFuY2VcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY29vcmQgPSBmdW5jdGlvbiBjb29yZCh0eXBlLCBjZmcpIHtcbiAgICB2YXIgY29vcmRDZmc7XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdCh0eXBlKSkge1xuICAgICAgY29vcmRDZmcgPSB0eXBlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb29yZENmZyA9IGNmZyB8fCB7fTtcbiAgICAgIGNvb3JkQ2ZnLnR5cGUgPSB0eXBlIHx8ICdjYXJ0ZXNpYW4nO1xuICAgIH1cblxuICAgIHRoaXMuc2V0KCdjb29yZENmZycsIGNvb3JkQ2ZnKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24gZmlsdGVyKGZpZWxkLCBjb25kaXRpb24pIHtcbiAgICB2YXIgZmlsdGVycyA9IHRoaXMuZ2V0KCdmaWx0ZXJzJykgfHwge307XG4gICAgZmlsdGVyc1tmaWVsZF0gPSBjb25kaXRpb247XG4gICAgdGhpcy5zZXQoJ2ZpbHRlcnMnLCBmaWx0ZXJzKTtcbiAgfVxuICAvKipcbiAgICogcmVuZGVyIHRoZSBjaGFydFxuICAgKiBAY2hhaW5hYmxlXG4gICAqIEByZXR1cm4ge0NoYXJ0fSByZXR1cm4gdGhlIGNoYXJ0IGluc3RhbmNlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBnZW9tcyA9IHRoaXMuZ2V0KCdnZW9tcycpO1xuICAgIHZhciBkYXRhID0gdGhpcy5nZXQoJ2RhdGEnKSB8fCBbXTtcblxuICAgIHZhciBmaWx0ZXJlZERhdGEgPSB0aGlzLl9leGVjRmlsdGVyKGRhdGEpOyAvLyBmaWx0ZXIgZGF0YVxuXG5cbiAgICB0aGlzLnNldCgnZmlsdGVyZWREYXRhJywgZmlsdGVyZWREYXRhKTtcblxuICAgIHRoaXMuX2luaXRDb29yZCgpOyAvLyBpbml0aWFsaXphdGlvbiBjb29yZGluYXRlIGluc3RhbmNlXG5cblxuICAgIENoYXJ0LnBsdWdpbnMubm90aWZ5KHRoaXMsICdiZWZvcmVHZW9tSW5pdCcpO1xuXG4gICAgdGhpcy5faW5pdEdlb21zKGdlb21zKTsgLy8gaW5pdCBhbGwgZ2VvbWV0cnkgaW5zdGFuY2VzXG5cblxuICAgIHRoaXMuZ2V0KCdzeW5jWScpICYmIHRoaXMuX3N5bmNZU2NhbGVzKCk7XG5cbiAgICB0aGlzLl9hZGp1c3RTY2FsZSgpOyAvLyBkbyBzb21lIGFkanVzdCBmb3IgZGF0YVxuXG5cbiAgICBDaGFydC5wbHVnaW5zLm5vdGlmeSh0aGlzLCAnYmVmb3JlR2VvbURyYXcnKTtcblxuICAgIHRoaXMuX3JlbmRlckF4aXMoKTtcblxuICAgIHZhciBtaWRkbGVQbG90ID0gdGhpcy5nZXQoJ21pZGRsZVBsb3QnKTtcblxuICAgIGlmICh0aGlzLmdldCgnbGltaXRJblBsb3QnKSAmJiAhbWlkZGxlUGxvdC5hdHRyKCdjbGlwJykpIHtcbiAgICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgICAgdmFyIGNsaXAgPSBIZWxwZXIuZ2V0Q2xpcChjb29yZCk7XG4gICAgICBjbGlwLnNldCgnY2FudmFzJywgbWlkZGxlUGxvdC5nZXQoJ2NhbnZhcycpKTtcbiAgICAgIG1pZGRsZVBsb3QuYXR0cignY2xpcCcsIGNsaXApO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZW9tcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGdlb20gPSBnZW9tc1tpXTtcbiAgICAgIGdlb20ucGFpbnQoKTtcbiAgICB9XG5cbiAgICBDaGFydC5wbHVnaW5zLm5vdGlmeSh0aGlzLCAnYWZ0ZXJHZW9tRHJhdycpO1xuICAgIGNhbnZhcy5zb3J0KCk7XG4gICAgdGhpcy5nZXQoJ2Zyb250UGxvdCcpLnNvcnQoKTtcbiAgICBDaGFydC5wbHVnaW5zLm5vdGlmeSh0aGlzLCAnYmVmb3JlQ2FudmFzRHJhdycpO1xuICAgIGNhbnZhcy5kcmF3KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIGNsZWFyIHRoZSBjaGFydCwgaW5jbHVkZSBnZW9tZXRyaXMgYW5kIGFsbCB0aGUgc2hhcGVzXG4gICAqIEBjaGFpbmFibGVcbiAgICogQHJldHVybiB7Q2hhcnR9IHJldHVybiB0aGUgY2hhcnRcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICBDaGFydC5wbHVnaW5zLm5vdGlmeSh0aGlzLCAnY2xlYXInKTtcblxuICAgIHRoaXMuX3JlbW92ZUdlb21zKCk7XG5cbiAgICB0aGlzLl9jbGVhcklubmVyKCk7XG5cbiAgICB0aGlzLnNldCgnZmlsdGVycycsIG51bGwpO1xuICAgIHRoaXMuc2V0KCdpc1VwZGF0ZScsIGZhbHNlKTtcbiAgICB0aGlzLnNldCgnX3BhZGRpbmcnLCBudWxsKTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5kcmF3KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlcGFpbnQgPSBmdW5jdGlvbiByZXBhaW50KCkge1xuICAgIHRoaXMuc2V0KCdpc1VwZGF0ZScsIHRydWUpO1xuICAgIENoYXJ0LnBsdWdpbnMubm90aWZ5KHRoaXMsICdyZXBhaW50Jyk7XG5cbiAgICB0aGlzLl9jbGVhcklubmVyKCk7XG5cbiAgICB0aGlzLnJlbmRlcigpO1xuICB9O1xuXG4gIF9wcm90by5jaGFuZ2VEYXRhID0gZnVuY3Rpb24gY2hhbmdlRGF0YShkYXRhKSB7XG4gICAgdGhpcy5zZXQoJ2RhdGEnLCBkYXRhKTtcbiAgICBDaGFydC5wbHVnaW5zLm5vdGlmeSh0aGlzLCAnY2hhbmdlRGF0YScpO1xuICAgIHRoaXMuc2V0KCdfcGFkZGluZycsIG51bGwpO1xuICAgIHRoaXMucmVwYWludCgpO1xuICB9O1xuXG4gIF9wcm90by5jaGFuZ2VTaXplID0gZnVuY3Rpb24gY2hhbmdlU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICB0aGlzLnNldCgnd2lkdGgnLCB3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpZHRoID0gdGhpcy5nZXQoJ3dpZHRoJyk7XG4gICAgfVxuXG4gICAgaWYgKGhlaWdodCkge1xuICAgICAgdGhpcy5zZXQoJ2hlaWdodCcsIGhlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlaWdodCA9IHRoaXMuZ2V0KCdoZWlnaHQnKTtcbiAgICB9XG5cbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5jaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpO1xuXG4gICAgdGhpcy5faW5pdExheW91dCgpO1xuXG4gICAgdGhpcy5yZXBhaW50KCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIGNhbnZhcy5kZXN0cm95KCk7XG4gICAgQ2hhcnQucGx1Z2lucy5ub3RpZnkodGhpcywgJ2FmdGVyQ2FudmFzRGVzdHJveWVkJyk7XG5cbiAgICBpZiAodGhpcy5faW50ZXJhY3Rpb25zKSB7XG4gICAgICBVdGlsLmVhY2godGhpcy5faW50ZXJhY3Rpb25zLCBmdW5jdGlvbiAoaW50ZXJhY3Rpb24pIHtcbiAgICAgICAgaW50ZXJhY3Rpb24uZGVzdHJveSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX0Jhc2UucHJvdG90eXBlLmRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogY2FsY3VsYXRlIGRhdGFzZXQncyBwb3NpdGlvbiBvbiBjYW52YXNcbiAgICogQHBhcmFtICB7T2JqZWN0fSByZWNvcmQgdGhlIGRhdGFzZXRcbiAgICogQHJldHVybiB7T2JqZWN0fSByZXR1cm4gdGhlIHBvc2l0aW9uXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0UG9zaXRpb24ocmVjb3JkKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb29yZCA9IHNlbGYuZ2V0KCdjb29yZCcpO1xuICAgIHZhciB4U2NhbGUgPSBzZWxmLmdldFhTY2FsZSgpO1xuICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZXMoKVswXTtcbiAgICB2YXIgeEZpZWxkID0geFNjYWxlLmZpZWxkO1xuICAgIHZhciB4ID0geFNjYWxlLnNjYWxlKHJlY29yZFt4RmllbGRdKTtcbiAgICB2YXIgeUZpZWxkID0geVNjYWxlLmZpZWxkO1xuICAgIHZhciB5ID0geVNjYWxlLnNjYWxlKHJlY29yZFt5RmllbGRdKTtcbiAgICByZXR1cm4gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0YSBpdGVtIG9mIHRoZSBwb2ludFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHBvaW50IGNhbnZhcyBwb3NpdGlvblxuICAgKiBAcmV0dXJuIHtPYmplY3R9IHJldHVybiB0aGUgZGF0YSBpdGVtXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFJlY29yZCA9IGZ1bmN0aW9uIGdldFJlY29yZChwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29vcmQgPSBzZWxmLmdldCgnY29vcmQnKTtcbiAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlID0gc2VsZi5nZXRZU2NhbGVzKClbMF07XG4gICAgdmFyIGludmVydFBvaW50ID0gY29vcmQuaW52ZXJ0UG9pbnQocG9pbnQpO1xuICAgIHZhciByZWNvcmQgPSB7fTtcbiAgICByZWNvcmRbeFNjYWxlLmZpZWxkXSA9IHhTY2FsZS5pbnZlcnQoaW52ZXJ0UG9pbnQueCk7XG4gICAgcmVjb3JkW3lTY2FsZS5maWVsZF0gPSB5U2NhbGUuaW52ZXJ0KGludmVydFBvaW50LnkpO1xuICAgIHJldHVybiByZWNvcmQ7XG4gIH1cbiAgLyoqXG4gICAqIGdldCB0aGUgZGF0YXNldCBvZiB0aGUgcG9pbnRcbiAgICogQHBhcmFtICB7T2JqZWN0fSBwb2ludCBjYW52YXMgcG9zaXRpb25cbiAgICogQHJldHVybiB7QXJyYXl9IHJldHVybiB0aGUgZGF0YXNldFxuICAqKi9cbiAgO1xuXG4gIF9wcm90by5nZXRTbmFwUmVjb3JkcyA9IGZ1bmN0aW9uIGdldFNuYXBSZWNvcmRzKHBvaW50KSB7XG4gICAgdmFyIGdlb20gPSB0aGlzLmdldCgnZ2VvbXMnKVswXTtcbiAgICB2YXIgZGF0YSA9IFtdO1xuXG4gICAgaWYgKGdlb20pIHtcbiAgICAgIC8vIG5lZWQgdG8ganVkZ2VcbiAgICAgIGRhdGEgPSBnZW9tLmdldFNuYXBSZWNvcmRzKHBvaW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICAvKipcbiAgICogY3JlYXQgc2NhbGUgaW5zdGFuY2VzXG4gICAqIEBwYXJhbSAge1N0cmluZ30gZmllbGQgZmllbGQgbmFtZSBvZiBkYXRhXG4gICAqIEByZXR1cm4ge1NjYWxlfSByZXR1cm4gdGhlIHNjYWxlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNyZWF0ZVNjYWxlID0gZnVuY3Rpb24gY3JlYXRlU2NhbGUoZmllbGQpIHtcbiAgICB2YXIgZGF0YSA9IHRoaXMuZ2V0KCdkYXRhJyk7XG4gICAgdmFyIGZpbHRlcmVkRGF0YSA9IHRoaXMuZ2V0KCdmaWx0ZXJlZERhdGEnKTtcblxuICAgIGlmIChmaWx0ZXJlZERhdGEubGVuZ3RoKSB7XG4gICAgICB2YXIgbGVnZW5kRmllbGRzID0gdGhpcy5fZ2V0RmllbGRzRm9yTGVnZW5kKCk7XG5cbiAgICAgIGlmIChsZWdlbmRGaWVsZHMuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICAgIGRhdGEgPSBmaWx0ZXJlZERhdGE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNjYWxlcyA9IHRoaXMuZ2V0KCdzY2FsZXMnKTtcblxuICAgIGlmICghc2NhbGVzW2ZpZWxkXSkge1xuICAgICAgc2NhbGVzW2ZpZWxkXSA9IHRoaXMuX2NyZWF0ZVNjYWxlKGZpZWxkLCBkYXRhKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2NhbGVzW2ZpZWxkXTtcbiAgfVxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBhZGQgZ2VvbWV0cnkgaW5zdGFuY2UgdG8gZ2VvbXNcbiAgICogQHBhcmFtIHtHZW9tfSBnZW9tIGdlb21ldHJ5IGluc3RhbmNlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmFkZEdlb20gPSBmdW5jdGlvbiBhZGRHZW9tKGdlb20pIHtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgbWlkZGxlUGxvdCA9IHRoaXMuZ2V0KCdtaWRkbGVQbG90Jyk7XG4gICAgZ2VvbXMucHVzaChnZW9tKTtcbiAgICBnZW9tLnNldCgnY2hhcnQnLCB0aGlzKTtcbiAgICBnZW9tLnNldCgnY29udGFpbmVyJywgbWlkZGxlUGxvdC5hZGRHcm91cCgpKTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBzY2FsZSBvZiB4IGF4aXNcbiAgICogQHJldHVybiB7U2NhbGV9IHJldHVybiB0aGUgc2NhbGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0WFNjYWxlID0gZnVuY3Rpb24gZ2V0WFNjYWxlKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZ2VvbXMgPSBzZWxmLmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgeFNjYWxlID0gZ2VvbXNbMF0uZ2V0WFNjYWxlKCk7XG4gICAgcmV0dXJuIHhTY2FsZTtcbiAgfVxuICAvKipcbiAgICogZ2V0IHRoZSBzY2FsZSBvZiB5IGF4aXNcbiAgICogQHJldHVybiB7QXJyYXl9IHJldHVybiB0aGUgc2NhbGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0WVNjYWxlcyA9IGZ1bmN0aW9uIGdldFlTY2FsZXMoKSB7XG4gICAgdmFyIGdlb21zID0gdGhpcy5nZXQoJ2dlb21zJyk7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgIHZhciB5U2NhbGUgPSBnZW9tLmdldFlTY2FsZSgpO1xuXG4gICAgICBpZiAocnN0LmluZGV4T2YoeVNjYWxlKSA9PT0gLTEpIHtcbiAgICAgICAgcnN0LnB1c2goeVNjYWxlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIF9wcm90by5nZXRMZWdlbmRJdGVtcyA9IGZ1bmN0aW9uIGdldExlZ2VuZEl0ZW1zKCkge1xuICAgIGlmICh0aGlzLmdldCgnbGVnZW5kSXRlbXMnKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KCdsZWdlbmRJdGVtcycpO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmRJdGVtcyA9IHt9O1xuICAgIHZhciBzY2FsZXMgPSBbXTtcbiAgICB2YXIgZ2VvbXMgPSB0aGlzLmdldCgnZ2VvbXMnKTtcbiAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICB2YXIgY29sb3JBdHRyID0gZ2VvbS5nZXRBdHRyKCdjb2xvcicpO1xuXG4gICAgICBpZiAoY29sb3JBdHRyKSB7XG4gICAgICAgIHZhciBzY2FsZSA9IGNvbG9yQXR0ci5nZXRTY2FsZSgnY29sb3InKTtcblxuICAgICAgICBpZiAoc2NhbGUudHlwZSAhPT0gJ2lkZW50aXR5JyAmJiAhX2lzU2NhbGVFeGlzdChzY2FsZXMsIHNjYWxlKSkge1xuICAgICAgICAgIHNjYWxlcy5wdXNoKHNjYWxlKTtcbiAgICAgICAgICB2YXIgZmllbGQgPSBzY2FsZS5maWVsZDtcbiAgICAgICAgICB2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuICAgICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICAgIFV0aWwuZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGljay50ZXh0O1xuICAgICAgICAgICAgdmFyIG5hbWUgPSB0ZXh0O1xuICAgICAgICAgICAgdmFyIHNjYWxlVmFsdWUgPSB0aWNrLnZhbHVlO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2NhbGUuaW52ZXJ0KHNjYWxlVmFsdWUpO1xuICAgICAgICAgICAgdmFyIGNvbG9yID0gY29sb3JBdHRyLm1hcHBpbmcodmFsdWUpLmpvaW4oJycpIHx8IEdsb2JhbC5kZWZhdWx0Q29sb3I7XG4gICAgICAgICAgICB2YXIgbWFya2VyID0ge1xuICAgICAgICAgICAgICBmaWxsOiBjb2xvcixcbiAgICAgICAgICAgICAgcmFkaXVzOiAzLFxuICAgICAgICAgICAgICBzeW1ib2w6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICBzdHJva2U6ICcjZmZmJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAvLyBmb3IgZGlzcGxheVxuICAgICAgICAgICAgICBkYXRhVmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgICAvLyB0aGUgb3JpZ2luIHZhbHVlXG4gICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWUsXG4gICAgICAgICAgICAgIG1hcmtlcjogbWFya2VyXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZWdlbmRJdGVtc1tmaWVsZF0gPSBpdGVtcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2V0KCdsZWdlbmRJdGVtcycsIGxlZ2VuZEl0ZW1zKTtcbiAgICByZXR1cm4gbGVnZW5kSXRlbXM7XG4gIH0gLy8gcmVnaXN0ZXIgdGhlIHBsdWdpbnNcbiAgO1xuXG4gIF9wcm90by5yZWdpc3RlclBsdWdpbnMgPSBmdW5jdGlvbiByZWdpc3RlclBsdWdpbnMocGx1Z2lucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhcnRQbHVnaW5zID0gc2VsZi5nZXQoJ3BsdWdpbnMnKSB8fCBbXTtcblxuICAgIGlmICghVXRpbC5pc0FycmF5KGNoYXJ0UGx1Z2lucykpIHtcbiAgICAgIGNoYXJ0UGx1Z2lucyA9IFtjaGFydFBsdWdpbnNdO1xuICAgIH1cblxuICAgIFtdLmNvbmNhdChwbHVnaW5zKS5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIGlmIChjaGFydFBsdWdpbnMuaW5kZXhPZihwbHVnaW4pID09PSAtMSkge1xuICAgICAgICBwbHVnaW4uaW5pdCAmJiBwbHVnaW4uaW5pdChzZWxmKTsgLy8gaW5pdFxuXG4gICAgICAgIGNoYXJ0UGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgQ2hhcnQucGx1Z2lucy5fY2FjaGVJZCsrO1xuICAgIHNlbGYuc2V0KCdwbHVnaW5zJywgY2hhcnRQbHVnaW5zKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckF4aXMgPSBmdW5jdGlvbiBfcmVuZGVyQXhpcygpIHtcbiAgICB2YXIgYXhpc0NvbnRyb2xsZXIgPSB0aGlzLmdldCgnYXhpc0NvbnRyb2xsZXInKTtcbiAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlcyA9IHRoaXMuZ2V0WVNjYWxlcygpO1xuICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgIENoYXJ0LnBsdWdpbnMubm90aWZ5KHRoaXMsICdiZWZvcmVSZW5kZXJBeGlzJyk7XG4gICAgYXhpc0NvbnRyb2xsZXIuY3JlYXRlQXhpcyhjb29yZCwgeFNjYWxlLCB5U2NhbGVzKTtcbiAgfTtcblxuICBfcHJvdG8uX2lzQXV0b1BhZGRpbmcgPSBmdW5jdGlvbiBfaXNBdXRvUGFkZGluZygpIHtcbiAgICBpZiAodGhpcy5nZXQoJ19wYWRkaW5nJykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0KCdwYWRkaW5nJyk7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHBhZGRpbmcpKSB7XG4gICAgICByZXR1cm4gcGFkZGluZy5pbmRleE9mKCdhdXRvJykgIT09IC0xO1xuICAgIH1cblxuICAgIHJldHVybiBwYWRkaW5nID09PSAnYXV0byc7XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVMYXlvdXQgPSBmdW5jdGlvbiBfdXBkYXRlTGF5b3V0KHBhZGRpbmcpIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldCgnd2lkdGgnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciBzdGFydCA9IHtcbiAgICAgIHg6IHBhZGRpbmdbM10sXG4gICAgICB5OiBwYWRkaW5nWzBdXG4gICAgfTtcbiAgICB2YXIgZW5kID0ge1xuICAgICAgeDogd2lkdGggLSBwYWRkaW5nWzFdLFxuICAgICAgeTogaGVpZ2h0IC0gcGFkZGluZ1syXVxuICAgIH07XG4gICAgdmFyIHBsb3QgPSB0aGlzLmdldCgncGxvdCcpO1xuICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuICAgIHBsb3QucmVzZXQoc3RhcnQsIGVuZCk7XG4gICAgY29vcmQucmVzZXQocGxvdCk7XG4gIH07XG5cbiAgcmV0dXJuIENoYXJ0O1xufShCYXNlKTtcblxuQ2hhcnQucGx1Z2lucyA9IENoYXJ0LmluaXRQbHVnaW5zKCk7XG5tb2R1bGUuZXhwb3J0cyA9IENoYXJ0O1xuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG52YXIgaXNUeXBlID0gZnVuY3Rpb24gaXNUeXBlKHZhbHVlLCB0eXBlKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVHlwZTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIOWIpOaWreaYr+WQpuaVsOWtl1xuICogQHJldHVybiB7Qm9vbGVhbn0g5piv5ZCm5pWw5a2XXG4gKi9cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxudmFyIGlzTnVtYmVyID0gZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ051bWJlcicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc051bWJlcjtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKHN0cikge1xuICByZXR1cm4gaXNUeXBlKHN0ciwgJ1N0cmluZycpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1N0cmluZztcblxuLyoqKi8gfSksXG4vKiAxOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgc2hhcGUgdXRpbFxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlVXRpbCA9IHtcbiAgc3BsaXRQb2ludHM6IGZ1bmN0aW9uIHNwbGl0UG9pbnRzKG9iaikge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICB2YXIgeCA9IG9iai54O1xuICAgIHZhciB5ID0gb2JqLnk7XG4gICAgeSA9IFV0aWwuaXNBcnJheSh5KSA/IHkgOiBbeV07XG4gICAgeS5mb3JFYWNoKGZ1bmN0aW9uICh5SXRlbSwgaW5kZXgpIHtcbiAgICAgIHZhciBwb2ludCA9IHtcbiAgICAgICAgeDogVXRpbC5pc0FycmF5KHgpID8geFtpbmRleF0gOiB4LFxuICAgICAgICB5OiB5SXRlbVxuICAgICAgfTtcbiAgICAgIHBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRzO1xuICB9LFxuICBzcGxpdEFycmF5OiBmdW5jdGlvbiBzcGxpdEFycmF5KGRhdGEsIHlGaWVsZCwgY29ubmVjdE51bGxzKSB7XG4gICAgaWYgKCFkYXRhLmxlbmd0aCkgcmV0dXJuIFtdO1xuICAgIHZhciBhcnIgPSBbXTtcbiAgICB2YXIgdG1wID0gW107XG4gICAgdmFyIHlWYWx1ZTtcbiAgICBVdGlsLmVhY2goZGF0YSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgeVZhbHVlID0gb2JqLl9vcmlnaW4gPyBvYmouX29yaWdpblt5RmllbGRdIDogb2JqW3lGaWVsZF07XG5cbiAgICAgIGlmIChjb25uZWN0TnVsbHMpIHtcbiAgICAgICAgaWYgKCFVdGlsLmlzTmlsKHlWYWx1ZSkpIHtcbiAgICAgICAgICB0bXAucHVzaChvYmopO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoVXRpbC5pc0FycmF5KHlWYWx1ZSkgJiYgVXRpbC5pc05pbCh5VmFsdWVbMF0pIHx8IFV0aWwuaXNOaWwoeVZhbHVlKSkge1xuICAgICAgICAgIGlmICh0bXAubGVuZ3RoKSB7XG4gICAgICAgICAgICBhcnIucHVzaCh0bXApO1xuICAgICAgICAgICAgdG1wID0gW107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRtcC5wdXNoKG9iaik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0bXAubGVuZ3RoKSB7XG4gICAgICBhcnIucHVzaCh0bXApO1xuICAgIH1cblxuICAgIHJldHVybiBhcnI7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlVXRpbDtcblxuLyoqKi8gfSksXG4vKiAyMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5ID8gQXJyYXkuaXNBcnJheSA6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnQXJyYXknKTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXk7XG5cbi8qKiovIH0pLFxuLyogMjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge307XG5cbiAgZnVuY3Rpb24gQmFzZShjZmcpIHtcbiAgICB0aGlzLl9pbml0RGVmYXVsdENmZygpO1xuXG4gICAgVXRpbC5taXgodGhpcywgY2ZnKTtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0aGlzLnBsb3QpIHtcbiAgICAgIHN0YXJ0ID0gdGhpcy5wbG90LmJsO1xuICAgICAgZW5kID0gdGhpcy5wbG90LnRyO1xuICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5lbmQgPSBlbmQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0ID0gdGhpcy5zdGFydDtcbiAgICAgIGVuZCA9IHRoaXMuZW5kO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdChzdGFydCwgZW5kKTtcbiAgfVxuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHt9O1xuXG4gIF9wcm90by5jb252ZXJ0UG9pbnQgPSBmdW5jdGlvbiBjb252ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgX3Byb3RvLmludmVydFBvaW50ID0gZnVuY3Rpb24gaW52ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQocGxvdCkge1xuICAgIHRoaXMucGxvdCA9IHBsb3Q7XG4gICAgdmFyIGJsID0gcGxvdC5ibCxcbiAgICAgICAgdHIgPSBwbG90LnRyO1xuICAgIHRoaXMuc3RhcnQgPSBibDtcbiAgICB0aGlzLmVuZCA9IHRyO1xuICAgIHRoaXMuaW5pdChibCwgdHIpO1xuICB9O1xuXG4gIHJldHVybiBCYXNlO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cbi8qKiovIH0pLFxuLyogMjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX21peChkaXN0LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGlzdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG59XG5cbnZhciBtaXggPSBmdW5jdGlvbiBtaXgoZGlzdCwgc3JjMSwgc3JjMiwgc3JjMykge1xuICBpZiAoc3JjMSkgX21peChkaXN0LCBzcmMxKTtcbiAgaWYgKHNyYzIpIF9taXgoZGlzdCwgc3JjMik7XG4gIGlmIChzcmMzKSBfbWl4KGRpc3QsIHNyYzMpO1xuICByZXR1cm4gZGlzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWl4O1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBtaXggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcblxudmFyIEFkanVzdCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBBZGp1c3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy5hZGp1c3ROYW1lcyA9IFsneCcsICd5J107IC8vIOiwg+aVtOeahOe7tOW6pu+8jOm7mOiupCx4LHnpg73lgZrosIPmlbRcbiAgfTtcblxuICBmdW5jdGlvbiBBZGp1c3QoY2ZnKSB7XG4gICAgdGhpcy5faW5pdERlZmF1bHRDZmcoKTtcblxuICAgIG1peCh0aGlzLCBjZmcpO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICBfcHJvdG8ucHJvY2Vzc0FkanVzdCA9IGZ1bmN0aW9uIHByb2Nlc3NBZGp1c3QoKVxuICAvKiBkYXRhQXJyYXkgKi9cbiAge307XG5cbiAgcmV0dXJuIEFkanVzdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBZGp1c3Q7XG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIE1hdHJpeCA9IHtcbiAgbXVsdGlwbHk6IGZ1bmN0aW9uIG11bHRpcGx5KG0xLCBtMikge1xuICAgIHZhciBtMTEgPSBtMVswXSAqIG0yWzBdICsgbTFbMl0gKiBtMlsxXTtcbiAgICB2YXIgbTEyID0gbTFbMV0gKiBtMlswXSArIG0xWzNdICogbTJbMV07XG4gICAgdmFyIG0yMSA9IG0xWzBdICogbTJbMl0gKyBtMVsyXSAqIG0yWzNdO1xuICAgIHZhciBtMjIgPSBtMVsxXSAqIG0yWzJdICsgbTFbM10gKiBtMlszXTtcbiAgICB2YXIgZHggPSBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdO1xuICAgIHZhciBkeSA9IG0xWzFdICogbTJbNF0gKyBtMVszXSAqIG0yWzVdICsgbTFbNV07XG4gICAgcmV0dXJuIFttMTEsIG0xMiwgbTIxLCBtMjIsIGR4LCBkeV07XG4gIH0sXG4gIHNjYWxlOiBmdW5jdGlvbiBzY2FsZShvdXQsIG0sIHYpIHtcbiAgICBvdXRbMF0gPSBtWzBdICogdlswXTtcbiAgICBvdXRbMV0gPSBtWzFdICogdlswXTtcbiAgICBvdXRbMl0gPSBtWzJdICogdlsxXTtcbiAgICBvdXRbM10gPSBtWzNdICogdlsxXTtcbiAgICBvdXRbNF0gPSBtWzRdO1xuICAgIG91dFs1XSA9IG1bNV07XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcbiAgcm90YXRlOiBmdW5jdGlvbiByb3RhdGUob3V0LCBtLCByYWRpYW4pIHtcbiAgICB2YXIgYyA9IE1hdGguY29zKHJhZGlhbik7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWRpYW4pO1xuICAgIHZhciBtMTEgPSBtWzBdICogYyArIG1bMl0gKiBzO1xuICAgIHZhciBtMTIgPSBtWzFdICogYyArIG1bM10gKiBzO1xuICAgIHZhciBtMjEgPSBtWzBdICogLXMgKyBtWzJdICogYztcbiAgICB2YXIgbTIyID0gbVsxXSAqIC1zICsgbVszXSAqIGM7XG4gICAgb3V0WzBdID0gbTExO1xuICAgIG91dFsxXSA9IG0xMjtcbiAgICBvdXRbMl0gPSBtMjE7XG4gICAgb3V0WzNdID0gbTIyO1xuICAgIG91dFs0XSA9IG1bNF07XG4gICAgb3V0WzVdID0gbVs1XTtcbiAgICByZXR1cm4gb3V0O1xuICB9LFxuICB0cmFuc2xhdGU6IGZ1bmN0aW9uIHRyYW5zbGF0ZShvdXQsIG0sIHYpIHtcbiAgICBvdXRbMF0gPSBtWzBdO1xuICAgIG91dFsxXSA9IG1bMV07XG4gICAgb3V0WzJdID0gbVsyXTtcbiAgICBvdXRbM10gPSBtWzNdO1xuICAgIG91dFs0XSA9IG1bNF0gKyBtWzBdICogdlswXSArIG1bMl0gKiB2WzFdO1xuICAgIG91dFs1XSA9IG1bNV0gKyBtWzFdICogdlswXSArIG1bM10gKiB2WzFdO1xuICAgIHJldHVybiBvdXQ7XG4gIH0sXG4gIHRyYW5zZm9ybTogZnVuY3Rpb24gdHJhbnNmb3JtKG0sIGFjdGlvbnMpIHtcbiAgICB2YXIgb3V0ID0gW10uY29uY2F0KG0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFjdGlvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBhY3Rpb24gPSBhY3Rpb25zW2ldO1xuXG4gICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICBNYXRyaXgudHJhbnNsYXRlKG91dCwgb3V0LCBbYWN0aW9uWzFdLCBhY3Rpb25bMl1dKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdzJzpcbiAgICAgICAgICBNYXRyaXguc2NhbGUob3V0LCBvdXQsIFthY3Rpb25bMV0sIGFjdGlvblsyXV0pO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgIE1hdHJpeC5yb3RhdGUob3V0LCBvdXQsIGFjdGlvblsxXSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXg7XG5cbi8qKiovIH0pLFxuLyogMjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmo7XG59IDogZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbn07XG5cbnZhciBpc09iamVjdCA9IGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIC8qKlxuICAgKiBpc09iamVjdCh7fSkgPT4gdHJ1ZVxuICAgKiBpc09iamVjdChbMSwgMiwgM10pID0+IHRydWVcbiAgICogaXNPYmplY3QoRnVuY3Rpb24pID0+IHRydWVcbiAgICogaXNPYmplY3QobnVsbCkgPT4gZmFsc2VcbiAgICovXG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSk7XG4gIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlID09PSAnb2JqZWN0JyB8fCB0eXBlID09PSAnZnVuY3Rpb24nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgVmVjdG9yMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBBYmFzdHJhY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gQWJhc3RyYWN0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIC8qKlxuICAgICAqIHRpY2tzXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuICAgIHRoaXMudGlja3MgPSBbXTtcbiAgICAvKipcbiAgICAgKiB0aGUgY29uZmlndXJhdGlvbiBmb3IgdGlja0xpbmVcbiAgICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgICAqL1xuXG4gICAgdGhpcy50aWNrTGluZSA9IHt9O1xuICAgIC8qKlxuICAgICAqIHRoZSBkaXJlY3Rpb24gb2YgdGlja3MsIDEgbWVhbnMgY2xvY2t3aXNlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMub2Zmc2V0RmFjdG9yID0gMTtcbiAgICAvKipcbiAgICAgKiB0aGUgdG9wIGNvbnRhaW5lclxuICAgICAqIEB0eXBlIHtjb250YWluZXJ9XG4gICAgICovXG5cbiAgICB0aGlzLmZyb250Q29udGFpbmVyID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiB0aGUgYmFjayBjb250YWluZXJcbiAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAqL1xuXG4gICAgdGhpcy5iYWNrQ29udGFpbmVyID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBwb2ludHMgZm9yIGRyYXcgZ3JpZCBsaW5lXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgdGhpcy5ncmlkUG9pbnRzID0gW107XG4gIH07XG5cbiAgZnVuY3Rpb24gQWJhc3RyYWN0KGNmZykge1xuICAgIHRoaXMuX2luaXREZWZhdWx0Q2ZnKCk7XG5cbiAgICBVdGlsLm1peCh0aGlzLCBjZmcpO1xuICAgIHRoaXMuZHJhdygpO1xuICB9XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KCkge1xuICAgIHZhciBsaW5lID0gdGhpcy5saW5lLFxuICAgICAgICB0aWNrTGluZSA9IHRoaXMudGlja0xpbmUsXG4gICAgICAgIGxhYmVsID0gdGhpcy5sYWJlbCxcbiAgICAgICAgZ3JpZCA9IHRoaXMuZ3JpZDtcbiAgICBncmlkICYmIHRoaXMuZHJhd0dyaWQoZ3JpZCk7IC8vIGRyYXcgdGhlIGdyaWQgbGluZXNcblxuICAgIHRpY2tMaW5lICYmIHRoaXMuZHJhd1RpY2tzKHRpY2tMaW5lKTsgLy8gZHJhdyB0aGUgdGlja0xpbmVcblxuICAgIGxpbmUgJiYgdGhpcy5kcmF3TGluZShsaW5lKTsgLy8gZHJhdyBheGlzIGxpbmVcblxuICAgIGxhYmVsICYmIHRoaXMuZHJhd0xhYmVscygpOyAvLyBkcmF3IHRpY2tzXG4gIH07XG5cbiAgX3Byb3RvLmRyYXdUaWNrcyA9IGZ1bmN0aW9uIGRyYXdUaWNrcyh0aWNrQ2ZnKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrcyA9IHNlbGYudGlja3M7XG4gICAgdmFyIGxlbmd0aCA9IHRpY2tDZmcubGVuZ3RoO1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmdldENvbnRhaW5lcih0aWNrQ2ZnLnRvcCk7XG4gICAgVXRpbC5lYWNoKHRpY2tzLCBmdW5jdGlvbiAodGljaykge1xuICAgICAgdmFyIHN0YXJ0ID0gc2VsZi5nZXRPZmZzZXRQb2ludCh0aWNrLnZhbHVlKTtcbiAgICAgIHZhciBlbmQgPSBzZWxmLmdldFNpZGVQb2ludChzdGFydCwgbGVuZ3RoKTtcbiAgICAgIHZhciBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXhpcy10aWNrJyxcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICB4MTogc3RhcnQueCxcbiAgICAgICAgICB5MTogc3RhcnQueSxcbiAgICAgICAgICB4MjogZW5kLngsXG4gICAgICAgICAgeTI6IGVuZC55XG4gICAgICAgIH0sIHRpY2tDZmcpXG4gICAgICB9KTtcbiAgICAgIHNoYXBlLl9pZCA9IHNlbGYuX2lkICsgJy10aWNrcyc7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXdMYWJlbHMgPSBmdW5jdGlvbiBkcmF3TGFiZWxzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGFiZWxPZmZzZXQgPSBzZWxmLmxhYmVsT2Zmc2V0O1xuICAgIHZhciBsYWJlbHMgPSBzZWxmLmxhYmVscztcbiAgICBVdGlsLmVhY2gobGFiZWxzLCBmdW5jdGlvbiAobGFiZWxTaGFwZSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ2V0Q29udGFpbmVyKGxhYmVsU2hhcGUuZ2V0KCd0b3AnKSk7XG4gICAgICB2YXIgc3RhcnQgPSBzZWxmLmdldE9mZnNldFBvaW50KGxhYmVsU2hhcGUuZ2V0KCd2YWx1ZScpKTtcblxuICAgICAgdmFyIF9zZWxmJGdldFNpZGVQb2ludCA9IHNlbGYuZ2V0U2lkZVBvaW50KHN0YXJ0LCBsYWJlbE9mZnNldCksXG4gICAgICAgICAgeCA9IF9zZWxmJGdldFNpZGVQb2ludC54LFxuICAgICAgICAgIHkgPSBfc2VsZiRnZXRTaWRlUG9pbnQueTtcblxuICAgICAgbGFiZWxTaGFwZS5hdHRyKFV0aWwubWl4KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSwgc2VsZi5nZXRUZXh0QWxpZ25JbmZvKHN0YXJ0LCBsYWJlbE9mZnNldCksIGxhYmVsU2hhcGUuZ2V0KCd0ZXh0U3R5bGUnKSkpO1xuICAgICAgbGFiZWxTaGFwZS5faWQgPSBzZWxmLl9pZCArICctJyArIGxhYmVsU2hhcGUuYXR0cigndGV4dCcpO1xuICAgICAgY29udGFpbmVyLmFkZChsYWJlbFNoYXBlKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZSgpIHt9O1xuXG4gIF9wcm90by5kcmF3R3JpZCA9IGZ1bmN0aW9uIGRyYXdHcmlkKGdyaWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGdyaWRQb2ludHMgPSBzZWxmLmdyaWRQb2ludHMsXG4gICAgICAgIHRpY2tzID0gc2VsZi50aWNrcztcbiAgICB2YXIgZ3JpZENmZyA9IGdyaWQ7XG4gICAgdmFyIGNvdW50ID0gZ3JpZFBvaW50cy5sZW5ndGg7XG4gICAgVXRpbC5lYWNoKGdyaWRQb2ludHMsIGZ1bmN0aW9uIChzdWJQb2ludHMsIGluZGV4KSB7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGdyaWQpKSB7XG4gICAgICAgIHZhciB0aWNrID0gdGlja3NbaW5kZXhdIHx8IHt9O1xuICAgICAgICB2YXIgZXhlY3V0ZWRHcmlkID0gZ3JpZCh0aWNrLnRleHQsIGluZGV4LCBjb3VudCk7XG4gICAgICAgIGdyaWRDZmcgPSBleGVjdXRlZEdyaWQgPyBVdGlsLm1peCh7fSwgR2xvYmFsLl9kZWZhdWx0QXhpcy5ncmlkLCBleGVjdXRlZEdyaWQpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGdyaWRDZmcpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBncmlkQ2ZnLnR5cGU7IC8vIGhhcyB0d28gdHlwZXM6ICdsaW5lJyBhbmQgJ2FyYydcblxuICAgICAgICB2YXIgcG9pbnRzID0gc3ViUG9pbnRzLnBvaW50cztcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHNlbGYuZ2V0Q29udGFpbmVyKGdyaWRDZmcudG9wKTtcbiAgICAgICAgdmFyIHNoYXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSAnYXJjJykge1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBzZWxmLmNlbnRlcixcbiAgICAgICAgICAgICAgc3RhcnRBbmdsZSA9IHNlbGYuc3RhcnRBbmdsZSxcbiAgICAgICAgICAgICAgZW5kQW5nbGUgPSBzZWxmLmVuZEFuZ2xlO1xuICAgICAgICAgIHZhciByYWRpdXMgPSBWZWN0b3IyLmxlbmd0aChbcG9pbnRzWzBdLnggLSBjZW50ZXIueCwgcG9pbnRzWzBdLnkgLSBjZW50ZXIueV0pO1xuICAgICAgICAgIHNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdBcmMnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdheGlzLWdyaWQnLFxuICAgICAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgICAgICAgIHk6IGNlbnRlci55LFxuICAgICAgICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGUsXG4gICAgICAgICAgICAgIHI6IHJhZGl1c1xuICAgICAgICAgICAgfSwgZ3JpZENmZylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnUG9seWxpbmUnLCB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdheGlzLWdyaWQnLFxuICAgICAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICAgICAgcG9pbnRzOiBwb2ludHNcbiAgICAgICAgICAgIH0sIGdyaWRDZmcpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBzaGFwZS5faWQgPSBzdWJQb2ludHMuX2lkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5nZXRPZmZzZXRQb2ludCA9IGZ1bmN0aW9uIGdldE9mZnNldFBvaW50KCkge307XG5cbiAgX3Byb3RvLmdldEF4aXNWZWN0b3IgPSBmdW5jdGlvbiBnZXRBeGlzVmVjdG9yKCkge307XG5cbiAgX3Byb3RvLmdldE9mZnNldFZlY3RvciA9IGZ1bmN0aW9uIGdldE9mZnNldFZlY3Rvcihwb2ludCwgb2Zmc2V0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBheGlzVmVjdG9yID0gc2VsZi5nZXRBeGlzVmVjdG9yKHBvaW50KTtcbiAgICB2YXIgbm9ybWFsID0gVmVjdG9yMi5ub3JtYWxpemUoW10sIGF4aXNWZWN0b3IpO1xuICAgIHZhciBmYWN0b3IgPSBzZWxmLm9mZnNldEZhY3RvcjtcbiAgICB2YXIgdmVydGljYWxWZWN0b3IgPSBbbm9ybWFsWzFdICogLTEgKiBmYWN0b3IsIG5vcm1hbFswXSAqIGZhY3Rvcl07XG4gICAgcmV0dXJuIFZlY3RvcjIuc2NhbGUoW10sIHZlcnRpY2FsVmVjdG9yLCBvZmZzZXQpO1xuICB9O1xuXG4gIF9wcm90by5nZXRTaWRlUG9pbnQgPSBmdW5jdGlvbiBnZXRTaWRlUG9pbnQocG9pbnQsIG9mZnNldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb2Zmc2V0VmVjdG9yID0gc2VsZi5nZXRPZmZzZXRWZWN0b3IocG9pbnQsIG9mZnNldCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHBvaW50LnggKyBvZmZzZXRWZWN0b3JbMF0sXG4gICAgICB5OiBwb2ludC55ICsgb2Zmc2V0VmVjdG9yWzFdXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0VGV4dEFsaWduSW5mbyA9IGZ1bmN0aW9uIGdldFRleHRBbGlnbkluZm8ocG9pbnQsIG9mZnNldCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgb2Zmc2V0VmVjdG9yID0gc2VsZi5nZXRPZmZzZXRWZWN0b3IocG9pbnQsIG9mZnNldCk7XG4gICAgdmFyIGFsaWduO1xuICAgIHZhciBiYXNlTGluZTtcblxuICAgIGlmIChvZmZzZXRWZWN0b3JbMF0gPiAwKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKG9mZnNldFZlY3RvclswXSA8IDApIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ24gPSAnY2VudGVyJztcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0VmVjdG9yWzFdID4gMCkge1xuICAgICAgYmFzZUxpbmUgPSAndG9wJztcbiAgICB9IGVsc2UgaWYgKG9mZnNldFZlY3RvclsxXSA8IDApIHtcbiAgICAgIGJhc2VMaW5lID0gJ2JvdHRvbSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJhc2VMaW5lID0gJ21pZGRsZSc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHRBbGlnbjogYWxpZ24sXG4gICAgICB0ZXh0QmFzZWxpbmU6IGJhc2VMaW5lXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0Q29udGFpbmVyID0gZnVuY3Rpb24gZ2V0Q29udGFpbmVyKGlzVG9wKSB7XG4gICAgdmFyIGZyb250Q29udGFpbmVyID0gdGhpcy5mcm9udENvbnRhaW5lcixcbiAgICAgICAgYmFja0NvbnRhaW5lciA9IHRoaXMuYmFja0NvbnRhaW5lcjtcbiAgICByZXR1cm4gaXNUb3AgPyBmcm9udENvbnRhaW5lciA6IGJhY2tDb250YWluZXI7XG4gIH07XG5cbiAgcmV0dXJuIEFiYXN0cmFjdDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBYmFzdHJhY3Q7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgTWF0cml4VXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG52YXIgVmVjdG9yMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBTdHlsZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgwKTtcblxuZnVuY3Rpb24gaXNVbmNoYW5nZWQobSkge1xuICByZXR1cm4gbVswXSA9PT0gMSAmJiBtWzFdID09PSAwICYmIG1bMl0gPT09IDAgJiYgbVszXSA9PT0gMSAmJiBtWzRdID09PSAwICYmIG1bNV0gPT09IDA7XG59XG5cbnZhciBBTElBU19BVFRSU19NQVAgPSB7XG4gIHN0cm9rZTogJ3N0cm9rZVN0eWxlJyxcbiAgZmlsbDogJ2ZpbGxTdHlsZScsXG4gIG9wYWNpdHk6ICdnbG9iYWxBbHBoYSdcbn07XG52YXIgU0hBUEVfQVRUUlMgPSBbJ2ZpbGxTdHlsZScsICdmb250JywgJ2dsb2JhbEFscGhhJywgJ2xpbmVDYXAnLCAnbGluZVdpZHRoJywgJ2xpbmVKb2luJywgJ21pdGVyTGltaXQnLCAnc2hhZG93Qmx1cicsICdzaGFkb3dDb2xvcicsICdzaGFkb3dPZmZzZXRYJywgJ3NoYWRvd09mZnNldFknLCAnc3Ryb2tlU3R5bGUnLCAndGV4dEFsaWduJywgJ3RleHRCYXNlbGluZScsICdsaW5lRGFzaCcsICdzaGFkb3cnIC8vIOWFvOWuueaUr+S7mOWuneWwj+eoi+W6j1xuXTtcbnZhciBDTElQX1NIQVBFUyA9IFsnY2lyY2xlJywgJ3NlY3RvcicsICdwb2x5Z29uJywgJ3JlY3QnLCAncG9seWxpbmUnXTtcblxudmFyIEVsZW1lbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICB0aGlzLl9hdHRycyA9IHtcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIHZpc2libGU6IHRydWUsXG4gICAgICBkZXN0cm95ZWQ6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBFbGVtZW50KGNmZykge1xuICAgIHRoaXMuX2luaXRQcm9wZXJ0aWVzKCk7XG5cbiAgICBVdGlsLm1peCh0aGlzLl9hdHRycywgY2ZnKTtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycy5hdHRycztcblxuICAgIGlmIChhdHRycykge1xuICAgICAgdGhpcy5pbml0QXR0cnMoYXR0cnMpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdFRyYW5zZm9ybSgpO1xuICB9XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hdHRyc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5pc0dyb3VwID0gZnVuY3Rpb24gaXNHcm91cCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2lzR3JvdXAnKTtcbiAgfTtcblxuICBfcHJvdG8uaXNTaGFwZSA9IGZ1bmN0aW9uIGlzU2hhcGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdpc1NoYXBlJyk7XG4gIH07XG5cbiAgX3Byb3RvLmluaXRBdHRycyA9IGZ1bmN0aW9uIGluaXRBdHRycyhhdHRycykge1xuICAgIHRoaXMuYXR0cihVdGlsLm1peCh0aGlzLmdldERlZmF1bHRBdHRycygpLCBhdHRycykpO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWZhdWx0QXR0cnMgPSBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9O1xuXG4gIF9wcm90by5fc2V0QXR0ciA9IGZ1bmN0aW9uIF9zZXRBdHRyKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG5cbiAgICBpZiAobmFtZSA9PT0gJ2NsaXAnKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX3NldEF0dHJDbGlwKHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWFzID0gQUxJQVNfQVRUUlNfTUFQW25hbWVdO1xuXG4gICAgICBpZiAoYWxpYXMpIHtcbiAgICAgICAgYXR0cnNbYWxpYXNdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cnNbbmFtZV0gPSB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldEF0dHIgPSBmdW5jdGlvbiBfZ2V0QXR0cihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzLmF0dHJzW25hbWVdO1xuICB9IC8vIF9hZnRlckF0dHJzU2V0KCkge31cbiAgO1xuXG4gIF9wcm90by5fc2V0QXR0ckNsaXAgPSBmdW5jdGlvbiBfc2V0QXR0ckNsaXAoY2xpcCkge1xuICAgIGlmIChjbGlwICYmIENMSVBfU0hBUEVTLmluZGV4T2YoY2xpcC5fYXR0cnMudHlwZSkgPiAtMSkge1xuICAgICAgaWYgKGNsaXAuZ2V0KCdjYW52YXMnKSA9PT0gbnVsbCkge1xuICAgICAgICBjbGlwID0gT2JqZWN0LmFzc2lnbih7fSwgY2xpcCk7XG4gICAgICB9XG5cbiAgICAgIGNsaXAuc2V0KCdwYXJlbnQnLCB0aGlzLmdldCgncGFyZW50JykpO1xuICAgICAgY2xpcC5zZXQoJ2NvbnRleHQnLCB0aGlzLmdldCgnY29udGV4dCcpKTtcbiAgICAgIHJldHVybiBjbGlwO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIF9wcm90by5hdHRyID0gZnVuY3Rpb24gYXR0cihuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5nZXQoJ2Rlc3Ryb3llZCcpKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgYXJndW1lbnRzTGVuID0gYXJndW1lbnRzLmxlbmd0aDtcblxuICAgIGlmIChhcmd1bWVudHNMZW4gPT09IDApIHtcbiAgICAgIHJldHVybiBzZWxmLl9hdHRycy5hdHRycztcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc09iamVjdChuYW1lKSkge1xuICAgICAgdGhpcy5fYXR0cnMuYmJveCA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGsgaW4gbmFtZSkge1xuICAgICAgICBzZWxmLl9zZXRBdHRyKGssIG5hbWVba10pO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2VsZi5fYWZ0ZXJBdHRyc1NldCkge1xuICAgICAgICBzZWxmLl9hZnRlckF0dHJzU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzZWxmO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHNMZW4gPT09IDIpIHtcbiAgICAgIHRoaXMuX2F0dHJzLmJib3ggPSBudWxsO1xuXG4gICAgICBzZWxmLl9zZXRBdHRyKG5hbWUsIHZhbHVlKTtcblxuICAgICAgaWYgKHNlbGYuX2FmdGVyQXR0cnNTZXQpIHtcbiAgICAgICAgc2VsZi5fYWZ0ZXJBdHRyc1NldCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZi5fZ2V0QXR0cihuYW1lKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0UGFyZW50ID0gZnVuY3Rpb24gZ2V0UGFyZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldCgncGFyZW50Jyk7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGNvbnRleHQpIHtcbiAgICBpZiAodGhpcy5nZXQoJ2Rlc3Ryb3llZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgIHRoaXMuc2V0Q29udGV4dChjb250ZXh0KTtcbiAgICAgIHRoaXMuZHJhd0lubmVyKGNvbnRleHQpO1xuICAgICAgdGhpcy5yZXN0b3JlQ29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNldENvbnRleHQgPSBmdW5jdGlvbiBzZXRDb250ZXh0KGNvbnRleHQpIHtcbiAgICB2YXIgY2xpcCA9IHRoaXMuX2F0dHJzLmF0dHJzLmNsaXA7XG4gICAgY29udGV4dC5zYXZlKCk7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcC5yZXNldFRyYW5zZm9ybShjb250ZXh0KTtcbiAgICAgIGNsaXAuY3JlYXRlUGF0aChjb250ZXh0KTtcbiAgICAgIGNvbnRleHQuY2xpcCgpO1xuICAgIH1cblxuICAgIHRoaXMucmVzZXRDb250ZXh0KGNvbnRleHQpO1xuICAgIHRoaXMucmVzZXRUcmFuc2Zvcm0oY29udGV4dCk7XG4gIH07XG5cbiAgX3Byb3RvLnJlc3RvcmVDb250ZXh0ID0gZnVuY3Rpb24gcmVzdG9yZUNvbnRleHQoY29udGV4dCkge1xuICAgIGNvbnRleHQucmVzdG9yZSgpO1xuICB9O1xuXG4gIF9wcm90by5yZXNldENvbnRleHQgPSBmdW5jdGlvbiByZXNldENvbnRleHQoY29udGV4dCkge1xuICAgIHZhciBlbEF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG5cbiAgICBpZiAoIXRoaXMuX2F0dHJzLmlzR3JvdXApIHtcbiAgICAgIGZvciAodmFyIGsgaW4gZWxBdHRycykge1xuICAgICAgICBpZiAoU0hBUEVfQVRUUlMuaW5kZXhPZihrKSA+IC0xKSB7XG4gICAgICAgICAgdmFyIHYgPSBlbEF0dHJzW2tdO1xuXG4gICAgICAgICAgaWYgKGsgPT09ICdmaWxsU3R5bGUnIHx8IGsgPT09ICdzdHJva2VTdHlsZScpIHtcbiAgICAgICAgICAgIHYgPSBTdHlsZVV0aWwucGFyc2VTdHlsZSh2LCB0aGlzLCBjb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoayA9PT0gJ2xpbmVEYXNoJyAmJiBjb250ZXh0LnNldExpbmVEYXNoICYmIFV0aWwuaXNBcnJheSh2KSkge1xuICAgICAgICAgICAgY29udGV4dC5zZXRMaW5lRGFzaCh2KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29udGV4dFtrXSA9IHY7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oYXNGaWxsID0gZnVuY3Rpb24gaGFzRmlsbCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NhbkZpbGwnKSAmJiB0aGlzLl9hdHRycy5hdHRycy5maWxsU3R5bGU7XG4gIH07XG5cbiAgX3Byb3RvLmhhc1N0cm9rZSA9IGZ1bmN0aW9uIGhhc1N0cm9rZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NhblN0cm9rZScpICYmIHRoaXMuX2F0dHJzLmF0dHJzLnN0cm9rZVN0eWxlO1xuICB9O1xuXG4gIF9wcm90by5kcmF3SW5uZXIgPSBmdW5jdGlvbiBkcmF3SW5uZXIoKVxuICAvKiBjb250ZXh0ICovXG4gIHt9O1xuXG4gIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLnNldCgndmlzaWJsZScsIHRydWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB0aGlzLnNldCgndmlzaWJsZScsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uaXNWaXNpYmxlID0gZnVuY3Rpb24gaXNWaXNpYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldCgndmlzaWJsZScpO1xuICB9O1xuXG4gIF9wcm90by5fcmVtb3ZlRnJvbVBhcmVudCA9IGZ1bmN0aW9uIF9yZW1vdmVGcm9tUGFyZW50KCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldCgncGFyZW50Jyk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnQuZ2V0KCdjaGlsZHJlbicpO1xuICAgICAgVXRpbC5BcnJheS5yZW1vdmUoY2hpbGRyZW4sIHRoaXMpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5yZW1vdmUgPSBmdW5jdGlvbiByZW1vdmUoZGVzdHJveSkge1xuICAgIGlmIChkZXN0cm95KSB7XG4gICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdmFyIGRlc3Ryb3llZCA9IHRoaXMuZ2V0KCdkZXN0cm95ZWQnKTtcblxuICAgIGlmIChkZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbW92ZUZyb21QYXJlbnQoKTtcblxuICAgIHRoaXMuX2F0dHJzID0ge307XG4gICAgdGhpcy5zZXQoJ2Rlc3Ryb3llZCcsIHRydWUpO1xuICB9O1xuXG4gIF9wcm90by5nZXRCQm94ID0gZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogMCxcbiAgICAgIG1heFg6IDAsXG4gICAgICBtaW5ZOiAwLFxuICAgICAgbWF4WTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uaW5pdFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGluaXRUcmFuc2Zvcm0oKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnMgfHwge307XG5cbiAgICBpZiAoIWF0dHJzLm1hdHJpeCkge1xuICAgICAgYXR0cnMubWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIH1cblxuICAgIHRoaXMuX2F0dHJzLmF0dHJzID0gYXR0cnM7XG4gIH07XG5cbiAgX3Byb3RvLmdldE1hdHJpeCA9IGZ1bmN0aW9uIGdldE1hdHJpeCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4O1xuICB9O1xuXG4gIF9wcm90by5zZXRNYXRyaXggPSBmdW5jdGlvbiBzZXRNYXRyaXgobSkge1xuICAgIHRoaXMuX2F0dHJzLmF0dHJzLm1hdHJpeCA9IFttWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdXTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtKGFjdGlvbnMpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4O1xuICAgIHRoaXMuX2F0dHJzLmF0dHJzLm1hdHJpeCA9IE1hdHJpeFV0aWwudHJhbnNmb3JtKG1hdHJpeCwgYWN0aW9ucyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIHNldFRyYW5zZm9ybShhY3Rpb25zKSB7XG4gICAgdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4ID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShhY3Rpb25zKTtcbiAgfTtcblxuICBfcHJvdG8udHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKHgsIHkpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4O1xuICAgIE1hdHJpeFV0aWwudHJhbnNsYXRlKG1hdHJpeCwgbWF0cml4LCBbeCwgeV0pO1xuICB9O1xuXG4gIF9wcm90by5yb3RhdGUgPSBmdW5jdGlvbiByb3RhdGUocmFkKSB7XG4gICAgdmFyIG1hdHJpeCA9IHRoaXMuX2F0dHJzLmF0dHJzLm1hdHJpeDtcbiAgICBNYXRyaXhVdGlsLnJvdGF0ZShtYXRyaXgsIG1hdHJpeCwgcmFkKTtcbiAgfTtcblxuICBfcHJvdG8uc2NhbGUgPSBmdW5jdGlvbiBzY2FsZShzeCwgc3kpIHtcbiAgICB2YXIgbWF0cml4ID0gdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4O1xuICAgIE1hdHJpeFV0aWwuc2NhbGUobWF0cml4LCBtYXRyaXgsIFtzeCwgc3ldKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZVRvID0gZnVuY3Rpb24gbW92ZVRvKHgsIHkpIHtcbiAgICB2YXIgY3ggPSB0aGlzLl9hdHRycy54IHx8IDA7XG4gICAgdmFyIGN5ID0gdGhpcy5fYXR0cnMueSB8fCAwO1xuICAgIHRoaXMudHJhbnNsYXRlKHggLSBjeCwgeSAtIGN5KTtcbiAgICB0aGlzLnNldCgneCcsIHgpO1xuICAgIHRoaXMuc2V0KCd5JywgeSk7XG4gIH07XG5cbiAgX3Byb3RvLmFwcGx5ID0gZnVuY3Rpb24gYXBwbHkodikge1xuICAgIHZhciBtID0gdGhpcy5fYXR0cnMuYXR0cnMubWF0cml4O1xuICAgIFZlY3RvcjIudHJhbnNmb3JtTWF0MmQodiwgdiwgbSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm0oY29udGV4dCkge1xuICAgIHZhciBtbyA9IHRoaXMuX2F0dHJzLmF0dHJzLm1hdHJpeDtcblxuICAgIGlmICghaXNVbmNoYW5nZWQobW8pKSB7XG4gICAgICBjb250ZXh0LnRyYW5zZm9ybShtb1swXSwgbW9bMV0sIG1vWzJdLCBtb1szXSwgbW9bNF0sIG1vWzVdKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmlzRGVzdHJveWVkID0gZnVuY3Rpb24gaXNEZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KCdkZXN0cm95ZWQnKTtcbiAgfTtcblxuICByZXR1cm4gRWxlbWVudDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50O1xuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gICAgU2hhcGUgPSBfcmVxdWlyZS5TaGFwZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENsaXA6IGZ1bmN0aW9uIGdldENsaXAoY29vcmQpIHtcbiAgICB2YXIgc3RhcnQgPSBjb29yZC5zdGFydDtcbiAgICB2YXIgZW5kID0gY29vcmQuZW5kO1xuICAgIHZhciB3aWR0aCA9IGVuZC54IC0gc3RhcnQueDtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5hYnMoZW5kLnkgLSBzdGFydC55KTtcbiAgICB2YXIgbWFyZ2luID0gMTA7XG4gICAgdmFyIGNsaXA7XG5cbiAgICBpZiAoY29vcmQuaXNQb2xhcikge1xuICAgICAgdmFyIGNpcmNsZVJhZGl1cyA9IGNvb3JkLmNpcmNsZVJhZGl1cyxcbiAgICAgICAgICBjZW50ZXIgPSBjb29yZC5jZW50ZXIsXG4gICAgICAgICAgc3RhcnRBbmdsZSA9IGNvb3JkLnN0YXJ0QW5nbGUsXG4gICAgICAgICAgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcbiAgICAgIGNsaXAgPSBuZXcgU2hhcGUuU2VjdG9yKHtcbiAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICB4OiBjZW50ZXIueCxcbiAgICAgICAgICB5OiBjZW50ZXIueSxcbiAgICAgICAgICByOiBjaXJjbGVSYWRpdXMsXG4gICAgICAgICAgcjA6IDAsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsaXAgPSBuZXcgU2hhcGUuUmVjdCh7XG4gICAgICAgIGF0dHJzOiB7XG4gICAgICAgICAgeDogc3RhcnQueCxcbiAgICAgICAgICB5OiBlbmQueSAtIG1hcmdpbixcbiAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBoZWlnaHQgKyAyICogbWFyZ2luXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNsaXAuaXNDbGlwID0gdHJ1ZTtcbiAgICByZXR1cm4gY2xpcDtcbiAgfSxcbiAgaXNQb2ludEluUGxvdDogZnVuY3Rpb24gaXNQb2ludEluUGxvdChwb2ludCwgcGxvdCkge1xuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgdmFyIHRsID0gcGxvdC50bCxcbiAgICAgICAgdHIgPSBwbG90LnRyLFxuICAgICAgICBiciA9IHBsb3QuYnI7XG4gICAgcmV0dXJuIHggPj0gdGwueCAmJiB4IDw9IHRyLnggJiYgeSA+PSB0bC55ICYmIHkgPD0gYnIueTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcblxuZnVuY3Rpb24gdG9TdHJpbmcodmFsdWUpIHtcbiAgaWYgKGlzTmlsKHZhbHVlKSkgcmV0dXJuICcnO1xuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b1N0cmluZztcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vLyBpc0Zpbml0ZSxcbnZhciBpc05pbCA9IGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gIC8qKlxuICAgKiBpc05pbChudWxsKSA9PiB0cnVlXG4gICAqIGlzTmlsKCkgPT4gdHJ1ZVxuICAgKi9cbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTmlsO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqO1xufSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG59O1xuXG52YXIgaXNPYmplY3QgPSBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZSkge1xuICAvKipcbiAgICogaXNPYmplY3Qoe30pID0+IHRydWVcbiAgICogaXNPYmplY3QoWzEsIDIsIDNdKSA9PiB0cnVlXG4gICAqIGlzT2JqZWN0KEZ1bmN0aW9uKSA9PiB0cnVlXG4gICAqIGlzT2JqZWN0KG51bGwpID0+IGZhbHNlXG4gICAqL1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodmFsdWUpO1xuICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMzIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIGlzT2JqZWN0TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpO1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIGlzUGxhaW5PYmplY3QgPSBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIC8qKlxuICAgKiBpc09iamVjdExpa2UobmV3IEZvbykgPT4gZmFsc2VcbiAgICogaXNPYmplY3RMaWtlKFsxLCAyLCAzXSkgPT4gZmFsc2VcbiAgICogaXNPYmplY3RMaWtlKHsgeDogMCwgeTogMCB9KSA9PiB0cnVlXG4gICAqIGlzT2JqZWN0TGlrZShPYmplY3QuY3JlYXRlKG51bGwpKSA9PiB0cnVlXG4gICAqL1xuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgIWlzVHlwZSh2YWx1ZSwgJ09iamVjdCcpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBwcm90byA9IHZhbHVlO1xuXG4gIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xuXG4vKioqLyB9KSxcbi8qIDMzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc09iamVjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuXG52YXIgZWFjaCA9IGZ1bmN0aW9uIGVhY2goZWxlbWVudHMsIGZ1bmMpIHtcbiAgaWYgKCFlbGVtZW50cykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByc3QgPSB2b2lkIDA7XG5cbiAgaWYgKGlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2ldLCBpKTtcblxuICAgICAgaWYgKHJzdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGVsZW1lbnRzKSkge1xuICAgIGZvciAodmFyIGsgaW4gZWxlbWVudHMpIHtcbiAgICAgIGlmIChlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2tdLCBrKTtcblxuICAgICAgICBpZiAocnN0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhY2g7XG5cbi8qKiovIH0pLFxuLyogMzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IEJhc2UgY2xhc3Mgb2YgY2hhcnQgYW5kIGdlb21ldHJ5XG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQmFzZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBCYXNlLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEJhc2UoY2ZnKSB7XG4gICAgdmFyIGF0dHJzID0ge307XG4gICAgdmFyIGRlZmF1bHRDZmcgPSB0aGlzLmdldERlZmF1bHRDZmcoKTtcbiAgICB0aGlzLl9hdHRycyA9IGF0dHJzO1xuICAgIFV0aWwubWl4KGF0dHJzLCBkZWZhdWx0Q2ZnLCBjZmcpO1xuICB9XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hdHRyc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIF9wcm90by5kZXN0cm95ID0gZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICB0aGlzLl9hdHRycyA9IHt9O1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcblxuICByZXR1cm4gQmFzZTtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIFNIQVBFX01BUCA9IHt9O1xudmFyIElOREVYID0gJ19JTkRFWCc7XG5cbmZ1bmN0aW9uIGdldENvbXBhcmVyKGNvbXBhcmUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xuICAgIHZhciByZXN1bHQgPSBjb21wYXJlKGxlZnQsIHJpZ2h0KTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSAwID8gbGVmdFtJTkRFWF0gLSByaWdodFtJTkRFWF0gOiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRHcm91cENsYXNzOiBmdW5jdGlvbiBnZXRHcm91cENsYXNzKCkge30sXG4gIGdldENoaWxkcmVuOiBmdW5jdGlvbiBnZXRDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG4gIH0sXG4gIGFkZFNoYXBlOiBmdW5jdGlvbiBhZGRTaGFwZSh0eXBlLCBjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBjYW52YXMgPSB0aGlzLmdldCgnY2FudmFzJyk7XG4gICAgdmFyIHNoYXBlVHlwZSA9IFNIQVBFX01BUFt0eXBlXTtcblxuICAgIGlmICghc2hhcGVUeXBlKSB7XG4gICAgICBzaGFwZVR5cGUgPSBVdGlsLnVwcGVyRmlyc3QodHlwZSk7XG4gICAgICBTSEFQRV9NQVBbdHlwZV0gPSBzaGFwZVR5cGU7XG4gICAgfVxuXG4gICAgY2ZnLmNhbnZhcyA9IGNhbnZhcztcblxuICAgIGlmIChzaGFwZVR5cGUgPT09ICdUZXh0JyAmJiBjYW52YXMgJiYgY2FudmFzLmdldCgnZm9udEZhbWlseScpKSB7XG4gICAgICBjZmcuYXR0cnMuZm9udEZhbWlseSA9IGNmZy5hdHRycy5mb250RmFtaWx5IHx8IGNhbnZhcy5nZXQoJ2ZvbnRGYW1pbHknKTtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBuZXcgU2hhcGVbc2hhcGVUeXBlXShjZmcpO1xuICAgIHRoaXMuYWRkKHNoYXBlKTtcbiAgICByZXR1cm4gc2hhcGU7XG4gIH0sXG4gIGFkZEdyb3VwOiBmdW5jdGlvbiBhZGRHcm91cChjZmcpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBncm91cENsYXNzID0gdGhpcy5nZXRHcm91cENsYXNzKCk7XG4gICAgY2ZnID0gVXRpbC5taXgoe30sIGNmZyk7XG4gICAgY2ZnLmNhbnZhcyA9IGNhbnZhcztcbiAgICBjZmcucGFyZW50ID0gdGhpcztcbiAgICB2YXIgcnN0ID0gbmV3IGdyb3VwQ2xhc3MoY2ZnKTtcbiAgICB0aGlzLmFkZChyc3QpO1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGNvbnRhaW46IGZ1bmN0aW9uIGNvbnRhaW4oaXRlbSkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHJldHVybiBjaGlsZHJlbi5pbmRleE9mKGl0ZW0pID4gLTE7XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgY2hpbGRbSU5ERVhdID0gaTtcbiAgICB9XG5cbiAgICBjaGlsZHJlbi5zb3J0KGdldENvbXBhcmVyKGZ1bmN0aW9uIChvYmoxLCBvYmoyKSB7XG4gICAgICByZXR1cm4gb2JqMS5nZXQoJ3pJbmRleCcpIC0gb2JqMi5nZXQoJ3pJbmRleCcpO1xuICAgIH0pKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgd2hpbGUgKGNoaWxkcmVuLmxlbmd0aCAhPT0gMCkge1xuICAgICAgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0ucmVtb3ZlKHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uIGFkZChpdGVtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hpbGRyZW4gPSBzZWxmLmdldCgnY2hpbGRyZW4nKTtcblxuICAgIGlmICghVXRpbC5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgaXRlbXMgPSBbaXRlbXNdO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICAgIHZhciBwYXJlbnQgPSBpdGVtLmdldCgncGFyZW50Jyk7XG5cbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gcGFyZW50LmdldCgnY2hpbGRyZW4nKTtcbiAgICAgICAgVXRpbC5BcnJheS5yZW1vdmUoZGVzY2VuZGFudHMsIGl0ZW0pO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9zZXRFdm4oaXRlbSk7XG5cbiAgICAgIGNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNlbGY7XG4gIH0sXG4gIF9zZXRFdm46IGZ1bmN0aW9uIF9zZXRFdm4oaXRlbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpdGVtLl9hdHRycy5wYXJlbnQgPSBzZWxmO1xuICAgIGl0ZW0uX2F0dHJzLmNvbnRleHQgPSBzZWxmLl9hdHRycy5jb250ZXh0O1xuICAgIGl0ZW0uX2F0dHJzLmNhbnZhcyA9IHNlbGYuX2F0dHJzLmNhbnZhcztcbiAgICB2YXIgY2xpcCA9IGl0ZW0uX2F0dHJzLmF0dHJzLmNsaXA7XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgY2xpcC5zZXQoJ3BhcmVudCcsIHNlbGYpO1xuICAgICAgY2xpcC5zZXQoJ2NvbnRleHQnLCBzZWxmLmdldCgnY29udGV4dCcpKTtcbiAgICB9XG5cbiAgICBpZiAoaXRlbS5fYXR0cnMuaXNHcm91cCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbS5fYXR0cnMuY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtLl9zZXRFdm4oY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgRWxlbWVudCA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuXG52YXIgQ29udGFpbmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XG5cbnZhciBWZWN0b3IyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcblxudmFyIEdyb3VwID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfRWxlbWVudCkge1xuICBfaW5oZXJpdHNMb29zZShHcm91cCwgX0VsZW1lbnQpO1xuXG4gIGZ1bmN0aW9uIEdyb3VwKCkge1xuICAgIHJldHVybiBfRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gR3JvdXAucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBfaW5pdFByb3BlcnRpZXMoKSB7XG4gICAgdGhpcy5fYXR0cnMgPSB7XG4gICAgICB6SW5kZXg6IDAsXG4gICAgICB2aXNpYmxlOiB0cnVlLFxuICAgICAgZGVzdHJveWVkOiBmYWxzZSxcbiAgICAgIGlzR3JvdXA6IHRydWUsXG4gICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5kcmF3SW5uZXIgPSBmdW5jdGlvbiBkcmF3SW5uZXIoY29udGV4dCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0KCdjaGlsZHJlbicpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIGNoaWxkLmRyYXcoY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLmdldEJCb3ggPSBmdW5jdGlvbiBnZXRCQm94KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbWluWCA9IEluZmluaXR5O1xuICAgIHZhciBtYXhYID0gLUluZmluaXR5O1xuICAgIHZhciBtaW5ZID0gSW5maW5pdHk7XG4gICAgdmFyIG1heFkgPSAtSW5maW5pdHk7XG4gICAgdmFyIGNoaWxkcmVuID0gc2VsZi5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXG4gICAgICBpZiAoY2hpbGQuZ2V0KCd2aXNpYmxlJykpIHtcbiAgICAgICAgdmFyIGJveCA9IGNoaWxkLmdldEJCb3goKTtcblxuICAgICAgICBpZiAoIWJveCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlZnRUb3AgPSBbYm94Lm1pblgsIGJveC5taW5ZXTtcbiAgICAgICAgdmFyIGxlZnRCb3R0b20gPSBbYm94Lm1pblgsIGJveC5tYXhZXTtcbiAgICAgICAgdmFyIHJpZ2h0VG9wID0gW2JveC5tYXhYLCBib3gubWluWV07XG4gICAgICAgIHZhciByaWdodEJvdHRvbSA9IFtib3gubWF4WCwgYm94Lm1heFldO1xuICAgICAgICB2YXIgbWF0cml4ID0gY2hpbGQuYXR0cignbWF0cml4Jyk7XG4gICAgICAgIFZlY3RvcjIudHJhbnNmb3JtTWF0MmQobGVmdFRvcCwgbGVmdFRvcCwgbWF0cml4KTtcbiAgICAgICAgVmVjdG9yMi50cmFuc2Zvcm1NYXQyZChsZWZ0Qm90dG9tLCBsZWZ0Qm90dG9tLCBtYXRyaXgpO1xuICAgICAgICBWZWN0b3IyLnRyYW5zZm9ybU1hdDJkKHJpZ2h0VG9wLCByaWdodFRvcCwgbWF0cml4KTtcbiAgICAgICAgVmVjdG9yMi50cmFuc2Zvcm1NYXQyZChyaWdodEJvdHRvbSwgcmlnaHRCb3R0b20sIG1hdHJpeCk7XG4gICAgICAgIG1pblggPSBNYXRoLm1pbihsZWZ0VG9wWzBdLCBsZWZ0Qm90dG9tWzBdLCByaWdodFRvcFswXSwgcmlnaHRCb3R0b21bMF0sIG1pblgpO1xuICAgICAgICBtYXhYID0gTWF0aC5tYXgobGVmdFRvcFswXSwgbGVmdEJvdHRvbVswXSwgcmlnaHRUb3BbMF0sIHJpZ2h0Qm90dG9tWzBdLCBtYXhYKTtcbiAgICAgICAgbWluWSA9IE1hdGgubWluKGxlZnRUb3BbMV0sIGxlZnRCb3R0b21bMV0sIHJpZ2h0VG9wWzFdLCByaWdodEJvdHRvbVsxXSwgbWluWSk7XG4gICAgICAgIG1heFkgPSBNYXRoLm1heChsZWZ0VG9wWzFdLCBsZWZ0Qm90dG9tWzFdLCByaWdodFRvcFsxXSwgcmlnaHRCb3R0b21bMV0sIG1heFkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBtaW5YOiBtaW5YLFxuICAgICAgbWluWTogbWluWSxcbiAgICAgIG1heFg6IG1heFgsXG4gICAgICBtYXhZOiBtYXhZLFxuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1pblksXG4gICAgICB3aWR0aDogbWF4WCAtIG1pblgsXG4gICAgICBoZWlnaHQ6IG1heFkgLSBtaW5ZXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIF9FbGVtZW50LnByb3RvdHlwZS5kZXN0cm95LmNhbGwodGhpcyk7XG4gIH07XG5cbiAgcmV0dXJuIEdyb3VwO1xufShFbGVtZW50KTtcblxuVXRpbC5taXgoR3JvdXAucHJvdG90eXBlLCBDb250YWluZXIsIHtcbiAgZ2V0R3JvdXBDbGFzczogZnVuY3Rpb24gZ2V0R3JvdXBDbGFzcygpIHtcbiAgICByZXR1cm4gR3JvdXA7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBHcm91cDtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBTaGFwZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7IC8vIHJlZ2lzdGVyIGxpbmUgZ2VvbVxuXG5cbnZhciBMaW5lID0gU2hhcGUucmVnaXN0ZXJGYWN0b3J5KCdsaW5lJywge1xuICBkZWZhdWx0U2hhcGVUeXBlOiAnbGluZSdcbn0pO1xuXG5mdW5jdGlvbiBnZXRTdHlsZShjZmcpIHtcbiAgdmFyIHN0eWxlID0ge1xuICAgIHN0cm9rZVN0eWxlOiBjZmcuY29sb3JcbiAgfTtcblxuICBpZiAoY2ZnLnNpemUgPj0gMCkge1xuICAgIHN0eWxlLmxpbmVXaWR0aCA9IGNmZy5zaXplO1xuICB9XG5cbiAgVXRpbC5taXgoc3R5bGUsIGNmZy5zdHlsZSk7XG4gIHJldHVybiBVdGlsLm1peCh7fSwgR2xvYmFsLnNoYXBlLmxpbmUsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZHJhd0xpbmVzKGNmZywgY29udGFpbmVyLCBzdHlsZSwgc21vb3RoKSB7XG4gIHZhciBwb2ludHMgPSBjZmcucG9pbnRzO1xuXG4gIGlmIChwb2ludHMubGVuZ3RoICYmIFV0aWwuaXNBcnJheShwb2ludHNbMF0ueSkpIHtcbiAgICB2YXIgdG9wUG9pbnRzID0gW107XG4gICAgdmFyIGJvdHRvbVBvaW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuICAgICAgdmFyIHRtcCA9IFNoYXBlVXRpbC5zcGxpdFBvaW50cyhwb2ludCk7XG4gICAgICBib3R0b21Qb2ludHMucHVzaCh0bXBbMF0pO1xuICAgICAgdG9wUG9pbnRzLnB1c2godG1wWzFdKTtcbiAgICB9XG5cbiAgICBpZiAoY2ZnLmlzSW5DaXJjbGUpIHtcbiAgICAgIHRvcFBvaW50cy5wdXNoKHRvcFBvaW50c1swXSk7XG4gICAgICBib3R0b21Qb2ludHMucHVzaChib3R0b21Qb2ludHNbMF0pO1xuICAgIH1cblxuICAgIGlmIChjZmcuaXNTdGFjaykge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnUG9seWxpbmUnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2xpbmUnLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHBvaW50czogdG9wUG9pbnRzLFxuICAgICAgICAgIHNtb290aDogc21vb3RoXG4gICAgICAgIH0sIHN0eWxlKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRvcFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdQb2x5bGluZScsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2xpbmUnLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgcG9pbnRzOiB0b3BQb2ludHMsXG4gICAgICAgIHNtb290aDogc21vb3RoXG4gICAgICB9LCBzdHlsZSlcbiAgICB9KTtcbiAgICB2YXIgYm90dG9tU2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ1BvbHlsaW5lJywge1xuICAgICAgY2xhc3NOYW1lOiAnbGluZScsXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwb2ludHM6IGJvdHRvbVBvaW50cyxcbiAgICAgICAgc21vb3RoOiBzbW9vdGhcbiAgICAgIH0sIHN0eWxlKVxuICAgIH0pO1xuICAgIHJldHVybiBbdG9wU2hhcGUsIGJvdHRvbVNoYXBlXTtcbiAgfVxuXG4gIGlmIChjZmcuaXNJbkNpcmNsZSkge1xuICAgIHBvaW50cy5wdXNoKHBvaW50c1swXSk7XG4gIH1cblxuICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdQb2x5bGluZScsIHtcbiAgICBjbGFzc05hbWU6ICdsaW5lJyxcbiAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgcG9pbnRzOiBwb2ludHMsXG4gICAgICBzbW9vdGg6IHNtb290aFxuICAgIH0sIHN0eWxlKVxuICB9KTtcbn1cblxudmFyIFNIQVBFUyA9IFsnbGluZScsICdzbW9vdGgnLCAnZGFzaCddO1xuVXRpbC5lYWNoKFNIQVBFUywgZnVuY3Rpb24gKHNoYXBlVHlwZSkge1xuICBTaGFwZS5yZWdpc3RlclNoYXBlKCdsaW5lJywgc2hhcGVUeXBlLCB7XG4gICAgZHJhdzogZnVuY3Rpb24gZHJhdyhjZmcsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHNtb290aCA9IHNoYXBlVHlwZSA9PT0gJ3Ntb290aCc7XG4gICAgICB2YXIgc3R5bGUgPSBnZXRTdHlsZShjZmcpO1xuXG4gICAgICBpZiAoc2hhcGVUeXBlID09PSAnZGFzaCcpIHtcbiAgICAgICAgc3R5bGUubGluZURhc2ggPSBHbG9iYWwubGluZURhc2g7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkcmF3TGluZXMoY2ZnLCBjb250YWluZXIsIHN0eWxlLCBzbW9vdGgpO1xuICAgIH1cbiAgfSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBjYXRBdXRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBpc1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuXG52YXIgQ2F0ZWdvcnkgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKENhdGVnb3J5LCBfQmFzZSk7XG5cbiAgZnVuY3Rpb24gQ2F0ZWdvcnkoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXRlZ29yeS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENmZygpIHtcbiAgICBfQmFzZS5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSAnY2F0JztcbiAgICAvKipcbiAgICAgKiDmmK/lkKbliIbnsbvluqbph49cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKi9cblxuICAgIHRoaXMuaXNDYXRlZ29yeSA9IHRydWU7XG4gICAgdGhpcy5pc1JvdW5kaW5nID0gdHJ1ZTsgLy8g5piv5ZCm6L+b6KGM5Y+W5pW05pON5L2cXG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHZhbHVlcyA9IHNlbGYudmFsdWVzO1xuICAgIHZhciB0aWNrQ291bnQgPSBzZWxmLnRpY2tDb3VudDtcbiAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHYudG9TdHJpbmcoKTtcbiAgICB9KTtcblxuICAgIGlmICghc2VsZi50aWNrcykge1xuICAgICAgdmFyIHRpY2tzID0gdmFsdWVzO1xuXG4gICAgICBpZiAodGlja0NvdW50KSB7XG4gICAgICAgIHZhciB0ZW1wID0gY2F0QXV0byh7XG4gICAgICAgICAgbWF4Q291bnQ6IHRpY2tDb3VudCxcbiAgICAgICAgICBkYXRhOiB2YWx1ZXMsXG4gICAgICAgICAgaXNSb3VuZGluZzogc2VsZi5pc1JvdW5kaW5nXG4gICAgICAgIH0pO1xuICAgICAgICB0aWNrcyA9IHRlbXAudGlja3M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudGlja3MgPSB0aWNrcztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRUZXh0ID0gZnVuY3Rpb24gZ2V0VGV4dCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnZhbHVlcy5pbmRleE9mKHZhbHVlKSA9PT0gLTEgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudmFsdWVzW01hdGgucm91bmQodmFsdWUpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gX0Jhc2UucHJvdG90eXBlLmdldFRleHQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by50cmFuc2xhdGUgPSBmdW5jdGlvbiB0cmFuc2xhdGUodmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICBpbmRleCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpbmRleCA9IE5hTjtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICB2YXIgcGVyY2VudDtcblxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgfHwgdGhpcy52YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMudHJhbnNsYXRlKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgcGVyY2VudCA9IHZhbHVlIC8gKHRoaXMudmFsdWVzLmxlbmd0aCAtIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlTWluICsgcGVyY2VudCAqIChyYW5nZU1heCAtIHJhbmdlTWluKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCh2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIC8vIOWmguaenOW3sue7j+aYr+Wtl+espuS4slxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBtaW4gPSB0aGlzLnJhbmdlTWluKCk7XG4gICAgdmFyIG1heCA9IHRoaXMucmFuZ2VNYXgoKTsgLy8g5b2S5LiA5YiwIOiMg+WbtOWGhVxuXG4gICAgaWYgKHZhbHVlIDwgbWluKSB7XG4gICAgICB2YWx1ZSA9IG1pbjtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgIHZhbHVlID0gbWF4O1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIHZhciBpbmRleCA9IE1hdGgucm91bmQocGVyY2VudCAqICh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKSkgJSB0aGlzLnZhbHVlcy5sZW5ndGg7XG4gICAgaW5kZXggPSBpbmRleCB8fCAwO1xuICAgIHJldHVybiB0aGlzLnZhbHVlc1tpbmRleF07XG4gIH07XG5cbiAgcmV0dXJuIENhdGVnb3J5O1xufShCYXNlKTtcblxuQmFzZS5DYXQgPSBDYXRlZ29yeTtcbm1vZHVsZS5leHBvcnRzID0gQ2F0ZWdvcnk7XG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOiuoeeul+WIhuexu+eahOeahOWdkOagh+eCuVxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIE1BWF9DT1VOVCA9IDg7XG52YXIgU1VCX0NPVU5UID0gNDsgLy8g5o6n5Yi25Liq5pWw5LiN6IO96L+H5bCPXG5cbmZ1bmN0aW9uIGdldFNpbXBsZUFycmF5KGRhdGEpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBlYWNoKGRhdGEsIGZ1bmN0aW9uIChzdWIpIHtcbiAgICBhcnIgPSBhcnIuY29uY2F0KHN1Yik7XG4gIH0pO1xuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRHcmVhdGVzdEZhY3Rvcihjb3VudCwgbnVtYmVyKSB7XG4gIHZhciBpO1xuXG4gIGZvciAoaSA9IG51bWJlcjsgaSA+IDA7IGktLSkge1xuICAgIGlmIChjb3VudCAlIGkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyDlpoLmnpzmmK/ntKDmlbDvvIzmsqHmnInlj6/ku6XmlbTpmaTnmoTmlbDlrZdcblxuXG4gIGlmIChpID09PSAxKSB7XG4gICAgZm9yIChpID0gbnVtYmVyOyBpID4gMDsgaS0tKSB7XG4gICAgICBpZiAoKGNvdW50IC0gMSkgJSBpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gIHZhciByc3QgPSB7fTtcbiAgdmFyIHRpY2tzID0gW107XG4gIHZhciBpc1JvdW5kaW5nID0gaW5mby5pc1JvdW5kaW5nO1xuICB2YXIgY2F0ZWdvcmllcyA9IGdldFNpbXBsZUFycmF5KGluZm8uZGF0YSk7XG4gIHZhciBsZW5ndGggPSBjYXRlZ29yaWVzLmxlbmd0aDtcbiAgdmFyIG1heENvdW50ID0gaW5mby5tYXhDb3VudCB8fCBNQVhfQ09VTlQ7XG4gIHZhciB0aWNrQ291bnQ7XG5cbiAgaWYgKGlzUm91bmRpbmcpIHtcbiAgICAvLyDlj5bmlbTmk43kvZxcbiAgICB0aWNrQ291bnQgPSBnZXRHcmVhdGVzdEZhY3RvcihsZW5ndGggLSAxLCBtYXhDb3VudCAtIDEpICsgMTsgLy8g5aaC5p6c6K6h566X5Ye65p2l5Y+q5pyJ5Lik5Liq5Z2Q5qCH54K577yM5YiZ55u05o6l5L2/55So5Lyg5YWl55qEIG1heENvdW50XG5cbiAgICBpZiAodGlja0NvdW50ID09PSAyKSB7XG4gICAgICB0aWNrQ291bnQgPSBtYXhDb3VudDtcbiAgICB9IGVsc2UgaWYgKHRpY2tDb3VudCA8IG1heENvdW50IC0gU1VCX0NPVU5UKSB7XG4gICAgICB0aWNrQ291bnQgPSBtYXhDb3VudCAtIFNVQl9DT1VOVDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGlja0NvdW50ID0gbWF4Q291bnQ7XG4gIH1cblxuICBpZiAoIWlzUm91bmRpbmcgJiYgbGVuZ3RoIDw9IHRpY2tDb3VudCArIHRpY2tDb3VudCAvIDIpIHtcbiAgICB0aWNrcyA9IFtdLmNvbmNhdChjYXRlZ29yaWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RlcCA9IHBhcnNlSW50KGxlbmd0aCAvICh0aWNrQ291bnQgLSAxKSwgMTApO1xuICAgIHZhciBncm91cHMgPSBjYXRlZ29yaWVzLm1hcChmdW5jdGlvbiAoZSwgaSkge1xuICAgICAgcmV0dXJuIGkgJSBzdGVwID09PSAwID8gY2F0ZWdvcmllcy5zbGljZShpLCBpICsgc3RlcCkgOiBudWxsO1xuICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMSwgZ3JvdXBMZW4gPSBncm91cHMubGVuZ3RoOyBpIDwgZ3JvdXBMZW4gJiYgKGlzUm91bmRpbmcgPyBpICogc3RlcCA8IGxlbmd0aCAtIHN0ZXAgOiBpIDwgdGlja0NvdW50IC0gMSk7IGkrKykge1xuICAgICAgdGlja3MucHVzaChncm91cHNbaV1bMF0pO1xuICAgIH1cblxuICAgIGlmIChjYXRlZ29yaWVzLmxlbmd0aCkge1xuICAgICAgdGlja3MudW5zaGlmdChjYXRlZ29yaWVzWzBdKTtcbiAgICAgIHZhciBsYXN0ID0gY2F0ZWdvcmllc1tsZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHRpY2tzLmluZGV4T2YobGFzdCkgPT09IC0xKSB7XG4gICAgICAgIHRpY2tzLnB1c2gobGFzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcnN0LmNhdGVnb3JpZXMgPSBjYXRlZ29yaWVzO1xuICByc3QudGlja3MgPSB0aWNrcztcbiAgcmV0dXJuIHJzdDtcbn07XG5cbi8qKiovIH0pLFxuLyogNDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZTogdHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgOiBmdW5jdGlvbiAoZm4pIHtcbiAgICByZXR1cm4gc2V0VGltZW91dChmbiwgMTYpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBjb252ZXJ0IHRoZSBsaW5lIHRvIGN1cnZlXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIFZlY3RvcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5mdW5jdGlvbiBnZXRQb2ludCh2KSB7XG4gIHJldHVybiBbdi54LCB2LnldO1xufVxuXG5mdW5jdGlvbiBzbW9vdGhCZXppZXIocG9pbnRzLCBzbW9vdGgsIGlzTG9vcCwgY29uc3RyYWludCkge1xuICB2YXIgY3BzID0gW107XG4gIHZhciBwcmV2UG9pbnQ7XG4gIHZhciBuZXh0UG9pbnQ7XG4gIHZhciBoYXNDb25zdHJhaW50ID0gISFjb25zdHJhaW50O1xuICB2YXIgbWluO1xuICB2YXIgbWF4O1xuICB2YXIgcG9pbnQ7XG4gIHZhciBsZW47XG4gIHZhciBsO1xuICB2YXIgaTtcblxuICBpZiAoaGFzQ29uc3RyYWludCkge1xuICAgIG1pbiA9IFtJbmZpbml0eSwgSW5maW5pdHldO1xuICAgIG1heCA9IFstSW5maW5pdHksIC1JbmZpbml0eV07XG5cbiAgICBmb3IgKGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcG9pbnQgPSBnZXRQb2ludChwb2ludHNbaV0pO1xuICAgICAgVmVjdG9yMi5taW4obWluLCBtaW4sIHBvaW50KTtcbiAgICAgIFZlY3RvcjIubWF4KG1heCwgbWF4LCBwb2ludCk7XG4gICAgfVxuXG4gICAgVmVjdG9yMi5taW4obWluLCBtaW4sIGNvbnN0cmFpbnRbMF0pO1xuICAgIFZlY3RvcjIubWF4KG1heCwgbWF4LCBjb25zdHJhaW50WzFdKTtcbiAgfVxuXG4gIGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHBvaW50ID0gZ2V0UG9pbnQocG9pbnRzW2ldKTtcblxuICAgIGlmIChpc0xvb3ApIHtcbiAgICAgIHByZXZQb2ludCA9IGdldFBvaW50KHBvaW50c1tpID8gaSAtIDEgOiBsZW4gLSAxXSk7XG4gICAgICBuZXh0UG9pbnQgPSBnZXRQb2ludChwb2ludHNbKGkgKyAxKSAlIGxlbl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoaSA9PT0gMCB8fCBpID09PSBsZW4gLSAxKSB7XG4gICAgICAgIGNwcy5wdXNoKFtwb2ludFswXSwgcG9pbnRbMV1dKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmV2UG9pbnQgPSBnZXRQb2ludChwb2ludHNbaSAtIDFdKTtcbiAgICAgICAgbmV4dFBvaW50ID0gZ2V0UG9pbnQocG9pbnRzW2kgKyAxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHYgPSBWZWN0b3IyLnN1YihbXSwgbmV4dFBvaW50LCBwcmV2UG9pbnQpO1xuICAgIFZlY3RvcjIuc2NhbGUodiwgdiwgc21vb3RoKTtcbiAgICB2YXIgZDAgPSBWZWN0b3IyLmRpc3RhbmNlKHBvaW50LCBwcmV2UG9pbnQpO1xuICAgIHZhciBkMSA9IFZlY3RvcjIuZGlzdGFuY2UocG9pbnQsIG5leHRQb2ludCk7XG4gICAgdmFyIHN1bSA9IGQwICsgZDE7XG5cbiAgICBpZiAoc3VtICE9PSAwKSB7XG4gICAgICBkMCAvPSBzdW07XG4gICAgICBkMSAvPSBzdW07XG4gICAgfVxuXG4gICAgdmFyIHYxID0gVmVjdG9yMi5zY2FsZShbXSwgdiwgLWQwKTtcbiAgICB2YXIgdjIgPSBWZWN0b3IyLnNjYWxlKFtdLCB2LCBkMSk7XG4gICAgdmFyIGNwMCA9IFZlY3RvcjIuYWRkKFtdLCBwb2ludCwgdjEpO1xuICAgIHZhciBjcDEgPSBWZWN0b3IyLmFkZChbXSwgcG9pbnQsIHYyKTtcblxuICAgIGlmIChoYXNDb25zdHJhaW50KSB7XG4gICAgICBWZWN0b3IyLm1heChjcDAsIGNwMCwgbWluKTtcbiAgICAgIFZlY3RvcjIubWluKGNwMCwgY3AwLCBtYXgpO1xuICAgICAgVmVjdG9yMi5tYXgoY3AxLCBjcDEsIG1pbik7XG4gICAgICBWZWN0b3IyLm1pbihjcDEsIGNwMSwgbWF4KTtcbiAgICB9XG5cbiAgICBjcHMucHVzaChbY3AwWzBdLCBjcDBbMV1dKTtcbiAgICBjcHMucHVzaChbY3AxWzBdLCBjcDFbMV1dKTtcbiAgfVxuXG4gIGlmIChpc0xvb3ApIHtcbiAgICBjcHMucHVzaChjcHMuc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gY3BzO1xufVxuXG5mdW5jdGlvbiBjYXRtdWxsUm9tMmJlemllcihwb2ludExpc3QsIHosIGNvbnN0cmFpbnQpIHtcbiAgdmFyIGlzTG9vcCA9ICEhejtcbiAgdmFyIGNvbnRyb2xQb2ludExpc3QgPSBzbW9vdGhCZXppZXIocG9pbnRMaXN0LCAwLjQsIGlzTG9vcCwgY29uc3RyYWludCk7XG4gIHZhciBsZW4gPSBwb2ludExpc3QubGVuZ3RoO1xuICB2YXIgZDEgPSBbXTtcbiAgdmFyIGNwMTtcbiAgdmFyIGNwMjtcbiAgdmFyIHA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcbiAgICBjcDEgPSBjb250cm9sUG9pbnRMaXN0W2kgKiAyXTtcbiAgICBjcDIgPSBjb250cm9sUG9pbnRMaXN0W2kgKiAyICsgMV07XG4gICAgcCA9IHBvaW50TGlzdFtpICsgMV07XG4gICAgZDEucHVzaChbJ0MnLCBjcDFbMF0sIGNwMVsxXSwgY3AyWzBdLCBjcDJbMV0sIHAueCwgcC55XSk7XG4gIH1cblxuICBpZiAoaXNMb29wKSB7XG4gICAgY3AxID0gY29udHJvbFBvaW50TGlzdFtsZW5dO1xuICAgIGNwMiA9IGNvbnRyb2xQb2ludExpc3RbbGVuICsgMV07XG4gICAgcCA9IHBvaW50TGlzdFswXTtcbiAgICBkMS5wdXNoKFsnQycsIGNwMVswXSwgY3AxWzFdLCBjcDJbMF0sIGNwMlsxXSwgcC54LCBwLnldKTtcbiAgfVxuXG4gIHJldHVybiBkMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNtb290aDogY2F0bXVsbFJvbTJiZXppZXJcbn07XG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG52YXIgUGF0aCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dlb20pIHtcbiAgX2luaGVyaXRzTG9vc2UoUGF0aCwgX0dlb20pO1xuXG4gIGZ1bmN0aW9uIFBhdGgoKSB7XG4gICAgcmV0dXJuIF9HZW9tLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQYXRoLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgdmFyIGNmZyA9IF9HZW9tLnByb3RvdHlwZS5nZXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICBjZmcudHlwZSA9ICdwYXRoJztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ2xpbmUnO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmdldERyYXdDZmcgPSBmdW5jdGlvbiBnZXREcmF3Q2ZnKG9iaikge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuZ2V0RHJhd0NmZy5jYWxsKHRoaXMsIG9iaik7XG5cbiAgICBjZmcuaXNTdGFjayA9IHRoaXMuaGFzQWRqdXN0KCdzdGFjaycpO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGRhdGEsIHNoYXBlRmFjdG9yeSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZSgpO1xuICAgIHZhciBjb25uZWN0TnVsbHMgPSBzZWxmLmdldCgnY29ubmVjdE51bGxzJyk7XG4gICAgdmFyIHNwbGl0QXJyYXkgPSBTaGFwZVV0aWwuc3BsaXRBcnJheShkYXRhLCB5U2NhbGUuZmllbGQsIGNvbm5lY3ROdWxscyk7XG4gICAgdmFyIGNmZyA9IHRoaXMuZ2V0RHJhd0NmZyhkYXRhWzBdKTtcbiAgICBjZmcub3JpZ2luID0gZGF0YTtcbiAgICBVdGlsLmVhY2goc3BsaXRBcnJheSwgZnVuY3Rpb24gKHN1YkRhdGEsIHNwbGl0ZWRJbmRleCkge1xuICAgICAgY2ZnLnNwbGl0ZWRJbmRleCA9IHNwbGl0ZWRJbmRleDtcbiAgICAgIGNmZy5wb2ludHMgPSBzdWJEYXRhO1xuICAgICAgc2VsZi5kcmF3U2hhcGUoY2ZnLnNoYXBlLCBkYXRhWzBdLCBjZmcsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gUGF0aDtcbn0oR2VvbSk7XG5cbkdlb20uUGF0aCA9IFBhdGg7XG5tb2R1bGUuZXhwb3J0cyA9IFBhdGg7XG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IFV0aWxpdHkgZm9yIGNhbGN1bGF0ZSB0aGUgd2l0aCByYXR1aSBpbiB4IGF4aXNcbiAqIEBhdXRob3Igc2ltYS56aGFuZzE5OTBAZ21haWwuY29tXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNpemVNaXhpbiA9IHtcbiAgZ2V0RGVmYWx1dFNpemU6IGZ1bmN0aW9uIGdldERlZmFsdXRTaXplKCkge1xuICAgIHZhciBkZWZhdWx0U2l6ZSA9IHRoaXMuZ2V0KCdkZWZhdWx0U2l6ZScpO1xuXG4gICAgaWYgKCFkZWZhdWx0U2l6ZSkge1xuICAgICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgICB2YXIgeFNjYWxlID0gdGhpcy5nZXRYU2NhbGUoKTtcbiAgICAgIHZhciBkYXRhQXJyYXkgPSB0aGlzLmdldCgnZGF0YUFycmF5Jyk7XG4gICAgICB2YXIgdmFsdWVzID0gVXRpbC51bmlxKHhTY2FsZS52YWx1ZXMpO1xuICAgICAgdmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgIHZhciByYW5nZSA9IHhTY2FsZS5yYW5nZTtcbiAgICAgIHZhciBub3JtYWxpemVTaXplID0gMSAvIGNvdW50O1xuICAgICAgdmFyIHdpZHRoUmF0aW8gPSAxO1xuXG4gICAgICBpZiAoY29vcmQgJiYgY29vcmQuaXNQb2xhcikge1xuICAgICAgICBpZiAoY29vcmQudHJhbnNwb3NlZCAmJiBjb3VudCA+IDEpIHtcbiAgICAgICAgICB3aWR0aFJhdGlvID0gR2xvYmFsLndpZHRoUmF0aW8ubXVsdGlwbGVQaWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2lkdGhSYXRpbyA9IEdsb2JhbC53aWR0aFJhdGlvLnJvc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4U2NhbGUuaXNMaW5lYXIpIHtcbiAgICAgICAgICBub3JtYWxpemVTaXplICo9IHJhbmdlWzFdIC0gcmFuZ2VbMF07XG4gICAgICAgIH1cblxuICAgICAgICB3aWR0aFJhdGlvID0gR2xvYmFsLndpZHRoUmF0aW8uY29sdW1uO1xuICAgICAgfVxuXG4gICAgICBub3JtYWxpemVTaXplICo9IHdpZHRoUmF0aW87XG5cbiAgICAgIGlmICh0aGlzLmhhc0FkanVzdCgnZG9kZ2UnKSkge1xuICAgICAgICBub3JtYWxpemVTaXplID0gbm9ybWFsaXplU2l6ZSAvIGRhdGFBcnJheS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRTaXplID0gbm9ybWFsaXplU2l6ZTtcbiAgICAgIHRoaXMuc2V0KCdkZWZhdWx0U2l6ZScsIGRlZmF1bHRTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFNpemU7XG4gIH0sXG4gIGdldERpbVdpZHRoOiBmdW5jdGlvbiBnZXREaW1XaWR0aChkaW1OYW1lKSB7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIHN0YXJ0ID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSk7XG4gICAgdmFyIGVuZCA9IGNvb3JkLmNvbnZlcnRQb2ludCh7XG4gICAgICB4OiBkaW1OYW1lID09PSAneCcgPyAxIDogMCxcbiAgICAgIHk6IGRpbU5hbWUgPT09ICd4JyA/IDAgOiAxXG4gICAgfSk7XG4gICAgdmFyIHdpZHRoID0gMDtcblxuICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgIHdpZHRoID0gTWF0aC5zcXJ0KE1hdGgucG93KGVuZC54IC0gc3RhcnQueCwgMikgKyBNYXRoLnBvdyhlbmQueSAtIHN0YXJ0LnksIDIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG4gIH0sXG4gIF9nZXRXaWR0aDogZnVuY3Rpb24gX2dldFdpZHRoKCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0KCdfd2lkdGgnKTtcblxuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHZhciBjb29yZCA9IHRoaXMuZ2V0KCdjb29yZCcpO1xuXG4gICAgICBpZiAoY29vcmQgJiYgY29vcmQuaXNQb2xhciAmJiAhY29vcmQudHJhbnNwb3NlZCkge1xuICAgICAgICB3aWR0aCA9IChjb29yZC5lbmRBbmdsZSAtIGNvb3JkLnN0YXJ0QW5nbGUpICogY29vcmQuY2lyY2xlUmFkaXVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2lkdGggPSB0aGlzLmdldERpbVdpZHRoKCd4Jyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0KCdfd2lkdGgnLCB3aWR0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdpZHRoO1xuICB9LFxuICBfdG9Ob3JtYWxpemVkU2l6ZTogZnVuY3Rpb24gX3RvTm9ybWFsaXplZFNpemUoc2l6ZSkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuX2dldFdpZHRoKCk7XG5cbiAgICByZXR1cm4gc2l6ZSAvIHdpZHRoO1xuICB9LFxuICBfdG9Db29yZFNpemU6IGZ1bmN0aW9uIF90b0Nvb3JkU2l6ZShub3JtYWxpemVTaXplKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fZ2V0V2lkdGgoKTtcblxuICAgIHJldHVybiB3aWR0aCAqIG5vcm1hbGl6ZVNpemU7XG4gIH0sXG4gIGdldE5vcm1hbGl6ZWRTaXplOiBmdW5jdGlvbiBnZXROb3JtYWxpemVkU2l6ZShvYmopIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXR0clZhbHVlKCdzaXplJywgb2JqKTtcblxuICAgIGlmIChVdGlsLmlzTmlsKHNpemUpKSB7XG4gICAgICBzaXplID0gdGhpcy5nZXREZWZhbHV0U2l6ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gdGhpcy5fdG9Ob3JtYWxpemVkU2l6ZShzaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbiAgfSxcbiAgZ2V0U2l6ZTogZnVuY3Rpb24gZ2V0U2l6ZShvYmopIHtcbiAgICB2YXIgc2l6ZSA9IHRoaXMuZ2V0QXR0clZhbHVlKCdzaXplJywgb2JqKTtcblxuICAgIGlmIChVdGlsLmlzTmlsKHNpemUpKSB7XG4gICAgICB2YXIgbm9ybWFsaXplU2l6ZSA9IHRoaXMuZ2V0RGVmYWx1dFNpemUoKTtcbiAgICAgIHNpemUgPSB0aGlzLl90b0Nvb3JkU2l6ZShub3JtYWxpemVTaXplKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxufTtcbm1vZHVsZS5leHBvcnRzID0gU2l6ZU1peGluO1xuXG4vKioqLyB9KSxcbi8qIDQ0ICovLFxuLyogNDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIENvcmUgPSB7fTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbkNvcmUuR2xvYmFsID0gR2xvYmFsO1xuQ29yZS52ZXJzaW9uID0gR2xvYmFsLnZlcnNpb247XG5Db3JlLkNoYXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5Db3JlLlNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbkNvcmUuRyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5Db3JlLlV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApOyAvLyBDb3JlLnRyYWNrID0gZnVuY3Rpb24oZW5hYmxlKSB7XG4vLyAgIEdsb2JhbC50cmFja2FibGUgPSBlbmFibGU7XG4vLyB9O1xuLy8gcmVxdWlyZSgnLi90cmFjaycpO1xuLy8gMjAxOC0xMi0yNyDlhbPpl63miZPngrlcblxuQ29yZS50cmFjayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvcmU7XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IGRlZmF1bHQgdGhlbWVcbiAqIEBhdXRob3IgZHhxNjEzQGdhaWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIGNvbG9yMSA9ICcjRThFOEU4JzsgLy8gY29sb3Igb2YgYXhpcy1saW5lIGFuZCBheGlzLWdyaWRcblxudmFyIGNvbG9yMiA9ICcjODA4MDgwJzsgLy8gY29sb3Igb2YgYXhpcyBsYWJlbFxuXG52YXIgZGVmYXVsdEF4aXMgPSB7XG4gIGxhYmVsOiB7XG4gICAgZmlsbDogY29sb3IyLFxuICAgIGZvbnRTaXplOiAxMFxuICB9LFxuICBsaW5lOiB7XG4gICAgc3Ryb2tlOiBjb2xvcjEsXG4gICAgbGluZVdpZHRoOiAxXG4gIH0sXG4gIGdyaWQ6IHtcbiAgICB0eXBlOiAnbGluZScsXG4gICAgc3Ryb2tlOiBjb2xvcjEsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIGxpbmVEYXNoOiBbMl1cbiAgfSxcbiAgdGlja0xpbmU6IG51bGwsXG4gIGxhYmVsT2Zmc2V0OiA3LjVcbn07XG52YXIgVGhlbWUgPSB7XG4gIGZvbnRGYW1pbHk6ICdcIkhlbHZldGljYSBOZXVlXCIsIFwiU2FuIEZyYW5jaXNjb1wiLCBIZWx2ZXRpY2EsIFRhaG9tYSwgQXJpYWwsIFwiUGluZ0ZhbmcgU0NcIiwgXCJIaXJhZ2lubyBTYW5zIEdCXCIsIFwiSGVpdGkgU0NcIiwgXCJNaWNyb3NvZnQgWWFIZWlcIiwgc2Fucy1zZXJpZicsXG4gIGRlZmF1bHRDb2xvcjogJyMxODkwRkYnLFxuICBwaXhlbFJhdGlvOiAxLFxuICBwYWRkaW5nOiAnYXV0bycsXG4gIGFwcGVuZFBhZGRpbmc6IDE1LFxuICBjb2xvcnM6IFsnIzE4OTBGRicsICcjMkZDMjVCJywgJyNGQUNDMTQnLCAnIzIyMzI3MycsICcjODU0M0UwJywgJyMxM0MyQzInLCAnIzM0MzZDNycsICcjRjA0ODY0J10sXG4gIHNoYXBlczoge1xuICAgIGxpbmU6IFsnbGluZScsICdkYXNoJ10sXG4gICAgcG9pbnQ6IFsnY2lyY2xlJywgJ2hvbGxvd0NpcmNsZSddXG4gIH0sXG4gIHNpemVzOiBbNCwgMTBdLFxuICBheGlzOiB7XG4gICAgY29tbW9uOiBkZWZhdWx0QXhpcyxcbiAgICAvLyBjb21tb24gYXhpcyBjb25maWd1cmF0aW9uXG4gICAgYm90dG9tOiBVdGlsLm1peCh7fSwgZGVmYXVsdEF4aXMsIHtcbiAgICAgIGdyaWQ6IG51bGxcbiAgICB9KSxcbiAgICBsZWZ0OiBVdGlsLm1peCh7fSwgZGVmYXVsdEF4aXMsIHtcbiAgICAgIGxpbmU6IG51bGxcbiAgICB9KSxcbiAgICByaWdodDogVXRpbC5taXgoe30sIGRlZmF1bHRBeGlzLCB7XG4gICAgICBsaW5lOiBudWxsXG4gICAgfSksXG4gICAgY2lyY2xlOiBVdGlsLm1peCh7fSwgZGVmYXVsdEF4aXMsIHtcbiAgICAgIGxpbmU6IG51bGxcbiAgICB9KSxcbiAgICByYWRpdXM6IFV0aWwubWl4KHt9LCBkZWZhdWx0QXhpcywge1xuICAgICAgbGFiZWxPZmZzZXQ6IDRcbiAgICB9KVxuICB9LFxuICBzaGFwZToge1xuICAgIGxpbmU6IHtcbiAgICAgIGxpbmVXaWR0aDogMixcbiAgICAgIGxpbmVKb2luOiAncm91bmQnLFxuICAgICAgbGluZUNhcDogJ3JvdW5kJ1xuICAgIH0sXG4gICAgcG9pbnQ6IHtcbiAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgIHNpemU6IDNcbiAgICB9LFxuICAgIGFyZWE6IHtcbiAgICAgIGZpbGxPcGFjaXR5OiAwLjFcbiAgICB9XG4gIH0sXG4gIF9kZWZhdWx0QXhpczogZGVmYXVsdEF4aXNcbn07XG5tb2R1bGUuZXhwb3J0cyA9IFRoZW1lO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBEb21VdGlsO1xuLyoqXG4gKiBEZXRlY3RzIHN1cHBvcnQgZm9yIG9wdGlvbnMgb2JqZWN0IGFyZ3VtZW50IGluIGFkZEV2ZW50TGlzdGVuZXIuXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRXZlbnRUYXJnZXQvYWRkRXZlbnRMaXN0ZW5lciNTYWZlbHlfZGV0ZWN0aW5nX29wdGlvbl9zdXBwb3J0XG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3VwcG9ydHMgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBvcHRpb25zID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBzdXBwb3J0cyA9IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2UnLCBudWxsLCBvcHRpb25zKTtcbiAgfSBjYXRjaCAoZSkgey8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0cztcbn0oKTsgLy8gRGVmYXVsdCBwYXNzaXZlIHRvIHRydWUgYXMgZXhwZWN0ZWQgYnkgQ2hyb21lIGZvciAndG91Y2hzdGFydCcgYW5kICd0b3VjaGVuZCcgZXZlbnRzLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NoYXJ0anMvQ2hhcnQuanMvaXNzdWVzLzQyODdcblxuXG52YXIgZXZlbnRMaXN0ZW5lck9wdGlvbnMgPSBzdXBwb3J0c0V2ZW50TGlzdGVuZXJPcHRpb25zID8ge1xuICBwYXNzaXZlOiB0cnVlXG59IDogZmFsc2U7XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCB4LCB5LCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgY2hhcnQ6IGNoYXJ0LFxuICAgIG5hdGl2ZTogbmF0aXZlRXZlbnQgfHwgbnVsbCxcbiAgICB4OiB4ICE9PSB1bmRlZmluZWQgPyB4IDogbnVsbCxcbiAgICB5OiB5ICE9PSB1bmRlZmluZWQgPyB5IDogbnVsbFxuICB9O1xufVxuXG5mdW5jdGlvbiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KSB7XG4gIHZhciB0eXBlID0gZXZlbnQudHlwZTtcbiAgdmFyIHBvaW50ID0ge307XG4gIHZhciB0b3VjaGVzID0gZXZlbnQudGFyZ2V0VG91Y2hlcztcblxuICBpZiAodG91Y2hlcyAmJiB0b3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICBwb2ludC54ID0gdG91Y2hlc1swXS5jbGllbnRYO1xuICAgIHBvaW50LnkgPSB0b3VjaGVzWzBdLmNsaWVudFk7XG4gIH0gZWxzZSB7XG4gICAgcG9pbnQueCA9IGV2ZW50LmNsaWVudFg7XG4gICAgcG9pbnQueSA9IGV2ZW50LmNsaWVudFk7XG4gIH1cblxuICB2YXIgY2FudmFzID0gY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgdmFyIHBvcyA9IERvbVV0aWwuZ2V0UmVsYXRpdmVQb3NpdGlvbihwb2ludCwgY2FudmFzKTtcbiAgcmV0dXJuIGNyZWF0ZUV2ZW50KHR5cGUsIGNoYXJ0LCBwb3MueCwgcG9zLnksIGV2ZW50KTtcbn1cblxuRG9tVXRpbCA9IHtcbiAgLyogZ2xvYmFsIHd4LCBteSwgbW9kdWxlICovXG4gIGlzV3g6IHR5cGVvZiB3eCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHd4LmdldFN5c3RlbUluZm9TeW5jID09PSAnZnVuY3Rpb24nLFxuICAvLyB3ZWl4aW4gbWluaXByb2dyYW1cbiAgaXNNeTogdHlwZW9mIG15ID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbXkuZ2V0U3lzdGVtSW5mb1N5bmMgPT09ICdmdW5jdGlvbicsXG4gIC8vIGFudCBtaW5pcHJvZ3JhbVxuICBpc05vZGU6IHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcsXG4gIC8vIGluIG5vZGVcbiAgaXNCcm93c2VyOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LnNlc3Npb25TdG9yYWdlICE9PSAndW5kZWZpbmVkJyxcbiAgLy8gaW4gYnJvd3NlclxuICBnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbiBnZXRQaXhlbFJhdGlvKCkge1xuICAgIHJldHVybiB3aW5kb3cgJiYgd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgfSxcbiAgZ2V0U3R5bGU6IGZ1bmN0aW9uIGdldFN0eWxlKGVsLCBwcm9wZXJ0eSkge1xuICAgIHJldHVybiBlbC5jdXJyZW50U3R5bGUgPyBlbC5jdXJyZW50U3R5bGVbcHJvcGVydHldIDogZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgbnVsbCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIH0sXG4gIGdldFdpZHRoOiBmdW5jdGlvbiBnZXRXaWR0aChlbCkge1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoZWwsICd3aWR0aCcpO1xuXG4gICAgaWYgKHdpZHRoID09PSAnYXV0bycpIHtcbiAgICAgIHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQod2lkdGgpO1xuICB9LFxuICBnZXRIZWlnaHQ6IGZ1bmN0aW9uIGdldEhlaWdodChlbCkge1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKGVsLCAnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoaGVpZ2h0ID09PSAnYXV0bycpIHtcbiAgICAgIGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyc2VGbG9hdChoZWlnaHQpO1xuICB9LFxuICBnZXREb21CeUlkOiBmdW5jdGlvbiBnZXREb21CeUlkKGlkKSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcbiAgfSxcbiAgZ2V0UmVsYXRpdmVQb3NpdGlvbjogZnVuY3Rpb24gZ2V0UmVsYXRpdmVQb3NpdGlvbihwb2ludCwgY2FudmFzKSB7XG4gICAgdmFyIGNhbnZhc0RvbSA9IGNhbnZhcy5nZXQoJ2VsJyk7XG5cbiAgICB2YXIgX2NhbnZhc0RvbSRnZXRCb3VuZGluID0gY2FudmFzRG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICB0b3AgPSBfY2FudmFzRG9tJGdldEJvdW5kaW4udG9wLFxuICAgICAgICByaWdodCA9IF9jYW52YXNEb20kZ2V0Qm91bmRpbi5yaWdodCxcbiAgICAgICAgYm90dG9tID0gX2NhbnZhc0RvbSRnZXRCb3VuZGluLmJvdHRvbSxcbiAgICAgICAgbGVmdCA9IF9jYW52YXNEb20kZ2V0Qm91bmRpbi5sZWZ0O1xuXG4gICAgdmFyIHBhZGRpbmdMZWZ0ID0gcGFyc2VGbG9hdCh0aGlzLmdldFN0eWxlKGNhbnZhc0RvbSwgJ3BhZGRpbmctbGVmdCcpKTtcbiAgICB2YXIgcGFkZGluZ1RvcCA9IHBhcnNlRmxvYXQodGhpcy5nZXRTdHlsZShjYW52YXNEb20sICdwYWRkaW5nLXRvcCcpKTtcbiAgICB2YXIgcGFkZGluZ1JpZ2h0ID0gcGFyc2VGbG9hdCh0aGlzLmdldFN0eWxlKGNhbnZhc0RvbSwgJ3BhZGRpbmctcmlnaHQnKSk7XG4gICAgdmFyIHBhZGRpbmdCb3R0b20gPSBwYXJzZUZsb2F0KHRoaXMuZ2V0U3R5bGUoY2FudmFzRG9tLCAncGFkZGluZy1ib3R0b20nKSk7XG4gICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0IC0gcGFkZGluZ0xlZnQgLSBwYWRkaW5nUmlnaHQ7XG4gICAgdmFyIGhlaWdodCA9IGJvdHRvbSAtIHRvcCAtIHBhZGRpbmdUb3AgLSBwYWRkaW5nQm90dG9tO1xuICAgIHZhciBwaXhlbFJhdGlvID0gY2FudmFzLmdldCgncGl4ZWxSYXRpbycpO1xuICAgIHZhciBtb3VzZVggPSAocG9pbnQueCAtIGxlZnQgLSBwYWRkaW5nTGVmdCkgLyB3aWR0aCAqIGNhbnZhc0RvbS53aWR0aCAvIHBpeGVsUmF0aW87XG4gICAgdmFyIG1vdXNlWSA9IChwb2ludC55IC0gdG9wIC0gcGFkZGluZ1RvcCkgLyBoZWlnaHQgKiBjYW52YXNEb20uaGVpZ2h0IC8gcGl4ZWxSYXRpbztcbiAgICByZXR1cm4ge1xuICAgICAgeDogbW91c2VYLFxuICAgICAgeTogbW91c2VZXG4gICAgfTtcbiAgfSxcbiAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihzb3VyY2UsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgRG9tVXRpbC5pc0Jyb3dzZXIgJiYgc291cmNlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfSxcbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcihzb3VyY2UsIHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgRG9tVXRpbC5pc0Jyb3dzZXIgJiYgc291cmNlLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIGV2ZW50TGlzdGVuZXJPcHRpb25zKTtcbiAgfSxcbiAgY3JlYXRlRXZlbnQ6IGZ1bmN0aW9uIGNyZWF0ZUV2ZW50KGV2ZW50LCBjaGFydCkge1xuICAgIHJldHVybiBmcm9tTmF0aXZlRXZlbnQoZXZlbnQsIGNoYXJ0KTtcbiAgfSxcbiAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uIG1lYXN1cmVUZXh0KHRleHQsIGZvbnQsIGN0eCkge1xuICAgIGlmICghY3R4KSB7XG4gICAgICBjdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuICAgIH1cblxuICAgIGN0eC5mb250ID0gZm9udCB8fCAnMTJweCBzYW5zLXNlcmlmJztcbiAgICByZXR1cm4gY3R4Lm1lYXN1cmVUZXh0KHRleHQpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBEb21VdGlsO1xuXG4vKioqLyB9KSxcbi8qIDQ4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciB0b1N0cmluZyA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xuXG52YXIgdXBwZXJGaXJzdCA9IGZ1bmN0aW9uIHVwcGVyRmlyc3QodmFsdWUpIHtcbiAgdmFyIHN0ciA9IHRvU3RyaW5nKHZhbHVlKTtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zdWJzdHJpbmcoMSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVwcGVyRmlyc3Q7XG5cbi8qKiovIH0pLFxuLyogNDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIHRvU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbnZhciBsb3dlckZpcnN0ID0gZnVuY3Rpb24gbG93ZXJGaXJzdCh2YWx1ZSkge1xuICB2YXIgc3RyID0gdG9TdHJpbmcodmFsdWUpO1xuICByZXR1cm4gc3RyLmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgc3RyLnN1YnN0cmluZygxKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbG93ZXJGaXJzdDtcblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIGlzU3RyaW5nID0gZnVuY3Rpb24gaXNTdHJpbmcoc3RyKSB7XG4gIHJldHVybiBpc1R5cGUoc3RyLCAnU3RyaW5nJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICog5Yik5pat5piv5ZCm5pWw5a2XXG4gKiBAcmV0dXJuIHtCb29sZWFufSDmmK/lkKbmlbDlrZdcbiAqL1xudmFyIGlzVHlwZSA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG5cbnZhciBpc051bWJlciA9IGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdOdW1iZXInKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOdW1iZXI7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiDmmK/lkKbmmK/luIPlsJTnsbvlnotcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWUg5rWL6K+V55qE5YC8XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIGlzQm9vbGVhbiA9IGZ1bmN0aW9uIGlzQm9vbGVhbih2YWx1ZSkge1xuICByZXR1cm4gaXNUeXBlKHZhbHVlLCAnQm9vbGVhbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0Jvb2xlYW47XG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiDmmK/lkKbkuLrlh73mlbBcbiAqIEBwYXJhbSAgeyp9IGZuIOWvueixoVxuICogQHJldHVybiB7Qm9vbGVhbn0gIOaYr+WQpuWHveaVsFxuICovXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdGdW5jdGlvbicpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1R5cGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuXG52YXIgaXNEYXRlID0gZnVuY3Rpb24gaXNEYXRlKHZhbHVlKSB7XG4gIHJldHVybiBpc1R5cGUodmFsdWUsICdEYXRlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRGF0ZTtcblxuLyoqKi8gfSksXG4vKiA1NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iajtcbn0gOiBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xufTtcblxudmFyIGlzT2JqZWN0TGlrZSA9IGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAvKipcbiAgICogaXNPYmplY3RMaWtlKHt9KSA9PiB0cnVlXG4gICAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pID0+IHRydWVcbiAgICogaXNPYmplY3RMaWtlKEZ1bmN0aW9uKSA9PiBmYWxzZVxuICAgKiBpc09iamVjdExpa2UobnVsbCkgPT4gZmFsc2VcbiAgICovXG4gIHJldHVybiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZih2YWx1ZSkpID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMik7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG5cbnZhciBNQVhfTUlYX0xFVkVMID0gNTtcblxuZnVuY3Rpb24gX2RlZXBNaXgoZGlzdCwgc3JjLCBsZXZlbCwgbWF4TGV2ZWwpIHtcbiAgbGV2ZWwgPSBsZXZlbCB8fCAwO1xuICBtYXhMZXZlbCA9IG1heExldmVsIHx8IE1BWF9NSVhfTEVWRUw7XG5cbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGlmIChzcmMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgdmFyIHZhbHVlID0gc3JjW2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiBpc1BsYWluT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGlzdFtrZXldKSkge1xuICAgICAgICAgIGRpc3Rba2V5XSA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwpIHtcbiAgICAgICAgICBfZGVlcE1peChkaXN0W2tleV0sIHZhbHVlLCBsZXZlbCArIDEsIG1heExldmVsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBkaXN0W2tleV0gPSBbXTtcbiAgICAgICAgZGlzdFtrZXldID0gZGlzdFtrZXldLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlzdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBkZWVwTWl4ID0gZnVuY3Rpb24gZGVlcE1peCgpIHtcbiAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gIHZhciBsZW5ndGggPSBhcmdzLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgfVxuXG4gIHZhciByc3QgPSBhcmdzWzBdO1xuXG4gIGZvciAodmFyIF9pID0gMTsgX2kgPCBsZW5ndGg7IF9pKyspIHtcbiAgICBfZGVlcE1peChyc3QsIGFyZ3NbX2ldKTtcbiAgfVxuXG4gIHJldHVybiByc3Q7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZXBNaXg7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX21peChkaXN0LCBvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiBrZXkgIT09ICdjb25zdHJ1Y3RvcicgJiYgb2JqW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgZGlzdFtrZXldID0gb2JqW2tleV07XG4gICAgfVxuICB9XG59XG5cbnZhciBtaXggPSBmdW5jdGlvbiBtaXgoZGlzdCwgc3JjMSwgc3JjMiwgc3JjMykge1xuICBpZiAoc3JjMSkgX21peChkaXN0LCBzcmMxKTtcbiAgaWYgKHNyYzIpIF9taXgoZGlzdCwgc3JjMik7XG4gIGlmIChzcmMzKSBfbWl4KGRpc3QsIHNyYzMpO1xuICByZXR1cm4gZGlzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbWl4O1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cbnZhciBjb250YWlucyA9IF9fd2VicGFja19yZXF1aXJlX18oNTkpO1xuXG52YXIgdW5pcSA9IGZ1bmN0aW9uIHVuaXEoYXJyKSB7XG4gIHZhciByZXN1bHRBcnIgPSBbXTtcbiAgZWFjaChhcnIsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKCFjb250YWlucyhyZXN1bHRBcnIsIGl0ZW0pKSB7XG4gICAgICByZXN1bHRBcnIucHVzaChpdGVtKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0QXJyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxO1xuXG4vKioqLyB9KSxcbi8qIDU5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBpc0FycmF5TGlrZSA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xuXG52YXIgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuXG52YXIgY29udGFpbnMgPSBmdW5jdGlvbiBjb250YWlucyhhcnIsIHZhbHVlKSB7XG4gIGlmICghaXNBcnJheUxpa2UoYXJyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBpbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSkgPiAtMTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnM7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24gaXNBcnJheUxpa2UodmFsdWUpIHtcbiAgLyoqXG4gICAqIGlzQXJyYXlMaWtlKFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgKiBpc0FycmF5TGlrZShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKSA9PiB0cnVlXG4gICAqIGlzQXJyYXlMaWtlKCdhYmMnKSA9PiB0cnVlXG4gICAqIGlzQXJyYXlMaWtlKEZ1bmN0aW9uKSA9PiBmYWxzZVxuICAgKi9cbiAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiBpc0Zpbml0ZSh2YWx1ZS5sZW5ndGgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZTtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBQbG90ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUGxvdChjZmcpIHtcbiAgICBVdGlsLm1peCh0aGlzLCBjZmcpO1xuXG4gICAgdGhpcy5faW5pdCgpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBsb3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgc3RhcnQgPSBzZWxmLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBzZWxmLmVuZDtcbiAgICB2YXIgeE1pbiA9IE1hdGgubWluKHN0YXJ0LngsIGVuZC54KTtcbiAgICB2YXIgeE1heCA9IE1hdGgubWF4KHN0YXJ0LngsIGVuZC54KTtcbiAgICB2YXIgeU1pbiA9IE1hdGgubWluKHN0YXJ0LnksIGVuZC55KTtcbiAgICB2YXIgeU1heCA9IE1hdGgubWF4KHN0YXJ0LnksIGVuZC55KTtcbiAgICB0aGlzLnRsID0ge1xuICAgICAgeDogeE1pbixcbiAgICAgIHk6IHlNaW5cbiAgICB9O1xuICAgIHRoaXMudHIgPSB7XG4gICAgICB4OiB4TWF4LFxuICAgICAgeTogeU1pblxuICAgIH07XG4gICAgdGhpcy5ibCA9IHtcbiAgICAgIHg6IHhNaW4sXG4gICAgICB5OiB5TWF4XG4gICAgfTtcbiAgICB0aGlzLmJyID0ge1xuICAgICAgeDogeE1heCxcbiAgICAgIHk6IHlNYXhcbiAgICB9O1xuICAgIHRoaXMud2lkdGggPSB4TWF4IC0geE1pbjtcbiAgICB0aGlzLmhlaWdodCA9IHlNYXggLSB5TWluO1xuICB9XG4gIC8qKlxuICAgKiByZXNldFxuICAgKiBAcGFyYW0gIHtPYmplY3R9IHN0YXJ0IHN0YXJ0IHBvaW50XG4gICAqIEBwYXJhbSAge09iamVjdH0gZW5kIGVuZCBwb2ludFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5yZXNldCA9IGZ1bmN0aW9uIHJlc2V0KHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQ7XG5cbiAgICB0aGlzLl9pbml0KCk7XG4gIH1cbiAgLyoqXG4gICAqIGNoZWNrIHRoZSBwb2ludCBpcyBpbiB0aGUgcmFuZ2Ugb2YgcGxvdFxuICAgKiBAcGFyYW0gIHtOdWJtZXJ9ICB4IHggdmFsdWVcbiAgICogQHBhcmFtICB7W3R5cGVdfSAgeSB5IHZhbHVlXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59IHJldHVybiB0aGUgcmVzdWx0XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmlzSW5SYW5nZSA9IGZ1bmN0aW9uIGlzSW5SYW5nZSh4LCB5KSB7XG4gICAgaWYgKFV0aWwuaXNPYmplY3QoeCkpIHtcbiAgICAgIHkgPSB4Lnk7XG4gICAgICB4ID0geC54O1xuICAgIH1cblxuICAgIHZhciB0bCA9IHRoaXMudGw7XG4gICAgdmFyIGJyID0gdGhpcy5icjtcbiAgICByZXR1cm4gdGwueCA8PSB4ICYmIHggPD0gYnIueCAmJiB0bC55IDw9IHkgJiYgeSA8PSBici55O1xuICB9O1xuXG4gIHJldHVybiBQbG90O1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBsb3Q7XG5cbi8qKiovIH0pLFxuLyogNjIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIENvb3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNjMpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvb3JkO1xuXG4vKioqLyB9KSxcbi8qIDYzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG52YXIgQ2FydGVzaWFuID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShDYXJ0ZXNpYW4sIF9CYXNlKTtcblxuICBmdW5jdGlvbiBDYXJ0ZXNpYW4oKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDYXJ0ZXNpYW4ucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ2NhcnRlc2lhbic7XG4gICAgdGhpcy50cmFuc3Bvc2VkID0gZmFsc2U7XG4gICAgdGhpcy5pc1JlY3QgPSB0cnVlO1xuICB9O1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChzdGFydCwgZW5kKSB7XG4gICAgdGhpcy54ID0ge1xuICAgICAgc3RhcnQ6IHN0YXJ0LngsXG4gICAgICBlbmQ6IGVuZC54XG4gICAgfTtcbiAgICB0aGlzLnkgPSB7XG4gICAgICBzdGFydDogc3RhcnQueSxcbiAgICAgIGVuZDogZW5kLnlcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jb252ZXJ0UG9pbnQgPSBmdW5jdGlvbiBjb252ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRyYW5zcG9zZWQgPSBzZWxmLnRyYW5zcG9zZWQ7XG4gICAgdmFyIHhEaW0gPSB0cmFuc3Bvc2VkID8gJ3knIDogJ3gnO1xuICAgIHZhciB5RGltID0gdHJhbnNwb3NlZCA/ICd4JyA6ICd5JztcbiAgICB2YXIgeCA9IHNlbGYueDtcbiAgICB2YXIgeSA9IHNlbGYueTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogeC5zdGFydCArICh4LmVuZCAtIHguc3RhcnQpICogcG9pbnRbeERpbV0sXG4gICAgICB5OiB5LnN0YXJ0ICsgKHkuZW5kIC0geS5zdGFydCkgKiBwb2ludFt5RGltXVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmludmVydFBvaW50ID0gZnVuY3Rpb24gaW52ZXJ0UG9pbnQocG9pbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHRyYW5zcG9zZWQgPSBzZWxmLnRyYW5zcG9zZWQ7XG4gICAgdmFyIHhEaW0gPSB0cmFuc3Bvc2VkID8gJ3knIDogJ3gnO1xuICAgIHZhciB5RGltID0gdHJhbnNwb3NlZCA/ICd4JyA6ICd5JztcbiAgICB2YXIgeCA9IHNlbGYueDtcbiAgICB2YXIgeSA9IHNlbGYueTtcbiAgICB2YXIgcnN0ID0ge307XG4gICAgcnN0W3hEaW1dID0gKHBvaW50LnggLSB4LnN0YXJ0KSAvICh4LmVuZCAtIHguc3RhcnQpO1xuICAgIHJzdFt5RGltXSA9IChwb2ludC55IC0geS5zdGFydCkgLyAoeS5lbmQgLSB5LnN0YXJ0KTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIHJldHVybiBDYXJ0ZXNpYW47XG59KEJhc2UpO1xuXG5CYXNlLkNhcnRlc2lhbiA9IENhcnRlc2lhbjtcbkJhc2UuUmVjdCA9IENhcnRlc2lhbjtcbm1vZHVsZS5leHBvcnRzID0gQ2FydGVzaWFuO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBQb3NpdGlvbjogX193ZWJwYWNrX3JlcXVpcmVfXyg2NSksXG4gIFNoYXBlOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KSxcbiAgU2l6ZTogX193ZWJwYWNrX3JlcXVpcmVfXyg2NyksXG4gIENvbG9yOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KVxufTtcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIFBvc2l0aW9uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShQb3NpdGlvbiwgX0Jhc2UpO1xuXG4gIGZ1bmN0aW9uIFBvc2l0aW9uKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgX3RoaXMubmFtZXMgPSBbJ3gnLCAneSddO1xuICAgIF90aGlzLnR5cGUgPSAncG9zaXRpb24nO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQb3NpdGlvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLm1hcHBpbmcgPSBmdW5jdGlvbiBtYXBwaW5nKHgsIHkpIHtcbiAgICB2YXIgc2NhbGVzID0gdGhpcy5zY2FsZXM7XG4gICAgdmFyIGNvb3JkID0gdGhpcy5jb29yZDtcbiAgICB2YXIgc2NhbGVYID0gc2NhbGVzWzBdO1xuICAgIHZhciBzY2FsZVkgPSBzY2FsZXNbMV07XG4gICAgdmFyIHJzdFg7XG4gICAgdmFyIHJzdFk7XG4gICAgdmFyIG9iajtcblxuICAgIGlmIChpc05pbCh4KSB8fCBpc05pbCh5KSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KHkpICYmIGlzQXJyYXkoeCkpIHtcbiAgICAgIHJzdFggPSBbXTtcbiAgICAgIHJzdFkgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwLCB4TGVuID0geC5sZW5ndGgsIHlMZW4gPSB5Lmxlbmd0aDsgaSA8IHhMZW4gJiYgaiA8IHlMZW47IGkrKywgaisrKSB7XG4gICAgICAgIG9iaiA9IGNvb3JkLmNvbnZlcnRQb2ludCh7XG4gICAgICAgICAgeDogc2NhbGVYLnNjYWxlKHhbaV0pLFxuICAgICAgICAgIHk6IHNjYWxlWS5zY2FsZSh5W2pdKVxuICAgICAgICB9KTtcbiAgICAgICAgcnN0WC5wdXNoKG9iai54KTtcbiAgICAgICAgcnN0WS5wdXNoKG9iai55KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkoeSkpIHtcbiAgICAgIHggPSBzY2FsZVguc2NhbGUoeCk7XG4gICAgICByc3RZID0gW107XG4gICAgICBlYWNoKHksIGZ1bmN0aW9uICh5VmFsKSB7XG4gICAgICAgIHlWYWwgPSBzY2FsZVkuc2NhbGUoeVZhbCk7XG4gICAgICAgIG9iaiA9IGNvb3JkLmNvbnZlcnRQb2ludCh7XG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5VmFsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChyc3RYICYmIHJzdFggIT09IG9iai54KSB7XG4gICAgICAgICAgaWYgKCFpc0FycmF5KHJzdFgpKSB7XG4gICAgICAgICAgICByc3RYID0gW3JzdFhdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJzdFgucHVzaChvYmoueCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcnN0WCA9IG9iai54O1xuICAgICAgICB9XG5cbiAgICAgICAgcnN0WS5wdXNoKG9iai55KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSh4KSkge1xuICAgICAgeSA9IHNjYWxlWS5zY2FsZSh5KTtcbiAgICAgIHJzdFggPSBbXTtcbiAgICAgIGVhY2goeCwgZnVuY3Rpb24gKHhWYWwpIHtcbiAgICAgICAgeFZhbCA9IHNjYWxlWC5zY2FsZSh4VmFsKTtcbiAgICAgICAgb2JqID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgICAgICB4OiB4VmFsLFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJzdFkgJiYgcnN0WSAhPT0gb2JqLnkpIHtcbiAgICAgICAgICBpZiAoIWlzQXJyYXkocnN0WSkpIHtcbiAgICAgICAgICAgIHJzdFkgPSBbcnN0WV07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcnN0WS5wdXNoKG9iai55KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByc3RZID0gb2JqLnk7XG4gICAgICAgIH1cblxuICAgICAgICByc3RYLnB1c2gob2JqLngpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBzY2FsZVguc2NhbGUoeCk7XG4gICAgICB5ID0gc2NhbGVZLnNjYWxlKHkpO1xuICAgICAgdmFyIHBvaW50ID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVxuICAgICAgfSk7XG4gICAgICByc3RYID0gcG9pbnQueDtcbiAgICAgIHJzdFkgPSBwb2ludC55O1xuICAgIH1cblxuICAgIHJldHVybiBbcnN0WCwgcnN0WV07XG4gIH07XG5cbiAgcmV0dXJuIFBvc2l0aW9uO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb3NpdGlvbjtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBTaGFwZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoU2hhcGUsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBTaGFwZShjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIF90aGlzLm5hbWVzID0gWydzaGFwZSddO1xuICAgIF90aGlzLnR5cGUgPSAnc2hhcGUnO1xuICAgIF90aGlzLmdyYWRpZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cblxuXG4gIHZhciBfcHJvdG8gPSBTaGFwZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldExpbmVhclZhbHVlID0gZnVuY3Rpb24gZ2V0TGluZWFyVmFsdWUocGVyY2VudCkge1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlcztcbiAgICB2YXIgaW5kZXggPSBNYXRoLnJvdW5kKCh2YWx1ZXMubGVuZ3RoIC0gMSkgKiBwZXJjZW50KTtcbiAgICByZXR1cm4gdmFsdWVzW2luZGV4XTtcbiAgfTtcblxuICByZXR1cm4gU2hhcGU7XG59KEJhc2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNoYXBlO1xuXG4vKioqLyB9KSxcbi8qIDY3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcblxudmFyIFNpemUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9CYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNpemUsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBTaXplKGNmZykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX0Jhc2UuY2FsbCh0aGlzLCBjZmcpIHx8IHRoaXM7XG4gICAgX3RoaXMubmFtZXMgPSBbJ3NpemUnXTtcbiAgICBfdGhpcy50eXBlID0gJ3NpemUnO1xuICAgIF90aGlzLmdyYWRpZW50ID0gbnVsbDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gU2l6ZTtcbn0oQmFzZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcblxuLyoqKi8gfSksXG4vKiA2OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgQ29sb3JVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2OSk7XG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbnZhciBDb2xvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ29sb3IsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBDb2xvcihjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9CYXNlLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIF90aGlzLm5hbWVzID0gWydjb2xvciddO1xuICAgIF90aGlzLnR5cGUgPSAnY29sb3InO1xuICAgIF90aGlzLmdyYWRpZW50ID0gbnVsbDtcblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKF90aGlzLnZhbHVlcykpIHtcbiAgICAgIF90aGlzLmxpbmVhciA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gQ29sb3IucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXRMaW5lYXJWYWx1ZSA9IGZ1bmN0aW9uIGdldExpbmVhclZhbHVlKHBlcmNlbnQpIHtcbiAgICB2YXIgZ3JhZGllbnQgPSB0aGlzLmdyYWRpZW50O1xuXG4gICAgaWYgKCFncmFkaWVudCkge1xuICAgICAgdmFyIHZhbHVlcyA9IHRoaXMudmFsdWVzO1xuICAgICAgZ3JhZGllbnQgPSBDb2xvclV0aWwuZ3JhZGllbnQodmFsdWVzKTtcbiAgICAgIHRoaXMuZ3JhZGllbnQgPSBncmFkaWVudDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhZGllbnQocGVyY2VudCk7XG4gIH07XG5cbiAgcmV0dXJuIENvbG9yO1xufShCYXNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2xvcjtcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7IC8vIEdldCB0aGUgaW50ZXJwb2xhdGlvbiBiZXR3ZWVuIGNvbG9yc1xuXG5cbmZ1bmN0aW9uIGdldFZhbHVlKHN0YXJ0LCBlbmQsIHBlcmNlbnQsIGluZGV4KSB7XG4gIHZhciB2YWx1ZSA9IHN0YXJ0W2luZGV4XSArIChlbmRbaW5kZXhdIC0gc3RhcnRbaW5kZXhdKSAqIHBlcmNlbnQ7XG4gIHJldHVybiB2YWx1ZTtcbn0gLy8gY29udmVydCB0byBoZXhcblxuXG5mdW5jdGlvbiBhcnIyaGV4KGFycikge1xuICByZXR1cm4gJyMnICsgdG9SR0JWYWx1ZShhcnJbMF0pICsgdG9SR0JWYWx1ZShhcnJbMV0pICsgdG9SR0JWYWx1ZShhcnJbMl0pO1xufVxuXG5mdW5jdGlvbiB0b1JHQlZhbHVlKHZhbHVlKSB7XG4gIHZhbHVlID0gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoMTYpO1xuXG4gIGlmICh2YWx1ZS5sZW5ndGggPT09IDEpIHtcbiAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBjYWxDb2xvcihjb2xvcnMsIHBlcmNlbnQpIHtcbiAgdmFyIHN0ZXBzID0gY29sb3JzLmxlbmd0aCAtIDE7XG4gIHZhciBzdGVwID0gTWF0aC5mbG9vcihzdGVwcyAqIHBlcmNlbnQpO1xuICB2YXIgbGVmdCA9IHN0ZXBzICogcGVyY2VudCAtIHN0ZXA7XG4gIHZhciBzdGFydCA9IGNvbG9yc1tzdGVwXTtcbiAgdmFyIGVuZCA9IHN0ZXAgPT09IHN0ZXBzID8gc3RhcnQgOiBjb2xvcnNbc3RlcCArIDFdO1xuICB2YXIgcmdiID0gYXJyMmhleChbZ2V0VmFsdWUoc3RhcnQsIGVuZCwgbGVmdCwgMCksIGdldFZhbHVlKHN0YXJ0LCBlbmQsIGxlZnQsIDEpLCBnZXRWYWx1ZShzdGFydCwgZW5kLCBsZWZ0LCAyKV0pO1xuICByZXR1cm4gcmdiO1xufVxuXG5mdW5jdGlvbiBoZXgyYXJyKHN0cikge1xuICB2YXIgYXJyID0gW107XG4gIGFyci5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHIoMSwgMiksIDE2KSk7XG4gIGFyci5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHIoMywgMiksIDE2KSk7XG4gIGFyci5wdXNoKHBhcnNlSW50KHN0ci5zdWJzdHIoNSwgMiksIDE2KSk7XG4gIHJldHVybiBhcnI7XG59XG5cbnZhciBjb2xvckNhY2hlID0ge1xuICBibGFjazogJyMwMDAwMDAnLFxuICBibHVlOiAnIzAwMDBmZicsXG4gIGdyZXk6ICcjODA4MDgwJyxcbiAgZ3JlZW46ICcjMDA4MDAwJyxcbiAgb3JhbmdlOiAnI2ZmYTUwMCcsXG4gIHBpbms6ICcjZmZjMGNiJyxcbiAgcHVycGxlOiAnIzgwMDA4MCcsXG4gIHJlZDogJyNmZjAwMDAnLFxuICB3aGl0ZTogJyNmZmZmZmYnLFxuICB5ZWxsb3c6ICcjZmZmZjAwJ1xufTtcbnZhciBDb2xvclV0aWwgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGlzIGNvbG9yIGluIFJHQiBzcGFjZSwgc3VjaCBhcyAjZjdlYWJhLlxuICAgKiBAcGFyYW0gIHtTdHJpbmd9IGNvbG9yIGNvbG9yIHZhbHVlXG4gICAqIEByZXR1cm4ge1N0cmluZ30gUmV0dXJucyBhIGhleGFkZWNpbWFsIHN0cmluZ1xuICAgKi9cbiAgdG9IZXg6IGZ1bmN0aW9uIHRvSGV4KGNvbG9yKSB7XG4gICAgaWYgKGNvbG9yQ2FjaGVbY29sb3JdKSB7XG4gICAgICByZXR1cm4gY29sb3JDYWNoZVtjb2xvcl07XG4gICAgfVxuXG4gICAgaWYgKGNvbG9yWzBdID09PSAnIycpIHtcbiAgICAgIGlmIChjb2xvci5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgICAgfVxuXG4gICAgICB2YXIgaGV4ID0gY29sb3IucmVwbGFjZSgvXiM/KFthLWZcXGRdKShbYS1mXFxkXSkoW2EtZlxcZF0pJC9pLCBmdW5jdGlvbiAobSwgciwgZywgYikge1xuICAgICAgICByZXR1cm4gJyMnICsgciArIHIgKyBnICsgZyArIGIgKyBiO1xuICAgICAgfSk7IC8vIGhleDMgdG8gaGV4NlxuXG4gICAgICBjb2xvckNhY2hlW2NvbG9yXSA9IGhleDtcbiAgICAgIHJldHVybiBoZXg7XG4gICAgfSAvLyByZ2IvcmdiYSB0byBoZXhcblxuXG4gICAgdmFyIHJzdCA9IGNvbG9yLm1hdGNoKC9ecmdiYT9bXFxzK10/XFwoW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8sW1xccytdPyhcXGQrKVtcXHMrXT8vaSk7XG4gICAgcnN0LnNoaWZ0KCk7XG4gICAgcnN0ID0gYXJyMmhleChyc3QpO1xuICAgIGNvbG9yQ2FjaGVbY29sb3JdID0gcnN0O1xuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIGhleDJhcnI6IGhleDJhcnIsXG5cbiAgLyoqXG4gICAqIGhhbmRsZSB0aGUgZ3JhZGllbnQgY29sb3JcbiAgICogQHBhcmFtICB7QXJyYXl9IGNvbG9ycyB0aGUgY29sb3JzXG4gICAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSBjb2xvciB2YWx1ZVxuICAgKi9cbiAgZ3JhZGllbnQ6IGZ1bmN0aW9uIGdyYWRpZW50KGNvbG9ycykge1xuICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgIGlmIChVdGlsLmlzU3RyaW5nKGNvbG9ycykpIHtcbiAgICAgIGNvbG9ycyA9IGNvbG9ycy5zcGxpdCgnLScpO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChjb2xvcnMsIGZ1bmN0aW9uIChjb2xvcikge1xuICAgICAgaWYgKGNvbG9yLmluZGV4T2YoJyMnKSA9PT0gLTEpIHtcbiAgICAgICAgY29sb3IgPSBDb2xvclV0aWwudG9IZXgoY29sb3IpO1xuICAgICAgfVxuXG4gICAgICBwb2ludHMucHVzaChoZXgyYXJyKGNvbG9yKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwZXJjZW50KSB7XG4gICAgICByZXR1cm4gY2FsQ29sb3IocG9pbnRzLCBwZXJjZW50KTtcbiAgICB9O1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBDb2xvclV0aWw7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNjYWxlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3MSk7XG5cbnZhciBTQ0FMRV9UWVBFU19NQVAgPSB7XG4gIGxpbmVhcjogJ0xpbmVhcicsXG4gIGNhdDogJ0NhdCcsXG4gIHRpbWVDYXQ6ICdUaW1lQ2F0JyxcbiAgaWRlbnRpdHk6ICdJZGVudGl0eSdcbn07XG5cbnZhciBTY2FsZUNvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTY2FsZUNvbnRyb2xsZXIoY2ZnKSB7XG4gICAgLy8gZGVmcyDliJflrprkuYlcbiAgICB0aGlzLmRlZnMgPSB7fTtcbiAgICBVdGlsLm1peCh0aGlzLCBjZmcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjYWxlQ29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9nZXREZWYgPSBmdW5jdGlvbiBfZ2V0RGVmKGZpZWxkKSB7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmRlZnM7XG4gICAgdmFyIGRlZiA9IG51bGw7XG5cbiAgICBpZiAoR2xvYmFsLnNjYWxlc1tmaWVsZF0gfHwgZGVmc1tmaWVsZF0pIHtcbiAgICAgIGRlZiA9IFV0aWwubWl4KHt9LCBHbG9iYWwuc2NhbGVzW2ZpZWxkXSk7XG4gICAgICBVdGlsLmVhY2goZGVmc1tmaWVsZF0sIGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgICAgIGlmIChVdGlsLmlzTmlsKHYpKSB7XG4gICAgICAgICAgZGVsZXRlIGRlZltrXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWZba10gPSB2O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0RGVmYXVsdFR5cGUgPSBmdW5jdGlvbiBfZ2V0RGVmYXVsdFR5cGUoZmllbGQsIGRhdGEsIGRlZikge1xuICAgIGlmIChkZWYgJiYgZGVmLnR5cGUpIHtcbiAgICAgIHJldHVybiBkZWYudHlwZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9ICdsaW5lYXInO1xuICAgIHZhciB2YWx1ZSA9IFV0aWwuQXJyYXkuZmlyc3RWYWx1ZShkYXRhLCBmaWVsZCk7XG5cbiAgICBpZiAoVXRpbC5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnY2F0JztcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFNjYWxlQ2ZnID0gZnVuY3Rpb24gX2dldFNjYWxlQ2ZnKHR5cGUsIGZpZWxkLCBkYXRhLCBkZWYpIHtcbiAgICB2YXIgdmFsdWVzO1xuXG4gICAgaWYgKGRlZiAmJiBkZWYudmFsdWVzKSB7XG4gICAgICB2YWx1ZXMgPSBkZWYudmFsdWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXMgPSBVdGlsLkFycmF5LnZhbHVlcyhkYXRhLCBmaWVsZCk7XG4gICAgfVxuXG4gICAgdmFyIGNmZyA9IHtcbiAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgfTtcblxuICAgIGlmICh0eXBlICE9PSAnY2F0JyAmJiB0eXBlICE9PSAndGltZUNhdCcpIHtcbiAgICAgIGlmICghZGVmIHx8ICEoZGVmLm1pbiAmJiBkZWYubWF4KSkge1xuICAgICAgICB2YXIgX1V0aWwkQXJyYXkkZ2V0UmFuZ2UgPSBVdGlsLkFycmF5LmdldFJhbmdlKHZhbHVlcyksXG4gICAgICAgICAgICBtaW4gPSBfVXRpbCRBcnJheSRnZXRSYW5nZS5taW4sXG4gICAgICAgICAgICBtYXggPSBfVXRpbCRBcnJheSRnZXRSYW5nZS5tYXg7XG5cbiAgICAgICAgY2ZnLm1pbiA9IG1pbjtcbiAgICAgICAgY2ZnLm1heCA9IG1heDtcbiAgICAgICAgY2ZnLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjZmcuaXNSb3VuZGluZyA9IGZhbHNlOyAvLyB1c2VkIGZvciB0aWNrQ291bnQgY2FsY3VsYXRpb25cbiAgICB9XG5cbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVTY2FsZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjYWxlKGZpZWxkLCBkYXRhKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGRlZiA9IHNlbGYuX2dldERlZihmaWVsZCk7XG5cbiAgICB2YXIgc2NhbGU7XG5cbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBpZiAoZGVmICYmIGRlZi50eXBlKSB7XG4gICAgICAgIGRlZi5maWVsZCA9IGZpZWxkO1xuICAgICAgICBzY2FsZSA9IG5ldyBTY2FsZVtTQ0FMRV9UWVBFU19NQVBbZGVmLnR5cGVdXShkZWYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGUgPSBuZXcgU2NhbGUuSWRlbnRpdHkoe1xuICAgICAgICAgIHZhbHVlOiBmaWVsZCxcbiAgICAgICAgICBmaWVsZDogZmllbGQudG9TdHJpbmcoKSxcbiAgICAgICAgICB2YWx1ZXM6IFtmaWVsZF1cbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3RPYmogPSBkYXRhWzBdO1xuICAgIHZhciBmaXJzdFZhbHVlID0gZmlyc3RPYmpbZmllbGRdO1xuXG4gICAgaWYgKGZpcnN0VmFsdWUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0VmFsdWUgPSBVdGlsLkFycmF5LmZpcnN0VmFsdWUoZGF0YSwgZmllbGQpO1xuICAgIH1cblxuICAgIGlmIChVdGlsLmlzTnVtYmVyKGZpZWxkKSB8fCBVdGlsLmlzTmlsKGZpcnN0VmFsdWUpICYmICFkZWYpIHtcbiAgICAgIHNjYWxlID0gbmV3IFNjYWxlLklkZW50aXR5KHtcbiAgICAgICAgdmFsdWU6IGZpZWxkLFxuICAgICAgICBmaWVsZDogZmllbGQudG9TdHJpbmcoKSxcbiAgICAgICAgdmFsdWVzOiBbZmllbGRdXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHR5cGUgPSBzZWxmLl9nZXREZWZhdWx0VHlwZShmaWVsZCwgZGF0YSwgZGVmKTtcblxuICAgICAgdmFyIGNmZyA9IHNlbGYuX2dldFNjYWxlQ2ZnKHR5cGUsIGZpZWxkLCBkYXRhLCBkZWYpO1xuXG4gICAgICBkZWYgJiYgVXRpbC5taXgoY2ZnLCBkZWYpO1xuICAgICAgc2NhbGUgPSBuZXcgU2NhbGVbU0NBTEVfVFlQRVNfTUFQW3R5cGVdXShjZmcpO1xuICAgIH1cblxuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICByZXR1cm4gU2NhbGVDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjYWxlQ29udHJvbGxlcjtcblxuLyoqKi8gfSksXG4vKiA3MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU2NhbGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg3Mik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTY2FsZTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgVGhlIG1lYXN1cmVtZW50IG9mIGxpbmVhciBkYXRhIHNjYWxlIGZ1bmN0aW9uXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xuXG5cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBlYWNoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIG51bWJlckF1dG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDczKTtcbi8qKlxuICog57q/5oCn5bqm6YePXG4gKiBAY2xhc3MgU2NhbGUuTGluZWFyXG4gKi9cblxuXG52YXIgTGluZWFyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShMaW5lYXIsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBMaW5lYXIoKSB7XG4gICAgcmV0dXJuIF9CYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaW5lYXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgX0Jhc2UucHJvdG90eXBlLl9pbml0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYudHlwZSA9ICdsaW5lYXInO1xuICAgIHNlbGYuaXNMaW5lYXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIOaYr+WQpuS4uuS6hueUqOaIt+S5oOaDr++8jOS8mOWMlm1pbixtYXjlkox0aWNrc++8jOWmguaenOi/m+ihjOS8mOWMlu+8jOWImeS8muagueaNrueUn+aIkOeahHRpY2tz6LCD5pW0bWluLG1heO+8jOWQpuWImeiIjeW8gyhtaW4sbWF4KeiMg+WbtOS5i+WklueahHRpY2tzXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cblxuICAgIHNlbGYubmljZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIG1pbiB2YWx1ZSBvZiB0aGUgc2NhbGVcbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKi9cblxuICAgIHNlbGYubWluID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBtaW4gdmFsdWUgbGltaXR0ZWQgb2YgdGhlIHNjYWxlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLm1pbkxpbWl0ID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiBtYXggdmFsdWUgb2YgdGhlIHNjYWxlXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLm1heCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogbWF4IHZhbHVlIGxpbWl0dGVkIG9mIHRoZSBzY2FsZVxuICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqL1xuXG4gICAgc2VsZi5tYXhMaW1pdCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog6Ieq5Yqo55Sf5oiQ5qCH6K6w5pe255qE5Liq5pWwXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLnRpY2tDb3VudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5Z2Q5qCH6L2054K55LmL6Ze055qE6Ze06Led77yM5oyH55qE5piv55yf5a6e5pWw5o2u55qE5beu5YC8XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLnRpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog5Z2Q5qCH6L2054K55LmL6Ze055qE5pyA5bCP6Ze06Led77yM5oyH55qE5piv55yf5a6e5pWw5o2u55qE5beu5YC8XG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICovXG5cbiAgICBzZWxmLm1pblRpY2tJbnRlcnZhbCA9IG51bGw7XG4gICAgLyoqXG4gICAgICog55So5LqO6K6h566X5Z2Q5qCH54K55pe26YC86L+R55qE5pWw57uEXG4gICAgICogQHR5cGUge0FycmF5fVxuICAgICAqL1xuXG4gICAgc2VsZi5zbmFwQXJyYXkgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoIXNlbGYudGlja3MpIHtcbiAgICAgIHNlbGYubWluID0gc2VsZi50cmFuc2xhdGUoc2VsZi5taW4pO1xuICAgICAgc2VsZi5tYXggPSBzZWxmLnRyYW5zbGF0ZShzZWxmLm1heCk7XG4gICAgICBzZWxmLmluaXRUaWNrcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdGlja3MgPSBzZWxmLnRpY2tzO1xuICAgICAgdmFyIGZpcnN0VmFsdWUgPSBzZWxmLnRyYW5zbGF0ZSh0aWNrc1swXSk7XG4gICAgICB2YXIgbGFzdFZhbHVlID0gc2VsZi50cmFuc2xhdGUodGlja3NbdGlja3MubGVuZ3RoIC0gMV0pO1xuXG4gICAgICBpZiAoaXNOaWwoc2VsZi5taW4pIHx8IHNlbGYubWluID4gZmlyc3RWYWx1ZSkge1xuICAgICAgICBzZWxmLm1pbiA9IGZpcnN0VmFsdWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc05pbChzZWxmLm1heCkgfHwgc2VsZi5tYXggPCBsYXN0VmFsdWUpIHtcbiAgICAgICAgc2VsZi5tYXggPSBsYXN0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiDorqHnrpflnZDmoIfngrlcbiAgICogQHByb3RlY3RlZFxuICAgKiBAcmV0dXJuIHtBcnJheX0g6K6h566X5a6M5oiQ55qE5Z2Q5qCH54K5XG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZVRpY2tzID0gZnVuY3Rpb24gY2FsY3VsYXRlVGlja3MoKSB7XG4gICAgdmFyIG1pbiA9IHRoaXMubWluLFxuICAgICAgICBtYXggPSB0aGlzLm1heCxcbiAgICAgICAgbWluTGltaXQgPSB0aGlzLm1pbkxpbWl0LFxuICAgICAgICBtYXhMaW1pdCA9IHRoaXMubWF4TGltaXQsXG4gICAgICAgIHRpY2tDb3VudCA9IHRoaXMudGlja0NvdW50LFxuICAgICAgICB0aWNrSW50ZXJ2YWwgPSB0aGlzLnRpY2tJbnRlcnZhbCxcbiAgICAgICAgbWluVGlja0ludGVydmFsID0gdGhpcy5taW5UaWNrSW50ZXJ2YWwsXG4gICAgICAgIHNuYXBBcnJheSA9IHRoaXMuc25hcEFycmF5O1xuXG4gICAgaWYgKHRpY2tDb3VudCA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdsaW5lYXIgc2NhbGVcXCd0aWNrQ291bnQgc2hvdWxkIG5vdCBiZSAxJyk7XG4gICAgfVxuXG4gICAgaWYgKG1heCA8IG1pbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWF4OiBcIiArIG1heCArIFwiIHNob3VsZCBub3QgYmUgbGVzcyB0aGFuIG1pbjogXCIgKyBtaW4pO1xuICAgIH1cblxuICAgIHZhciB0bXAgPSBudW1iZXJBdXRvKHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXgsXG4gICAgICBtaW5MaW1pdDogbWluTGltaXQsXG4gICAgICBtYXhMaW1pdDogbWF4TGltaXQsXG4gICAgICBtaW5Db3VudDogdGlja0NvdW50LFxuICAgICAgbWF4Q291bnQ6IHRpY2tDb3VudCxcbiAgICAgIGludGVydmFsOiB0aWNrSW50ZXJ2YWwsXG4gICAgICBtaW5UaWNrSW50ZXJ2YWw6IG1pblRpY2tJbnRlcnZhbCxcbiAgICAgIHNuYXBBcnJheTogc25hcEFycmF5XG4gICAgfSk7XG4gICAgcmV0dXJuIHRtcC50aWNrcztcbiAgfSAvLyDliJ3lp4vljJZ0aWNrc1xuICA7XG5cbiAgX3Byb3RvLmluaXRUaWNrcyA9IGZ1bmN0aW9uIGluaXRUaWNrcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNhbFRpY2tzID0gc2VsZi5jYWxjdWxhdGVUaWNrcygpO1xuXG4gICAgaWYgKHNlbGYubmljZSkge1xuICAgICAgLy8g5aaC5p6c6ZyA6KaB5LyY5YyW5pi+56S655qEdGlja1xuICAgICAgc2VsZi50aWNrcyA9IGNhbFRpY2tzO1xuICAgICAgc2VsZi5taW4gPSBjYWxUaWNrc1swXTtcbiAgICAgIHNlbGYubWF4ID0gY2FsVGlja3NbY2FsVGlja3MubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB0aWNrcyA9IFtdO1xuICAgICAgZWFjaChjYWxUaWNrcywgZnVuY3Rpb24gKHRpY2spIHtcbiAgICAgICAgaWYgKHRpY2sgPj0gc2VsZi5taW4gJiYgdGljayA8PSBzZWxmLm1heCkge1xuICAgICAgICAgIHRpY2tzLnB1c2godGljayk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyDlpoLmnpwgdGlja3Mg5Li656m677yM55u05o6l6L6T5YWl5pyA5bCP5YC844CB5pyA5aSn5YC8XG5cbiAgICAgIGlmICghdGlja3MubGVuZ3RoKSB7XG4gICAgICAgIHRpY2tzLnB1c2goc2VsZi5taW4pO1xuICAgICAgICB0aWNrcy5wdXNoKHNlbGYubWF4KTtcbiAgICAgIH1cblxuICAgICAgc2VsZi50aWNrcyA9IHRpY2tzO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUodmFsdWUpIHtcbiAgICBpZiAoaXNOaWwodmFsdWUpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHZhciBtYXggPSB0aGlzLm1heDtcbiAgICB2YXIgbWluID0gdGhpcy5taW47XG5cbiAgICBpZiAobWF4ID09PSBtaW4pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHZhciBwZXJjZW50ID0gKHZhbHVlIC0gbWluKSAvIChtYXggLSBtaW4pO1xuICAgIHZhciByYW5nZU1pbiA9IHRoaXMucmFuZ2VNaW4oKTtcbiAgICB2YXIgcmFuZ2VNYXggPSB0aGlzLnJhbmdlTWF4KCk7XG4gICAgcmV0dXJuIHJhbmdlTWluICsgcGVyY2VudCAqIChyYW5nZU1heCAtIHJhbmdlTWluKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmludmVydCA9IGZ1bmN0aW9uIGludmVydCh2YWx1ZSkge1xuICAgIHZhciBwZXJjZW50ID0gKHZhbHVlIC0gdGhpcy5yYW5nZU1pbigpKSAvICh0aGlzLnJhbmdlTWF4KCkgLSB0aGlzLnJhbmdlTWluKCkpO1xuICAgIHJldHVybiB0aGlzLm1pbiArIHBlcmNlbnQgKiAodGhpcy5tYXggLSB0aGlzLm1pbik7XG4gIH07XG5cbiAgcmV0dXJuIExpbmVhcjtcbn0oQmFzZSk7XG5cbkJhc2UuTGluZWFyID0gTGluZWFyO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lYXI7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOiHquWKqOiuoeeul+aVsOWtl+WdkOagh+i9tFxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbnZhciBpc05pbCA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgQXV0b1V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxudmFyIE1JTl9DT1VOVCA9IDU7XG52YXIgTUFYX0NPVU5UID0gNztcbnZhciBTTkFQX0NPVU5UX0FSUkFZID0gWzAsIDEsIDEuMiwgMS41LCAxLjYsIDIsIDIuMiwgMi40LCAyLjUsIDMsIDQsIDUsIDYsIDcuNSwgOCwgMTBdO1xudmFyIFNOQVBfQVJSQVkgPSBbMCwgMSwgMiwgNCwgNSwgMTBdO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gIHZhciBtaW4gPSBpbmZvLm1pbjtcbiAgdmFyIG1heCA9IGluZm8ubWF4O1xuICB2YXIgaW50ZXJ2YWwgPSBpbmZvLmludGVydmFsO1xuICB2YXIgbWluVGlja0ludGVydmFsID0gaW5mby5taW5UaWNrSW50ZXJ2YWw7XG4gIHZhciB0aWNrcyA9IFtdO1xuICB2YXIgbWluQ291bnQgPSBpbmZvLm1pbkNvdW50IHx8IE1JTl9DT1VOVDtcbiAgdmFyIG1heENvdW50ID0gaW5mby5tYXhDb3VudCB8fCBNQVhfQ09VTlQ7XG4gIHZhciBpc0ZpeGVkQ291bnQgPSBtaW5Db3VudCA9PT0gbWF4Q291bnQ7IC8vIOaYr+WQpumZkOWumuatu+S6huS4quaVsFxuXG4gIHZhciBtaW5MaW1pdCA9IGlzTmlsKGluZm8ubWluTGltaXQpID8gLUluZmluaXR5IDogaW5mby5taW5MaW1pdDsgLy8g6ZmQ5a6a55qE5pyA5bCP5YC8XG5cbiAgdmFyIG1heExpbWl0ID0gaXNOaWwoaW5mby5tYXhMaW1pdCkgPyBJbmZpbml0eSA6IGluZm8ubWF4TGltaXQ7IC8vIOmZkOWumuacgOWkp+WAvFxuXG4gIHZhciBhdmdDb3VudCA9IChtaW5Db3VudCArIG1heENvdW50KSAvIDI7XG4gIHZhciBjb3VudCA9IGF2Z0NvdW50OyAvLyDnlKjmiLfkvKDlhaXnmoTpgLzov5HmlbDnu4RcblxuICB2YXIgc25hcEFycmF5ID0gaW5mby5zbmFwQXJyYXkgPyBpbmZvLnNuYXBBcnJheSA6IGlzRml4ZWRDb3VudCA/IFNOQVBfQ09VTlRfQVJSQVkgOiBTTkFQX0FSUkFZOyAvLyDlpoLmnpzpmZDlrprlpKflsI/ojIPlm7TvvIzlkIzml7blpKflsI/ojIPlm7TnrYnkuo7nlKjmiLfkvKDlhaXnmoTojIPlm7TvvIzlkIzml7bpmZDlrprkuobkuKrmlbDvvIxpbnRlcnZhbCDmjInnhafkuKrmlbDlnYfliIZcblxuICBpZiAobWluID09PSBtaW5MaW1pdCAmJiBtYXggPT09IG1heExpbWl0ICYmIGlzRml4ZWRDb3VudCkge1xuICAgIGludGVydmFsID0gKG1heCAtIG1pbikgLyAoY291bnQgLSAxKTtcbiAgfVxuXG4gIGlmIChpc05pbChtaW4pKSB7XG4gICAgbWluID0gMDtcbiAgfVxuXG4gIGlmIChpc05pbChtYXgpKSB7XG4gICAgbWF4ID0gMDtcbiAgfVxuXG4gIGlmIChtYXggPT09IG1pbikge1xuICAgIGlmIChtaW4gPT09IDApIHtcbiAgICAgIG1heCA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChtaW4gPiAwKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXggPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXggLSBtaW4gPCA1ICYmICFpbnRlcnZhbCAmJiBtYXggLSBtaW4gPj0gMSkge1xuICAgICAgaW50ZXJ2YWwgPSAxO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc05pbChpbnRlcnZhbCkpIHtcbiAgICAvLyDorqHnrpfpl7Tot51cbiAgICB2YXIgdGVtcCA9IChtYXggLSBtaW4pIC8gKGF2Z0NvdW50IC0gMSk7XG4gICAgaW50ZXJ2YWwgPSBBdXRvVXRpbC5zbmFwRmFjdG9yVG8odGVtcCwgc25hcEFycmF5LCAnY2VpbCcpO1xuXG4gICAgaWYgKG1heENvdW50ICE9PSBtaW5Db3VudCkge1xuICAgICAgY291bnQgPSBwYXJzZUludCgobWF4IC0gbWluKSAvIGludGVydmFsLCAxMCk7XG5cbiAgICAgIGlmIChjb3VudCA+IG1heENvdW50KSB7XG4gICAgICAgIGNvdW50ID0gbWF4Q291bnQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA8IG1pbkNvdW50KSB7XG4gICAgICAgIGNvdW50ID0gbWluQ291bnQ7XG4gICAgICB9IC8vIOS4jeehruWumnRpY2vnmoTkuKrmlbDml7bvvIzkvb/lvpd0aWNr5YGP5bCPXG5cblxuICAgICAgaW50ZXJ2YWwgPSBBdXRvVXRpbC5zbmFwRmFjdG9yVG8oKG1heCAtIG1pbikgLyAoY291bnQgLSAxKSwgc25hcEFycmF5LCAnZmxvb3InKTtcbiAgICB9XG4gIH0gLy8gaW50ZXJ2YWwgc2hvdWxkIG5vdCBiZSBsZXNzIHRoYW4gbWluVGlja0ludGVydmFsXG5cblxuICBpZiAoaXNOdW1iZXIobWluVGlja0ludGVydmFsKSAmJiBpbnRlcnZhbCA8IG1pblRpY2tJbnRlcnZhbCkge1xuICAgIGludGVydmFsID0gbWluVGlja0ludGVydmFsO1xuICB9XG5cbiAgaWYgKGluZm8uaW50ZXJ2YWwgfHwgbWF4Q291bnQgIT09IG1pbkNvdW50KSB7XG4gICAgLy8g5qCh5q2jIG1heCDlkowgbWluXG4gICAgbWF4ID0gTWF0aC5taW4oQXV0b1V0aWwuc25hcE11bHRpcGxlKG1heCwgaW50ZXJ2YWwsICdjZWlsJyksIG1heExpbWl0KTsgLy8g5ZCR5LiK6YC86L+RXG5cbiAgICBtaW4gPSBNYXRoLm1heChBdXRvVXRpbC5zbmFwTXVsdGlwbGUobWluLCBpbnRlcnZhbCwgJ2Zsb29yJyksIG1pbkxpbWl0KTsgLy8g5ZCR5LiL6YC86L+RXG5cbiAgICBjb3VudCA9IE1hdGgucm91bmQoKG1heCAtIG1pbikgLyBpbnRlcnZhbCk7XG4gICAgbWluID0gQXV0b1V0aWwuZml4ZWRCYXNlKG1pbiwgaW50ZXJ2YWwpO1xuICAgIG1heCA9IEF1dG9VdGlsLmZpeGVkQmFzZShtYXgsIGludGVydmFsKTtcbiAgfSBlbHNlIHtcbiAgICBhdmdDb3VudCA9IHBhcnNlSW50KGF2Z0NvdW50LCAxMCk7IC8vIOWPluaVtFxuXG4gICAgdmFyIGF2ZyA9IChtYXggKyBtaW4pIC8gMjtcbiAgICB2YXIgYXZnVGljayA9IEF1dG9VdGlsLnNuYXBNdWx0aXBsZShhdmcsIGludGVydmFsLCAnY2VpbCcpO1xuICAgIHZhciBzaWRlQ291bnQgPSBNYXRoLmZsb29yKChhdmdDb3VudCAtIDIpIC8gMik7XG4gICAgdmFyIG1heFRpY2sgPSBhdmdUaWNrICsgc2lkZUNvdW50ICogaW50ZXJ2YWw7XG4gICAgdmFyIG1pblRpY2s7XG5cbiAgICBpZiAoYXZnQ291bnQgJSAyID09PSAwKSB7XG4gICAgICBtaW5UaWNrID0gYXZnVGljayAtIHNpZGVDb3VudCAqIGludGVydmFsO1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5UaWNrID0gYXZnVGljayAtIChzaWRlQ291bnQgKyAxKSAqIGludGVydmFsO1xuICAgIH1cblxuICAgIHdoaWxlIChtYXhUaWNrIDwgbWF4KSB7XG4gICAgICAvLyDkv53or4HorqHnrpflh7rmnaXnmoTliLvluqbmnIDlpKflgLwgbWF4VGljayDkuI3lsI/kuo7mlbDmja7mnIDlpKflgLwgbWF4XG4gICAgICBtYXhUaWNrID0gQXV0b1V0aWwuZml4ZWRCYXNlKG1heFRpY2sgKyBpbnRlcnZhbCwgaW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIHdoaWxlIChtaW5UaWNrID4gbWluKSB7XG4gICAgICAvLyDkv53or4HorqHnrpflh7rmnaXnmoTliLvluqbmnIDlsI/lgLwgbWluVGljayDkuI3lsI/kuo7mlbDmja7mnIDlpKflgLwgbWluXG4gICAgICBtaW5UaWNrID0gQXV0b1V0aWwuZml4ZWRCYXNlKG1pblRpY2sgLSBpbnRlcnZhbCwgaW50ZXJ2YWwpOyAvLyDpmLLmraLotoXluLjmta7ngrnmlbDorqHnrpfpl67pophcbiAgICB9XG5cbiAgICBtYXggPSBtYXhUaWNrO1xuICAgIG1pbiA9IG1pblRpY2s7XG4gIH1cblxuICBtYXggPSBNYXRoLm1pbihtYXgsIG1heExpbWl0KTtcbiAgbWluID0gTWF0aC5tYXgobWluLCBtaW5MaW1pdCk7XG4gIHRpY2tzLnB1c2gobWluKTtcblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGNvdW50OyBpKyspIHtcbiAgICB2YXIgdGlja1ZhbHVlID0gQXV0b1V0aWwuZml4ZWRCYXNlKGludGVydmFsICogaSArIG1pbiwgaW50ZXJ2YWwpO1xuXG4gICAgaWYgKHRpY2tWYWx1ZSA8IG1heCkge1xuICAgICAgdGlja3MucHVzaCh0aWNrVmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aWNrc1t0aWNrcy5sZW5ndGggLSAxXSA8IG1heCkge1xuICAgIHRpY2tzLnB1c2gobWF4KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgaW50ZXJ2YWw6IGludGVydmFsLFxuICAgIGNvdW50OiBjb3VudCxcbiAgICB0aWNrczogdGlja3NcbiAgfTtcbn07XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOiuoeeul+aWueazlVxuICogQGF1dGhvciBkeHE2MTNAZ21haWwuY29tXG4gKi9cbi8vIOWmguaenOWwj+aVsOeCueWQjumdoui2hei/hyAxMCDkvY3mta7ngrnmlbDml7bov5vooYzkuIDkuIvlpITnkIZcbnZhciBERUNJTUFMX0xFTkdUSCA9IDEyOyAvLyDojrflj5bns7vmlbBcblxuZnVuY3Rpb24gZ2V0RmFjdG9yKHYpIHtcbiAgdmFyIGZhY3RvciA9IDE7XG5cbiAgaWYgKHYgPT09IEluZmluaXR5IHx8IHYgPT09IC1JbmZpbml0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IHN1cHBvcnQgSW5maW5pdHkhJyk7XG4gIH1cblxuICBpZiAodiA8IDEpIHtcbiAgICB2YXIgY291bnQgPSAwO1xuXG4gICAgd2hpbGUgKHYgPCAxKSB7XG4gICAgICBmYWN0b3IgPSBmYWN0b3IgLyAxMDtcbiAgICAgIHYgPSB2ICogMTA7XG4gICAgICBjb3VudCsrO1xuICAgIH0gLy8g5rWu54K55pWw6K6h566X5Ye6546w6Zeu6aKYXG5cblxuICAgIGlmIChmYWN0b3IudG9TdHJpbmcoKS5sZW5ndGggPiBERUNJTUFMX0xFTkdUSCkge1xuICAgICAgZmFjdG9yID0gcGFyc2VGbG9hdChmYWN0b3IudG9GaXhlZChjb3VudCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAodiA+IDEwKSB7XG4gICAgICBmYWN0b3IgPSBmYWN0b3IgKiAxMDtcbiAgICAgIHYgPSB2IC8gMTA7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhY3Rvcjtcbn0gLy8g5Y+W5bCP5LqO5b2T5YmN5YC855qEXG5cblxuZnVuY3Rpb24gYXJyYXlGbG9vcih2YWx1ZXMsIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmIChsZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgdmFyIHByZSA9IHZhbHVlc1swXTtcblxuICBpZiAodmFsdWUgPCB2YWx1ZXNbMF0pIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgaWYgKHZhbHVlID49IHZhbHVlc1tsZW5ndGggLSAxXSkge1xuICAgIHJldHVybiB2YWx1ZXNbbGVuZ3RoIC0gMV07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZSA8IHZhbHVlc1tpXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcHJlID0gdmFsdWVzW2ldO1xuICB9XG5cbiAgcmV0dXJuIHByZTtcbn0gLy8g5aSn5LqO5b2T5YmN5YC855qE56ys5LiA5LiqXG5cblxuZnVuY3Rpb24gYXJyYXlDZWlsaW5nKHZhbHVlcywgdmFsdWUpIHtcbiAgdmFyIGxlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBOYU47XG4gIH0gLy8gdmFyIHByZSA9IHZhbHVlc1swXTtcblxuXG4gIHZhciByc3Q7XG5cbiAgaWYgKHZhbHVlID4gdmFsdWVzW2xlbmd0aCAtIDFdKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIGlmICh2YWx1ZSA8IHZhbHVlc1swXSkge1xuICAgIHJldHVybiB2YWx1ZXNbMF07XG4gIH1cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmICh2YWx1ZSA8PSB2YWx1ZXNbaV0pIHtcbiAgICAgIHJzdCA9IHZhbHVlc1tpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByc3Q7XG59XG5cbnZhciBVdGlsID0ge1xuICAvLyDojrflj5bpgLzov5HnmoTmlbDlgLxcbiAgc25hcEZhY3RvclRvOiBmdW5jdGlvbiBzbmFwRmFjdG9yVG8odiwgYXJyLCBzbmFwVHlwZSkge1xuICAgIC8vIOWBh+iuviB2ID0gLTUxMixpc0Zsb29yID0gdHJ1ZVxuICAgIGlmIChpc05hTih2KSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG5cbiAgICB2YXIgZmFjdG9yID0gMTsgLy8g6K6h566X57O75pWwXG5cbiAgICBpZiAodiAhPT0gMCkge1xuICAgICAgaWYgKHYgPCAwKSB7XG4gICAgICAgIGZhY3RvciA9IC0xO1xuICAgICAgfVxuXG4gICAgICB2ID0gdiAqIGZhY3RvcjsgLy8gdiA9IDUxMlxuXG4gICAgICB2YXIgdG1wRmFjdG9yID0gZ2V0RmFjdG9yKHYpO1xuICAgICAgZmFjdG9yID0gZmFjdG9yICogdG1wRmFjdG9yOyAvLyBmYWN0b3IgPSAtMTAwXG5cbiAgICAgIHYgPSB2IC8gdG1wRmFjdG9yOyAvLyB2ID0gNS4xMlxuICAgIH1cblxuICAgIGlmIChzbmFwVHlwZSA9PT0gJ2Zsb29yJykge1xuICAgICAgdiA9IFV0aWwuc25hcEZsb29yKGFyciwgdik7IC8vIHYgPSA1XG4gICAgfSBlbHNlIGlmIChzbmFwVHlwZSA9PT0gJ2NlaWwnKSB7XG4gICAgICB2ID0gVXRpbC5zbmFwQ2VpbGluZyhhcnIsIHYpOyAvLyB2ID0gNlxuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gVXRpbC5zbmFwVG8oYXJyLCB2KTsgLy8g5Zub6IiN5LqU5YWlIDVcbiAgICB9XG5cbiAgICB2YXIgcnN0ID0gcGFyc2VGbG9hdCgodiAqIGZhY3RvcikudG9QcmVjaXNpb24oREVDSU1BTF9MRU5HVEgpKTsgLy8g5aaC5p6c5Ye6546w5rWu54K55pWw6K6h566X6Zeu6aKY77yM6ZyA6KaB5aSE55CG5LiA5LiLXG4gICAgLy8g5aaC5p6c5Ye6546w5rWu54K55pWw6K6h566X6Zeu6aKY77yM6ZyA6KaB5aSE55CG5LiA5LiLXG5cbiAgICBpZiAoTWF0aC5hYnMoZmFjdG9yKSA8IDEgJiYgcnN0LnRvU3RyaW5nKCkubGVuZ3RoID4gREVDSU1BTF9MRU5HVEgpIHtcbiAgICAgIHZhciBkZWNpbWFsVmFsID0gcGFyc2VJbnQoMSAvIGZhY3Rvcik7XG4gICAgICB2YXIgc3ltYm9sID0gZmFjdG9yID4gMCA/IDEgOiAtMTtcbiAgICAgIHJzdCA9IHYgLyBkZWNpbWFsVmFsICogc3ltYm9sO1xuICAgIH1cblxuICAgIHJldHVybiByc3Q7XG4gIH0sXG4gIC8vIOiOt+WPlumAvOi/keeahOWAjeaVsFxuICBzbmFwTXVsdGlwbGU6IGZ1bmN0aW9uIHNuYXBNdWx0aXBsZSh2LCBiYXNlLCBzbmFwVHlwZSkge1xuICAgIHZhciBkaXY7XG5cbiAgICBpZiAoc25hcFR5cGUgPT09ICdjZWlsJykge1xuICAgICAgZGl2ID0gTWF0aC5jZWlsKHYgLyBiYXNlKTtcbiAgICB9IGVsc2UgaWYgKHNuYXBUeXBlID09PSAnZmxvb3InKSB7XG4gICAgICBkaXYgPSBNYXRoLmZsb29yKHYgLyBiYXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGl2ID0gTWF0aC5yb3VuZCh2IC8gYmFzZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpdiAqIGJhc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIOiOt+WPlumAvOi/keeahOWAvO+8jOeUqOS6juWvuem9kOaVsOaNrlxuICAgKiBAcGFyYW0gIHtBcnJheX0gdmFsdWVzICAg5pWw5o2u6ZuG5ZCIXG4gICAqIEBwYXJhbSAge051bWJlcn0gdmFsdWUgICDmlbDlgLxcbiAgICogQHJldHVybiB7TnVtYmVyfSDpgLzov5HnmoTlgLxcbiAgICovXG4gIHNuYXBUbzogZnVuY3Rpb24gc25hcFRvKHZhbHVlcywgdmFsdWUpIHtcbiAgICAvLyDov5nph4zlgYflrpp2YWx1ZXPmmK/ljYfluo/mjpLliJdcbiAgICB2YXIgZmxvb3JWYWwgPSBhcnJheUZsb29yKHZhbHVlcywgdmFsdWUpO1xuICAgIHZhciBjZWlsaW5nVmFsID0gYXJyYXlDZWlsaW5nKHZhbHVlcywgdmFsdWUpO1xuXG4gICAgaWYgKGlzTmFOKGZsb29yVmFsKSB8fCBpc05hTihjZWlsaW5nVmFsKSkge1xuICAgICAgaWYgKHZhbHVlc1swXSA+PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWVzWzBdO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGFzdCA9IHZhbHVlc1t2YWx1ZXMubGVuZ3RoIC0gMV07XG5cbiAgICAgIGlmIChsYXN0IDw9IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBsYXN0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChNYXRoLmFicyh2YWx1ZSAtIGZsb29yVmFsKSA8IE1hdGguYWJzKGNlaWxpbmdWYWwgLSB2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmbG9vclZhbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY2VpbGluZ1ZhbDtcbiAgfSxcblxuICAvKipcbiAgICog6I635Y+W6YC86L+R55qE5pyA5bCP5YC877yM55So5LqO5a+56b2Q5pWw5o2uXG4gICAqIEBwYXJhbSAge0FycmF5fSB2YWx1ZXMgICDmlbDmja7pm4blkIhcbiAgICogQHBhcmFtICB7TnVtYmVyfSB2YWx1ZSAgIOaVsOWAvFxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9IOmAvOi/keeahOacgOWwj+WAvFxuICAgKi9cbiAgc25hcEZsb29yOiBmdW5jdGlvbiBzbmFwRmxvb3IodmFsdWVzLCB2YWx1ZSkge1xuICAgIC8vIOi/memHjOWBh+WumnZhbHVlc+aYr+WNh+W6j+aOkuWIl1xuICAgIHJldHVybiBhcnJheUZsb29yKHZhbHVlcywgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiDojrflj5bpgLzov5HnmoTmnIDlpKflgLzvvIznlKjkuo7lr7npvZDmlbDmja5cbiAgICogQHBhcmFtICB7QXJyYXl9IHZhbHVlcyAgIOaVsOaNrumbhuWQiFxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHZhbHVlICAg5pWw5YC8XG4gICAqIEByZXR1cm4ge051bWJlcn0g6YC86L+R55qE5pyA5aSn5YC8XG4gICAqL1xuICBzbmFwQ2VpbGluZzogZnVuY3Rpb24gc25hcENlaWxpbmcodmFsdWVzLCB2YWx1ZSkge1xuICAgIC8vIOi/memHjOWBh+WumnZhbHVlc+aYr+WNh+W6j+aOkuWIl1xuICAgIHJldHVybiBhcnJheUNlaWxpbmcodmFsdWVzLCB2YWx1ZSk7XG4gIH0sXG4gIGZpeGVkQmFzZTogZnVuY3Rpb24gZml4ZWRCYXNlKHYsIGJhc2UpIHtcbiAgICB2YXIgc3RyID0gYmFzZS50b1N0cmluZygpO1xuICAgIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCcuJyk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2KTtcbiAgICB9XG5cbiAgICB2YXIgbGVuZ3RoID0gc3RyLnN1YnN0cihpbmRleCArIDEpLmxlbmd0aDtcblxuICAgIGlmIChsZW5ndGggPiAyMCkge1xuICAgICAgbGVuZ3RoID0gMjA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQodi50b0ZpeGVkKGxlbmd0aCkpO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBVdGlsO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpO1xuICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbn1cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKTtcblxudmFyIGlzTnVtYmVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNyk7XG5cbnZhciBJZGVudGl0eSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoSWRlbnRpdHksIF9CYXNlKTtcblxuICBmdW5jdGlvbiBJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IElkZW50aXR5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9CYXNlLnByb3RvdHlwZS5faW5pdERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuaXNJZGVudGl0eSA9IHRydWU7XG4gICAgdGhpcy50eXBlID0gJ2lkZW50aXR5JztcbiAgICAvKipcbiAgICAgKiDluLjph4/lgLxcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cblxuICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZ2V0VGV4dCA9IGZ1bmN0aW9uIGdldFRleHQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUudG9TdHJpbmcoKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnNjYWxlID0gZnVuY3Rpb24gc2NhbGUodmFsdWUpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUgJiYgaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmFuZ2VbMF07XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5pbnZlcnQgPSBmdW5jdGlvbiBpbnZlcnQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH07XG5cbiAgcmV0dXJuIElkZW50aXR5O1xufShCYXNlKTtcblxuQmFzZS5JZGVudGl0eSA9IElkZW50aXR5O1xubW9kdWxlLmV4cG9ydHMgPSBJZGVudGl0eTtcblxuLyoqKi8gfSksXG4vKiA3NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBBeGlzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Nyk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxuICAgIFNoYXBlID0gX3JlcXVpcmUuU2hhcGU7XG5cbmZ1bmN0aW9uIGZvcm1hdFRpY2tzKHRpY2tzKSB7XG4gIHZhciB0bXAgPSB0aWNrcy5zbGljZSgwKTtcblxuICBpZiAodG1wLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgZmlyc3QgPSB0bXBbMF07XG4gICAgdmFyIGxhc3QgPSB0bXBbdG1wLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGZpcnN0LnZhbHVlICE9PSAwKSB7XG4gICAgICB0bXAudW5zaGlmdCh7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAobGFzdC52YWx1ZSAhPT0gMSkge1xuICAgICAgdG1wLnB1c2goe1xuICAgICAgICB2YWx1ZTogMVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRtcDtcbn1cblxudmFyIEF4aXNDb250cm9sbGVyID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQXhpc0NvbnRyb2xsZXIoY2ZnKSB7XG4gICAgdGhpcy5heGlzQ2ZnID0ge307XG4gICAgdGhpcy5mcm9udFBsb3QgPSBudWxsO1xuICAgIHRoaXMuYmFja1Bsb3QgPSBudWxsO1xuICAgIHRoaXMuYXhlcyA9IHt9OyAvLyBzdG9yZSB0aGUgYXhlcydzIG9wdGlvbnNcblxuICAgIFV0aWwubWl4KHRoaXMsIGNmZyk7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gQXhpc0NvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5faXNIaWRlID0gZnVuY3Rpb24gX2lzSGlkZShmaWVsZCkge1xuICAgIHZhciBheGlzQ2ZnID0gdGhpcy5heGlzQ2ZnO1xuICAgIHJldHVybiAhYXhpc0NmZyB8fCBheGlzQ2ZnW2ZpZWxkXSA9PT0gZmFsc2U7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRMaW5lUG9zaXRpb24gPSBmdW5jdGlvbiBfZ2V0TGluZVBvc2l0aW9uKHNjYWxlLCBkaW1UeXBlLCBpbmRleCwgdHJhbnNwb3NlZCkge1xuICAgIHZhciBwb3NpdGlvbiA9ICcnO1xuICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgIHZhciBheGlzQ2ZnID0gdGhpcy5heGlzQ2ZnO1xuXG4gICAgaWYgKGF4aXNDZmdbZmllbGRdICYmIGF4aXNDZmdbZmllbGRdLnBvc2l0aW9uKSB7XG4gICAgICBwb3NpdGlvbiA9IGF4aXNDZmdbZmllbGRdLnBvc2l0aW9uO1xuICAgIH0gZWxzZSBpZiAoZGltVHlwZSA9PT0gJ3gnKSB7XG4gICAgICBwb3NpdGlvbiA9IHRyYW5zcG9zZWQgPyAnbGVmdCcgOiAnYm90dG9tJztcbiAgICB9IGVsc2UgaWYgKGRpbVR5cGUgPT09ICd5Jykge1xuICAgICAgcG9zaXRpb24gPSBpbmRleCA/ICdyaWdodCcgOiAnbGVmdCc7XG5cbiAgICAgIGlmICh0cmFuc3Bvc2VkKSB7XG4gICAgICAgIHBvc2l0aW9uID0gJ2JvdHRvbSc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0TGluZUNmZyA9IGZ1bmN0aW9uIF9nZXRMaW5lQ2ZnKGNvb3JkLCBkaW1UeXBlLCBwb3NpdGlvbikge1xuICAgIHZhciBzdGFydDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBmYWN0b3IgPSAxOyAvLyBNYXJrIGNsb2Nrd2lzZSBvciBjb3VudGVyY2xvY2t3aXNlXG5cbiAgICBpZiAoZGltVHlwZSA9PT0gJ3gnKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICAgIC8vIHRoZXJlIHdpbGwgYmUgc2V2ZXJhbCB5IGF4ZXNcbiAgICAgICAgc3RhcnQgPSB7XG4gICAgICAgICAgeDogMSxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICAgIGVuZCA9IHtcbiAgICAgICAgICB4OiAxLFxuICAgICAgICAgIHk6IDFcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0ge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAxXG4gICAgICAgIH07XG4gICAgICAgIGZhY3RvciA9IC0xO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb29yZC50cmFuc3Bvc2VkKSB7XG4gICAgICBmYWN0b3IgKj0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldEZhY3RvcjogZmFjdG9yLFxuICAgICAgc3RhcnQ6IGNvb3JkLmNvbnZlcnRQb2ludChzdGFydCksXG4gICAgICBlbmQ6IGNvb3JkLmNvbnZlcnRQb2ludChlbmQpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2dldENpcmNsZUNmZyA9IGZ1bmN0aW9uIF9nZXRDaXJjbGVDZmcoY29vcmQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnRBbmdsZTogY29vcmQuc3RhcnRBbmdsZSxcbiAgICAgIGVuZEFuZ2xlOiBjb29yZC5lbmRBbmdsZSxcbiAgICAgIGNlbnRlcjogY29vcmQuY2VudGVyLFxuICAgICAgcmFkaXVzOiBjb29yZC5jaXJjbGVSYWRpdXNcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fZ2V0UmFkaXVzQ2ZnID0gZnVuY3Rpb24gX2dldFJhZGl1c0NmZyhjb29yZCkge1xuICAgIHZhciB0cmFuc3Bvc2VkID0gY29vcmQudHJhbnNwb3NlZDtcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcblxuICAgIGlmICh0cmFuc3Bvc2VkKSB7XG4gICAgICBzdGFydCA9IHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICAgIGVuZCA9IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICBlbmQgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDFcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldEZhY3RvcjogLTEsXG4gICAgICBzdGFydDogY29vcmQuY29udmVydFBvaW50KHN0YXJ0KSxcbiAgICAgIGVuZDogY29vcmQuY29udmVydFBvaW50KGVuZClcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fZ2V0QXhpc0NmZyA9IGZ1bmN0aW9uIF9nZXRBeGlzQ2ZnKGNvb3JkLCBzY2FsZSwgdmVydGljYWxTY2FsZSwgZGltVHlwZSwgZGVmYXVsdENmZykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXhpc0NmZyA9IHRoaXMuYXhpc0NmZztcbiAgICB2YXIgdGlja3MgPSBzY2FsZS5nZXRUaWNrcygpO1xuICAgIHZhciBjZmcgPSBVdGlsLmRlZXBNaXgoe1xuICAgICAgdGlja3M6IHRpY2tzLFxuICAgICAgZnJvbnRDb250YWluZXI6IHRoaXMuZnJvbnRQbG90LFxuICAgICAgYmFja0NvbnRhaW5lcjogdGhpcy5iYWNrUGxvdFxuICAgIH0sIGRlZmF1bHRDZmcsIGF4aXNDZmdbc2NhbGUuZmllbGRdKTtcbiAgICB2YXIgbGFiZWxzID0gW107XG4gICAgdmFyIGxhYmVsID0gY2ZnLmxhYmVsO1xuICAgIHZhciBjb3VudCA9IHRpY2tzLmxlbmd0aDtcbiAgICB2YXIgbWF4V2lkdGggPSAwO1xuICAgIHZhciBtYXhIZWlnaHQgPSAwO1xuICAgIHZhciBsYWJlbENmZyA9IGxhYmVsO1xuICAgIFV0aWwuZWFjaCh0aWNrcywgZnVuY3Rpb24gKHRpY2ssIGluZGV4KSB7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGxhYmVsKSkge1xuICAgICAgICB2YXIgZXhlY3V0ZWRMYWJlbCA9IGxhYmVsKHRpY2sudGV4dCwgaW5kZXgsIGNvdW50KTtcbiAgICAgICAgbGFiZWxDZmcgPSBleGVjdXRlZExhYmVsID8gVXRpbC5taXgoe30sIEdsb2JhbC5fZGVmYXVsdEF4aXMubGFiZWwsIGV4ZWN1dGVkTGFiZWwpIDogbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxhYmVsQ2ZnKSB7XG4gICAgICAgIHZhciB0ZXh0U3R5bGUgPSB7fTtcblxuICAgICAgICBpZiAobGFiZWxDZmcudGV4dEFsaWduKSB7XG4gICAgICAgICAgdGV4dFN0eWxlLnRleHRBbGlnbiA9IGxhYmVsQ2ZnLnRleHRBbGlnbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsYWJlbENmZy50ZXh0QmFzZWxpbmUpIHtcbiAgICAgICAgICB0ZXh0U3R5bGUudGV4dEJhc2VsaW5lID0gbGFiZWxDZmcudGV4dEJhc2VsaW5lO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGF4aXNMYWJlbCA9IG5ldyBTaGFwZS5UZXh0KHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdheGlzLWxhYmVsJyxcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB0ZXh0OiB0aWNrLnRleHQsXG4gICAgICAgICAgICBmb250RmFtaWx5OiBzZWxmLmNoYXJ0LmdldCgnY2FudmFzJykuZ2V0KCdmb250RmFtaWx5JylcbiAgICAgICAgICB9LCBsYWJlbENmZyksXG4gICAgICAgICAgdmFsdWU6IHRpY2sudmFsdWUsXG4gICAgICAgICAgdGV4dFN0eWxlOiB0ZXh0U3R5bGUsXG4gICAgICAgICAgdG9wOiBsYWJlbENmZy50b3AsXG4gICAgICAgICAgY29udGV4dDogc2VsZi5jaGFydC5nZXQoJ2NhbnZhcycpLmdldCgnY29udGV4dCcpXG4gICAgICAgIH0pO1xuICAgICAgICBsYWJlbHMucHVzaChheGlzTGFiZWwpO1xuXG4gICAgICAgIHZhciBfYXhpc0xhYmVsJGdldEJCb3ggPSBheGlzTGFiZWwuZ2V0QkJveCgpLFxuICAgICAgICAgICAgd2lkdGggPSBfYXhpc0xhYmVsJGdldEJCb3gud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBfYXhpc0xhYmVsJGdldEJCb3guaGVpZ2h0O1xuXG4gICAgICAgIG1heFdpZHRoID0gTWF0aC5tYXgobWF4V2lkdGgsIHdpZHRoKTtcbiAgICAgICAgbWF4SGVpZ2h0ID0gTWF0aC5tYXgobWF4SGVpZ2h0LCBoZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNmZy5sYWJlbHMgPSBsYWJlbHM7XG4gICAgY2ZnLm1heFdpZHRoID0gbWF4V2lkdGg7XG4gICAgY2ZnLm1heEhlaWdodCA9IG1heEhlaWdodDtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5fY3JlYXRlQXhpcyA9IGZ1bmN0aW9uIF9jcmVhdGVBeGlzKGNvb3JkLCBzY2FsZSwgdmVydGljYWxTY2FsZSwgZGltVHlwZSwgaW5kZXgpIHtcbiAgICBpZiAoaW5kZXggPT09IHZvaWQgMCkge1xuICAgICAgaW5kZXggPSAnJztcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvb3JkVHlwZSA9IGNvb3JkLnR5cGU7XG4gICAgdmFyIHRyYW5zcG9zZWQgPSBjb29yZC50cmFuc3Bvc2VkO1xuICAgIHZhciB0eXBlO1xuICAgIHZhciBrZXk7XG4gICAgdmFyIGRlZmF1bHRDZmc7XG5cbiAgICBpZiAoY29vcmRUeXBlID09PSAnY2FydGVzaWFuJyB8fCBjb29yZFR5cGUgPT09ICdyZWN0Jykge1xuICAgICAgdmFyIHBvc2l0aW9uID0gc2VsZi5fZ2V0TGluZVBvc2l0aW9uKHNjYWxlLCBkaW1UeXBlLCBpbmRleCwgdHJhbnNwb3NlZCk7XG5cbiAgICAgIGRlZmF1bHRDZmcgPSBHbG9iYWwuYXhpc1twb3NpdGlvbl07XG4gICAgICBkZWZhdWx0Q2ZnLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICB0eXBlID0gJ0xpbmUnO1xuICAgICAga2V5ID0gcG9zaXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaW1UeXBlID09PSAneCcgJiYgIXRyYW5zcG9zZWQgfHwgZGltVHlwZSA9PT0gJ3knICYmIHRyYW5zcG9zZWQpIHtcbiAgICAgICAgZGVmYXVsdENmZyA9IEdsb2JhbC5heGlzLmNpcmNsZTtcbiAgICAgICAgdHlwZSA9ICdDaXJjbGUnO1xuICAgICAgICBrZXkgPSAnY2lyY2xlJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmF1bHRDZmcgPSBHbG9iYWwuYXhpcy5yYWRpdXM7XG4gICAgICAgIHR5cGUgPSAnTGluZSc7XG4gICAgICAgIGtleSA9ICdyYWRpdXMnO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjZmcgPSBzZWxmLl9nZXRBeGlzQ2ZnKGNvb3JkLCBzY2FsZSwgdmVydGljYWxTY2FsZSwgZGltVHlwZSwgZGVmYXVsdENmZyk7XG5cbiAgICBjZmcudHlwZSA9IHR5cGU7XG4gICAgY2ZnLmRpbVR5cGUgPSBkaW1UeXBlO1xuICAgIGNmZy52ZXJ0aWNhbFNjYWxlID0gdmVydGljYWxTY2FsZTtcbiAgICBjZmcuaW5kZXggPSBpbmRleDtcbiAgICB0aGlzLmF4ZXNba2V5XSA9IGNmZztcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlQXhpcyA9IGZ1bmN0aW9uIGNyZWF0ZUF4aXMoY29vcmQsIHhTY2FsZSwgeVNjYWxlcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGlmICh4U2NhbGUgJiYgIXNlbGYuX2lzSGlkZSh4U2NhbGUuZmllbGQpKSB7XG4gICAgICBzZWxmLl9jcmVhdGVBeGlzKGNvb3JkLCB4U2NhbGUsIHlTY2FsZXNbMF0sICd4Jyk7XG4gICAgfVxuXG4gICAgVXRpbC5lYWNoKHlTY2FsZXMsIGZ1bmN0aW9uICh5U2NhbGUsIGluZGV4KSB7XG4gICAgICBpZiAoIXNlbGYuX2lzSGlkZSh5U2NhbGUuZmllbGQpKSB7XG4gICAgICAgIHNlbGYuX2NyZWF0ZUF4aXMoY29vcmQsIHlTY2FsZSwgeFNjYWxlLCAneScsIGluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgYXhlcyA9IHRoaXMuYXhlcztcbiAgICB2YXIgY2hhcnQgPSBzZWxmLmNoYXJ0O1xuXG4gICAgaWYgKGNoYXJ0Ll9pc0F1dG9QYWRkaW5nKCkpIHtcbiAgICAgIHZhciB1c2VyUGFkZGluZyA9IFV0aWwucGFyc2VQYWRkaW5nKGNoYXJ0LmdldCgncGFkZGluZycpKTtcbiAgICAgIHZhciBhcHBlbmRQYWRkaW5nID0gVXRpbC5wYXJzZVBhZGRpbmcoY2hhcnQuZ2V0KCdhcHBlbmRQYWRkaW5nJykpO1xuICAgICAgdmFyIGxlZ2VuZFJhbmdlID0gY2hhcnQuZ2V0KCdsZWdlbmRSYW5nZScpIHx8IHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICByaWdodDogMCxcbiAgICAgICAgYm90dG9tOiAwLFxuICAgICAgICBsZWZ0OiAwXG4gICAgICB9O1xuICAgICAgdmFyIHBhZGRpbmcgPSBbdXNlclBhZGRpbmdbMF0gPT09ICdhdXRvJyA/IGxlZ2VuZFJhbmdlLnRvcCArIGFwcGVuZFBhZGRpbmdbMF0gKiAyIDogdXNlclBhZGRpbmdbMF0sIHVzZXJQYWRkaW5nWzFdID09PSAnYXV0bycgPyBsZWdlbmRSYW5nZS5yaWdodCArIGFwcGVuZFBhZGRpbmdbMV0gOiB1c2VyUGFkZGluZ1sxXSwgdXNlclBhZGRpbmdbMl0gPT09ICdhdXRvJyA/IGxlZ2VuZFJhbmdlLmJvdHRvbSArIGFwcGVuZFBhZGRpbmdbMl0gOiB1c2VyUGFkZGluZ1syXSwgdXNlclBhZGRpbmdbM10gPT09ICdhdXRvJyA/IGxlZ2VuZFJhbmdlLmxlZnQgKyBhcHBlbmRQYWRkaW5nWzNdIDogdXNlclBhZGRpbmdbM11dO1xuXG4gICAgICBpZiAoY29vcmQuaXNQb2xhcikge1xuICAgICAgICB2YXIgY2lyY2xlQXhpcyA9IGF4ZXMuY2lyY2xlO1xuXG4gICAgICAgIGlmIChjaXJjbGVBeGlzKSB7XG4gICAgICAgICAgdmFyIG1heEhlaWdodCA9IGNpcmNsZUF4aXMubWF4SGVpZ2h0LFxuICAgICAgICAgICAgICBtYXhXaWR0aCA9IGNpcmNsZUF4aXMubWF4V2lkdGgsXG4gICAgICAgICAgICAgIGxhYmVsT2Zmc2V0ID0gY2lyY2xlQXhpcy5sYWJlbE9mZnNldDtcbiAgICAgICAgICBwYWRkaW5nWzBdICs9IG1heEhlaWdodCArIGxhYmVsT2Zmc2V0O1xuICAgICAgICAgIHBhZGRpbmdbMV0gKz0gbWF4V2lkdGggKyBsYWJlbE9mZnNldDtcbiAgICAgICAgICBwYWRkaW5nWzJdICs9IG1heEhlaWdodCArIGxhYmVsT2Zmc2V0O1xuICAgICAgICAgIHBhZGRpbmdbM10gKz0gbWF4V2lkdGggKyBsYWJlbE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGF4ZXMucmlnaHQgJiYgdXNlclBhZGRpbmdbMV0gPT09ICdhdXRvJykge1xuICAgICAgICAgIHZhciBfYXhlcyRyaWdodCA9IGF4ZXMucmlnaHQsXG4gICAgICAgICAgICAgIF9tYXhXaWR0aCA9IF9heGVzJHJpZ2h0Lm1heFdpZHRoLFxuICAgICAgICAgICAgICBfbGFiZWxPZmZzZXQgPSBfYXhlcyRyaWdodC5sYWJlbE9mZnNldDtcbiAgICAgICAgICBwYWRkaW5nWzFdICs9IF9tYXhXaWR0aCArIF9sYWJlbE9mZnNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGVzLmxlZnQgJiYgdXNlclBhZGRpbmdbM10gPT09ICdhdXRvJykge1xuICAgICAgICAgIHZhciBfYXhlcyRsZWZ0ID0gYXhlcy5sZWZ0LFxuICAgICAgICAgICAgICBfbWF4V2lkdGgyID0gX2F4ZXMkbGVmdC5tYXhXaWR0aCxcbiAgICAgICAgICAgICAgX2xhYmVsT2Zmc2V0MiA9IF9heGVzJGxlZnQubGFiZWxPZmZzZXQ7XG4gICAgICAgICAgcGFkZGluZ1szXSArPSBfbWF4V2lkdGgyICsgX2xhYmVsT2Zmc2V0MjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChheGVzLmJvdHRvbSAmJiB1c2VyUGFkZGluZ1syXSA9PT0gJ2F1dG8nKSB7XG4gICAgICAgICAgdmFyIF9heGVzJGJvdHRvbSA9IGF4ZXMuYm90dG9tLFxuICAgICAgICAgICAgICBfbWF4SGVpZ2h0ID0gX2F4ZXMkYm90dG9tLm1heEhlaWdodCxcbiAgICAgICAgICAgICAgX2xhYmVsT2Zmc2V0MyA9IF9heGVzJGJvdHRvbS5sYWJlbE9mZnNldDtcbiAgICAgICAgICBwYWRkaW5nWzJdICs9IF9tYXhIZWlnaHQgKyBfbGFiZWxPZmZzZXQzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNoYXJ0LnNldCgnX3BhZGRpbmcnLCBwYWRkaW5nKTtcblxuICAgICAgY2hhcnQuX3VwZGF0ZUxheW91dChwYWRkaW5nKTtcbiAgICB9XG5cbiAgICBVdGlsLmVhY2goYXhlcywgZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgIHZhciB0eXBlID0gYXhpcy50eXBlLFxuICAgICAgICAgIGdyaWQgPSBheGlzLmdyaWQsXG4gICAgICAgICAgdmVydGljYWxTY2FsZSA9IGF4aXMudmVydGljYWxTY2FsZSxcbiAgICAgICAgICB0aWNrcyA9IGF4aXMudGlja3MsXG4gICAgICAgICAgZGltVHlwZSA9IGF4aXMuZGltVHlwZSxcbiAgICAgICAgICBwb3NpdGlvbiA9IGF4aXMucG9zaXRpb24sXG4gICAgICAgICAgaW5kZXggPSBheGlzLmluZGV4O1xuICAgICAgdmFyIGFwcGVuZENmZztcblxuICAgICAgaWYgKGNvb3JkLmlzUG9sYXIpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdMaW5lJykge1xuICAgICAgICAgIGFwcGVuZENmZyA9IHNlbGYuX2dldFJhZGl1c0NmZyhjb29yZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0NpcmNsZScpIHtcbiAgICAgICAgICBhcHBlbmRDZmcgPSBzZWxmLl9nZXRDaXJjbGVDZmcoY29vcmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmRDZmcgPSBzZWxmLl9nZXRMaW5lQ2ZnKGNvb3JkLCBkaW1UeXBlLCBwb3NpdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChncmlkICYmIHZlcnRpY2FsU2NhbGUpIHtcbiAgICAgICAgdmFyIGdyaWRQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIHZlcnRpY2FsVGlja3MgPSBmb3JtYXRUaWNrcyh2ZXJ0aWNhbFNjYWxlLmdldFRpY2tzKCkpO1xuICAgICAgICBVdGlsLmVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICAgICAgdmFyIHN1YlBvaW50cyA9IFtdO1xuICAgICAgICAgIFV0aWwuZWFjaCh2ZXJ0aWNhbFRpY2tzLCBmdW5jdGlvbiAodmVydGljYWxUaWNrKSB7XG4gICAgICAgICAgICB2YXIgeCA9IGRpbVR5cGUgPT09ICd4JyA/IHRpY2sudmFsdWUgOiB2ZXJ0aWNhbFRpY2sudmFsdWU7XG4gICAgICAgICAgICB2YXIgeSA9IGRpbVR5cGUgPT09ICd4JyA/IHZlcnRpY2FsVGljay52YWx1ZSA6IHRpY2sudmFsdWU7XG5cbiAgICAgICAgICAgIGlmICh4ID49IDAgJiYgeCA8PSAxICYmIHkgPj0gMCAmJiB5IDw9IDEpIHtcbiAgICAgICAgICAgICAgdmFyIHBvaW50ID0gY29vcmQuY29udmVydFBvaW50KHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHN1YlBvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBncmlkUG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgcG9pbnRzOiBzdWJQb2ludHMsXG4gICAgICAgICAgICBfaWQ6ICdheGlzLScgKyBkaW1UeXBlICsgaW5kZXggKyAnLWdyaWQtJyArIHRpY2sudGlja1ZhbHVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBheGlzLmdyaWRQb2ludHMgPSBncmlkUG9pbnRzO1xuXG4gICAgICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICAgICAgYXhpcy5jZW50ZXIgPSBjb29yZC5jZW50ZXI7XG4gICAgICAgICAgYXhpcy5zdGFydEFuZ2xlID0gY29vcmQuc3RhcnRBbmdsZTtcbiAgICAgICAgICBheGlzLmVuZEFuZ2xlID0gY29vcmQuZW5kQW5nbGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYXBwZW5kQ2ZnLl9pZCA9ICdheGlzLScgKyBkaW1UeXBlO1xuXG4gICAgICBpZiAoIVV0aWwuaXNOaWwoaW5kZXgpKSB7XG4gICAgICAgIGFwcGVuZENmZy5faWQgPSAnYXhpcy0nICsgZGltVHlwZSArIGluZGV4O1xuICAgICAgfVxuXG4gICAgICBuZXcgQXhpc1t0eXBlXShVdGlsLm1peChheGlzLCBhcHBlbmRDZmcpKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmF4ZXMgPSB7fTtcbiAgICB0aGlzLmZyb250UGxvdC5jbGVhcigpO1xuICAgIHRoaXMuYmFja1Bsb3QuY2xlYXIoKTtcbiAgfTtcblxuICByZXR1cm4gQXhpc0NvbnRyb2xsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpc0NvbnRyb2xsZXI7XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIEFic3RyYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbl9fd2VicGFja19yZXF1aXJlX18oNzgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0O1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBBYnN0cmFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgTGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Fic3RyYWN0KSB7XG4gIF9pbmhlcml0c0xvb3NlKExpbmUsIF9BYnN0cmFjdCk7XG5cbiAgZnVuY3Rpb24gTGluZSgpIHtcbiAgICByZXR1cm4gX0Fic3RyYWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9BYnN0cmFjdC5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLmVuZCA9IG51bGw7XG4gIH07XG5cbiAgX3Byb3RvLmdldE9mZnNldFBvaW50ID0gZnVuY3Rpb24gZ2V0T2Zmc2V0UG9pbnQodmFsdWUpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLnN0YXJ0LFxuICAgICAgICBlbmQgPSB0aGlzLmVuZDtcbiAgICByZXR1cm4ge1xuICAgICAgeDogc3RhcnQueCArIChlbmQueCAtIHN0YXJ0LngpICogdmFsdWUsXG4gICAgICB5OiBzdGFydC55ICsgKGVuZC55IC0gc3RhcnQueSkgKiB2YWx1ZVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldEF4aXNWZWN0b3IgPSBmdW5jdGlvbiBnZXRBeGlzVmVjdG9yKCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgIGVuZCA9IHRoaXMuZW5kO1xuICAgIHJldHVybiBbZW5kLnggLSBzdGFydC54LCBlbmQueSAtIHN0YXJ0LnldO1xuICB9O1xuXG4gIF9wcm90by5kcmF3TGluZSA9IGZ1bmN0aW9uIGRyYXdMaW5lKGxpbmVDZmcpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5nZXRDb250YWluZXIobGluZUNmZy50b3ApO1xuICAgIHZhciBzdGFydCA9IHRoaXMuc3RhcnQsXG4gICAgICAgIGVuZCA9IHRoaXMuZW5kO1xuICAgIGNvbnRhaW5lci5hZGRTaGFwZSgnbGluZScsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2F4aXMtbGluZScsXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB4MTogc3RhcnQueCxcbiAgICAgICAgeTE6IHN0YXJ0LnksXG4gICAgICAgIHgyOiBlbmQueCxcbiAgICAgICAgeTI6IGVuZC55XG4gICAgICB9LCBsaW5lQ2ZnKVxuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBMaW5lO1xufShBYnN0cmFjdCk7XG5cbkFic3RyYWN0LkxpbmUgPSBMaW5lO1xubW9kdWxlLmV4cG9ydHMgPSBMaW5lO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIENvbnRhaW5lciA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG52YXIgR3JvdXAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gX3JlcXVpcmUucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuXG52YXIgQ2FudmFzID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgdmFyIF9wcm90byA9IENhbnZhcy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldCA9IGZ1bmN0aW9uIGdldChuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJzW25hbWVdO1xuICB9O1xuXG4gIF9wcm90by5zZXQgPSBmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLl9hdHRyc1tuYW1lXSA9IHZhbHVlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENhbnZhcyhjZmcpIHtcbiAgICB0aGlzLl9hdHRycyA9IFV0aWwubWl4KHtcbiAgICAgIHR5cGU6ICdjYW52YXMnLFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfSwgY2ZnKTtcblxuICAgIHRoaXMuX2luaXRQaXhlbFJhdGlvKCk7XG5cbiAgICB0aGlzLl9pbml0Q2FudmFzKCk7XG4gIH1cblxuICBfcHJvdG8uX2luaXRQaXhlbFJhdGlvID0gZnVuY3Rpb24gX2luaXRQaXhlbFJhdGlvKCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXQoJ3BpeGVsUmF0aW8nKTtcblxuICAgIGlmICghcGl4ZWxSYXRpbykge1xuICAgICAgdGhpcy5zZXQoJ3BpeGVsUmF0aW8nLCBVdGlsLmdldFBpeGVsUmF0aW8oKSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5iZWZvcmVEcmF3ID0gZnVuY3Rpb24gYmVmb3JlRHJhdygpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuX2F0dHJzLmNvbnRleHQ7XG4gICAgdmFyIGVsID0gdGhpcy5fYXR0cnMuZWw7XG4gICAgIVV0aWwuaXNXeCAmJiAhVXRpbC5pc015ICYmIGNvbnRleHQgJiYgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgZWwud2lkdGgsIGVsLmhlaWdodCk7XG4gIH07XG5cbiAgX3Byb3RvLl9pbml0Q2FudmFzID0gZnVuY3Rpb24gX2luaXRDYW52YXMoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBlbCA9IHNlbGYuZ2V0KCdlbCcpO1xuICAgIHZhciBjb250ZXh0ID0gc2VsZi5nZXQoJ2NvbnRleHQnKTtcbiAgICB2YXIgY2FudmFzO1xuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIC8vIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRFxuICAgICAgY2FudmFzID0gY29udGV4dC5jYW52YXM7XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzU3RyaW5nKGVsKSkge1xuICAgICAgLy8gSFRNTEVsZW1lbnQncyBpZFxuICAgICAgY2FudmFzID0gVXRpbC5nZXREb21CeUlkKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSFRNTEVsZW1lbnRcbiAgICAgIGNhbnZhcyA9IGVsO1xuICAgIH1cblxuICAgIGlmICghY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBzcGVjaWZ5IHRoZSBpZCBvciBlbCBvZiB0aGUgY2hhcnQhJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQgJiYgY2FudmFzICYmICFjYW52YXMuZ2V0Q29udGV4dCkge1xuICAgICAgY2FudmFzLmdldENvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgd2lkdGggPSBzZWxmLmdldCgnd2lkdGgnKTtcblxuICAgIGlmICghd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gVXRpbC5nZXRXaWR0aChjYW52YXMpO1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQgPSBzZWxmLmdldCgnaGVpZ2h0Jyk7XG5cbiAgICBpZiAoIWhlaWdodCkge1xuICAgICAgaGVpZ2h0ID0gVXRpbC5nZXRIZWlnaHQoY2FudmFzKTtcbiAgICB9XG5cbiAgICBzZWxmLnNldCgnY2FudmFzJywgdGhpcyk7XG4gICAgc2VsZi5zZXQoJ2VsJywgY2FudmFzKTtcbiAgICBzZWxmLnNldCgnY29udGV4dCcsIGNvbnRleHQgfHwgY2FudmFzLmdldENvbnRleHQoJzJkJykpO1xuICAgIHNlbGYuY2hhbmdlU2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgfTtcblxuICBfcHJvdG8uY2hhbmdlU2l6ZSA9IGZ1bmN0aW9uIGNoYW5nZVNpemUod2lkdGgsIGhlaWdodCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXQoJ3BpeGVsUmF0aW8nKTtcbiAgICB2YXIgY2FudmFzRE9NID0gdGhpcy5nZXQoJ2VsJyk7XG5cbiAgICBpZiAoVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgIGNhbnZhc0RPTS5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgIGNhbnZhc0RPTS5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgIH1cblxuICAgIGlmICghVXRpbC5pc1d4ICYmICFVdGlsLmlzTXkpIHtcbiAgICAgIGNhbnZhc0RPTS53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcbiAgICAgIGNhbnZhc0RPTS5oZWlnaHQgPSBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuXG4gICAgICBpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuICAgICAgICB2YXIgY3R4ID0gdGhpcy5nZXQoJ2NvbnRleHQnKTtcbiAgICAgICAgY3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc2V0KCd3aWR0aCcsIHdpZHRoKTtcbiAgICB0aGlzLnNldCgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICB2YXIgcGl4ZWxSYXRpbyA9IHRoaXMuZ2V0KCdwaXhlbFJhdGlvJyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXQoJ3dpZHRoJyk7XG4gICAgcmV0dXJuIHdpZHRoICogcGl4ZWxSYXRpbztcbiAgfTtcblxuICBfcHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgIHZhciBwaXhlbFJhdGlvID0gdGhpcy5nZXQoJ3BpeGVsUmF0aW8nKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXQoJ2hlaWdodCcpO1xuICAgIHJldHVybiBoZWlnaHQgKiBwaXhlbFJhdGlvO1xuICB9O1xuXG4gIF9wcm90by5nZXRQb2ludEJ5Q2xpZW50ID0gZnVuY3Rpb24gZ2V0UG9pbnRCeUNsaWVudChjbGllbnRYLCBjbGllbnRZKSB7XG4gICAgdmFyIGVsID0gdGhpcy5nZXQoJ2VsJyk7XG4gICAgdmFyIGJib3ggPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgd2lkdGggPSBiYm94LnJpZ2h0IC0gYmJveC5sZWZ0O1xuICAgIHZhciBoZWlnaHQgPSBiYm94LmJvdHRvbSAtIGJib3gudG9wO1xuICAgIHJldHVybiB7XG4gICAgICB4OiAoY2xpZW50WCAtIGJib3gubGVmdCkgKiAoZWwud2lkdGggLyB3aWR0aCksXG4gICAgICB5OiAoY2xpZW50WSAtIGJib3gudG9wKSAqIChlbC5oZWlnaHQgLyBoZWlnaHQpXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2JlZ2luRHJhdyA9IGZ1bmN0aW9uIF9iZWdpbkRyYXcoKSB7XG4gICAgdGhpcy5fYXR0cnMudG9EcmF3ID0gdHJ1ZTtcbiAgfTtcblxuICBfcHJvdG8uX2VuZERyYXcgPSBmdW5jdGlvbiBfZW5kRHJhdygpIHtcbiAgICB0aGlzLl9hdHRycy50b0RyYXcgPSBmYWxzZTtcbiAgfTtcblxuICBfcHJvdG8uZHJhdyA9IGZ1bmN0aW9uIGRyYXcoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZHJhd0lubmVyKCkge1xuICAgICAgc2VsZi5zZXQoJ2FuaW1hdGVIYW5kbGVyJywgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zZXQoJ2FuaW1hdGVIYW5kbGVyJywgdW5kZWZpbmVkKTtcblxuICAgICAgICBpZiAoc2VsZi5nZXQoJ3RvRHJhdycpKSB7XG4gICAgICAgICAgZHJhd0lubmVyKCk7XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIHNlbGYuYmVmb3JlRHJhdygpO1xuXG4gICAgICB0cnkge1xuICAgICAgICB2YXIgY29udGV4dCA9IHNlbGYuX2F0dHJzLmNvbnRleHQ7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHNlbGYuX2F0dHJzLmNoaWxkcmVuO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgIGNoaWxkLmRyYXcoY29udGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoVXRpbC5pc1d4IHx8IFV0aWwuaXNNeSkge1xuICAgICAgICAgIGNvbnRleHQuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChldikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2Vycm9yIGluIGRyYXcgY2FudmFzLCBkZXRhaWwgYXM6Jyk7XG4gICAgICAgIGNvbnNvbGUud2Fybihldik7XG5cbiAgICAgICAgc2VsZi5fZW5kRHJhdygpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9lbmREcmF3KCk7XG4gICAgfVxuXG4gICAgaWYgKHNlbGYuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChzZWxmLmdldCgnYW5pbWF0ZUhhbmRsZXInKSkge1xuICAgICAgdGhpcy5fYmVnaW5EcmF3KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRyYXdJbm5lcigpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2xlYXIoKTtcbiAgICB0aGlzLl9hdHRycyA9IHt9O1xuICAgIHRoaXMuc2V0KCdkZXN0cm95ZWQnLCB0cnVlKTtcbiAgfTtcblxuICBfcHJvdG8uaXNEZXN0cm95ZWQgPSBmdW5jdGlvbiBpc0Rlc3Ryb3llZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQoJ2Rlc3Ryb3llZCcpO1xuICB9O1xuXG4gIHJldHVybiBDYW52YXM7XG59KCk7XG5cblV0aWwubWl4KENhbnZhcy5wcm90b3R5cGUsIENvbnRhaW5lciwge1xuICBnZXRHcm91cENsYXNzOiBmdW5jdGlvbiBnZXRHcm91cENsYXNzKCkge1xuICAgIHJldHVybiBHcm91cDtcbiAgfVxufSk7XG5tb2R1bGUuZXhwb3J0cyA9IENhbnZhcztcblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIF9tb2QobiwgbSkge1xuICByZXR1cm4gKG4gJSBtICsgbSkgJSBtO1xufVxuXG5mdW5jdGlvbiBfYWRkU3RvcChzdGVwcywgZ3JhZGllbnQpIHtcbiAgVXRpbC5lYWNoKHN0ZXBzLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgIGl0ZW0gPSBpdGVtLnNwbGl0KCc6Jyk7XG4gICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKE51bWJlcihpdGVtWzBdKSwgaXRlbVsxXSk7XG4gIH0pO1xufSAvLyB0aGUgc3RyaW5nIGZvcm1hdDogJ2woMCkgMDojZmZmZmZmIDAuNTojN2VjMmYzIDE6IzE4OTBmZidcblxuXG5mdW5jdGlvbiBfcGFyc2VMaW5lR3JhZGllbnQoY29sb3IsIHNoYXBlLCBjb250ZXh0KSB7XG4gIHZhciBhcnIgPSBjb2xvci5zcGxpdCgnICcpO1xuICB2YXIgYW5nbGUgPSBhcnJbMF0uc2xpY2UoMiwgYXJyWzBdLmxlbmd0aCAtIDEpO1xuICBhbmdsZSA9IF9tb2QocGFyc2VGbG9hdChhbmdsZSkgKiBNYXRoLlBJIC8gMTgwLCBNYXRoLlBJICogMik7XG4gIHZhciBzdGVwcyA9IGFyci5zbGljZSgxKTtcblxuICB2YXIgX3NoYXBlJGdldEJCb3ggPSBzaGFwZS5nZXRCQm94KCksXG4gICAgICBtaW5YID0gX3NoYXBlJGdldEJCb3gubWluWCxcbiAgICAgIG1pblkgPSBfc2hhcGUkZ2V0QkJveC5taW5ZLFxuICAgICAgbWF4WCA9IF9zaGFwZSRnZXRCQm94Lm1heFgsXG4gICAgICBtYXhZID0gX3NoYXBlJGdldEJCb3gubWF4WTtcblxuICB2YXIgc3RhcnQ7XG4gIHZhciBlbmQ7XG5cbiAgaWYgKGFuZ2xlID49IDAgJiYgYW5nbGUgPCAwLjUgKiBNYXRoLlBJKSB7XG4gICAgc3RhcnQgPSB7XG4gICAgICB4OiBtaW5YLFxuICAgICAgeTogbWluWVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogbWF4WCxcbiAgICAgIHk6IG1heFlcbiAgICB9O1xuICB9IGVsc2UgaWYgKDAuNSAqIE1hdGguUEkgPD0gYW5nbGUgJiYgYW5nbGUgPCBNYXRoLlBJKSB7XG4gICAgc3RhcnQgPSB7XG4gICAgICB4OiBtYXhYLFxuICAgICAgeTogbWluWVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1heFlcbiAgICB9O1xuICB9IGVsc2UgaWYgKE1hdGguUEkgPD0gYW5nbGUgJiYgYW5nbGUgPCAxLjUgKiBNYXRoLlBJKSB7XG4gICAgc3RhcnQgPSB7XG4gICAgICB4OiBtYXhYLFxuICAgICAgeTogbWF4WVxuICAgIH07XG4gICAgZW5kID0ge1xuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1pbllcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0ge1xuICAgICAgeDogbWluWCxcbiAgICAgIHk6IG1heFlcbiAgICB9O1xuICAgIGVuZCA9IHtcbiAgICAgIHg6IG1heFgsXG4gICAgICB5OiBtaW5ZXG4gICAgfTtcbiAgfVxuXG4gIHZhciB0YW5UaGV0YSA9IE1hdGgudGFuKGFuZ2xlKTtcbiAgdmFyIHRhblRoZXRhMiA9IHRhblRoZXRhICogdGFuVGhldGE7XG4gIHZhciB4ID0gKGVuZC54IC0gc3RhcnQueCArIHRhblRoZXRhICogKGVuZC55IC0gc3RhcnQueSkpIC8gKHRhblRoZXRhMiArIDEpICsgc3RhcnQueDtcbiAgdmFyIHkgPSB0YW5UaGV0YSAqIChlbmQueCAtIHN0YXJ0LnggKyB0YW5UaGV0YSAqIChlbmQueSAtIHN0YXJ0LnkpKSAvICh0YW5UaGV0YTIgKyAxKSArIHN0YXJ0Lnk7XG4gIHZhciBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlTGluZWFyR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSwgeCwgeSk7XG5cbiAgX2FkZFN0b3Aoc3RlcHMsIGdyYWRpZW50KTtcblxuICByZXR1cm4gZ3JhZGllbnQ7XG59IC8vIHRoZSBzdHJpbmcgZm9ybWF0OiAncigwLjUsIDAuNSwgMC4xKSAwOiNmZmZmZmYgMTojMTg5MGZmJ1xuXG5cbmZ1bmN0aW9uIF9wYXJzZVJhZGlhbEdyYWRpZW50KGNvbG9yLCBzaGFwZSwgY29udGV4dCkge1xuICB2YXIgYXJyID0gY29sb3Iuc3BsaXQoJyAnKTtcbiAgdmFyIGNpcmNsZUNmZyA9IGFyclswXS5zbGljZSgyLCBhcnJbMF0ubGVuZ3RoIC0gMSk7XG4gIGNpcmNsZUNmZyA9IGNpcmNsZUNmZy5zcGxpdCgnLCcpO1xuICB2YXIgZnggPSBwYXJzZUZsb2F0KGNpcmNsZUNmZ1swXSk7XG4gIHZhciBmeSA9IHBhcnNlRmxvYXQoY2lyY2xlQ2ZnWzFdKTtcbiAgdmFyIGZyID0gcGFyc2VGbG9hdChjaXJjbGVDZmdbMl0pO1xuICB2YXIgc3RlcHMgPSBhcnIuc2xpY2UoMSk7IC8vIGlmIHJhZGl1cyBpcyAwLCBubyBncmFkaWVudCwgc3Ryb2tlIHdpdGggdGhlIGxhc3QgY29sb3JcblxuICBpZiAoZnIgPT09IDApIHtcbiAgICB2YXIgX2NvbG9yID0gc3RlcHNbc3RlcHMubGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIF9jb2xvci5zcGxpdCgnOicpWzFdO1xuICB9XG5cbiAgdmFyIF9zaGFwZSRnZXRCQm94MiA9IHNoYXBlLmdldEJCb3goKSxcbiAgICAgIHdpZHRoID0gX3NoYXBlJGdldEJCb3gyLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3NoYXBlJGdldEJCb3gyLmhlaWdodCxcbiAgICAgIG1pblggPSBfc2hhcGUkZ2V0QkJveDIubWluWCxcbiAgICAgIG1pblkgPSBfc2hhcGUkZ2V0QkJveDIubWluWTtcblxuICB2YXIgciA9IE1hdGguc3FydCh3aWR0aCAqIHdpZHRoICsgaGVpZ2h0ICogaGVpZ2h0KSAvIDI7XG4gIHZhciBncmFkaWVudCA9IGNvbnRleHQuY3JlYXRlUmFkaWFsR3JhZGllbnQobWluWCArIHdpZHRoICogZngsIG1pblkgKyBoZWlnaHQgKiBmeSwgZnIgKiByLCBtaW5YICsgd2lkdGggLyAyLCBtaW5ZICsgaGVpZ2h0IC8gMiwgcik7XG5cbiAgX2FkZFN0b3Aoc3RlcHMsIGdyYWRpZW50KTtcblxuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBwYXJzZVN0eWxlOiBmdW5jdGlvbiBwYXJzZVN0eWxlKGNvbG9yLCBzaGFwZSwgY29udGV4dCkge1xuICAgIGlmIChjb2xvclsxXSA9PT0gJygnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZmlyc3RDb2RlID0gY29sb3JbMF07XG5cbiAgICAgICAgaWYgKGZpcnN0Q29kZSA9PT0gJ2wnKSB7XG4gICAgICAgICAgcmV0dXJuIF9wYXJzZUxpbmVHcmFkaWVudChjb2xvciwgc2hhcGUsIGNvbnRleHQpO1xuICAgICAgICB9IGVsc2UgaWYgKGZpcnN0Q29kZSA9PT0gJ3InKSB7XG4gICAgICAgICAgcmV0dXJuIF9wYXJzZVJhZGlhbEdyYWRpZW50KGNvbG9yLCBzaGFwZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV2KSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ2Vycm9yIGluIHBhcnNpbmcgZ3JhZGllbnQgc3RyaW5nLCBwbGVhc2UgY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBleHRyYSB3aGl0ZXNwYWNlcy4nKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihldik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBSZWN0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVjdCwgX1NoYXBlKTtcblxuICBmdW5jdGlvbiBSZWN0KCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlY3QucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBfaW5pdFByb3BlcnRpZXMoKSB7XG4gICAgX1NoYXBlLnByb3RvdHlwZS5faW5pdFByb3BlcnRpZXMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2F0dHJzLmNhbkZpbGwgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLmNhblN0cm9rZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMudHlwZSA9ICdyZWN0JztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdEF0dHJzID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgcmFkaXVzOiAwLFxuICAgICAgbGluZVdpZHRoOiAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICB3aWR0aCA9IGF0dHJzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBhdHRycy5oZWlnaHQ7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICB2YXIgcmFkaXVzID0gYXR0cnMucmFkaXVzO1xuXG4gICAgaWYgKCFyYWRpdXMgfHwgISh3aWR0aCAqIGhlaWdodCkpIHtcbiAgICAgIGNvbnRleHQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmFkaXVzID0gVXRpbC5wYXJzZVBhZGRpbmcocmFkaXVzKTtcbiAgICAgIGNvbnRleHQubW92ZVRvKHggKyByYWRpdXNbMF0sIHkpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzWzFdLCB5KTtcbiAgICAgIGNvbnRleHQuYXJjKHggKyB3aWR0aCAtIHJhZGl1c1sxXSwgeSArIHJhZGl1c1sxXSwgcmFkaXVzWzFdLCAtTWF0aC5QSSAvIDIsIDAsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJhZGl1c1syXSk7XG4gICAgICBjb250ZXh0LmFyYyh4ICsgd2lkdGggLSByYWRpdXNbMl0sIHkgKyBoZWlnaHQgLSByYWRpdXNbMl0sIHJhZGl1c1syXSwgMCwgTWF0aC5QSSAvIDIsIGZhbHNlKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHggKyByYWRpdXNbM10sIHkgKyBoZWlnaHQpO1xuICAgICAgY29udGV4dC5hcmMoeCArIHJhZGl1c1szXSwgeSArIGhlaWdodCAtIHJhZGl1c1szXSwgcmFkaXVzWzNdLCBNYXRoLlBJIC8gMiwgTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgY29udGV4dC5saW5lVG8oeCwgeSArIHJhZGl1c1swXSk7XG4gICAgICBjb250ZXh0LmFyYyh4ICsgcmFkaXVzWzBdLCB5ICsgcmFkaXVzWzBdLCByYWRpdXNbMF0sIE1hdGguUEksIE1hdGguUEkgKiAzIC8gMiwgZmFsc2UpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICB3aWR0aCA9IGF0dHJzLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBhdHRycy5oZWlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHgsXG4gICAgICBtaW5ZOiB5LFxuICAgICAgbWF4WDogeCArIHdpZHRoLFxuICAgICAgbWF4WTogeSArIGhlaWdodFxuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIFJlY3Q7XG59KFNoYXBlKTtcblxuU2hhcGUuUmVjdCA9IFJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IFJlY3Q7XG5cbi8qKiovIH0pLFxuLyogODIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBDaXJjbGUgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9TaGFwZSkge1xuICBfaW5oZXJpdHNMb29zZShDaXJjbGUsIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gQ2lyY2xlKCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IENpcmNsZS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICBfU2hhcGUucHJvdG90eXBlLl9pbml0UHJvcGVydGllcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fYXR0cnMuY2FuRmlsbCA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMuY2FuU3Ryb2tlID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy50eXBlID0gJ2NpcmNsZSc7XG4gIH07XG5cbiAgX3Byb3RvLmdldERlZmF1bHRBdHRycyA9IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByOiAwLFxuICAgICAgbGluZVdpZHRoOiAwXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0KCdhdHRycycpO1xuICAgIHZhciB4ID0gYXR0cnMueCxcbiAgICAgICAgeSA9IGF0dHJzLnksXG4gICAgICAgIHIgPSBhdHRycy5yO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoeCwgeSwgciwgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICB9O1xuXG4gIF9wcm90by5jYWxjdWxhdGVCb3ggPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHggPSBhdHRycy54LFxuICAgICAgICB5ID0gYXR0cnMueSxcbiAgICAgICAgciA9IGF0dHJzLnI7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IHggLSByLFxuICAgICAgbWF4WDogeCArIHIsXG4gICAgICBtaW5ZOiB5IC0gcixcbiAgICAgIG1heFk6IHkgKyByXG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gQ2lyY2xlO1xufShTaGFwZSk7XG5cblNoYXBlLkNpcmNsZSA9IENpcmNsZTtcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG4vKioqLyB9KSxcbi8qIDgzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgYmJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgTGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1NoYXBlKSB7XG4gIF9pbmhlcml0c0xvb3NlKExpbmUsIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gTGluZSgpIHtcbiAgICByZXR1cm4gX1NoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX2luaXRQcm9wZXJ0aWVzKCkge1xuICAgIF9TaGFwZS5wcm90b3R5cGUuX2luaXRQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9hdHRycy5jYW5TdHJva2UgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLnR5cGUgPSAnbGluZSc7XG4gIH07XG5cbiAgX3Byb3RvLmdldERlZmF1bHRBdHRycyA9IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDE6IDAsXG4gICAgICB5MTogMCxcbiAgICAgIHgyOiAwLFxuICAgICAgeTI6IDAsXG4gICAgICBsaW5lV2lkdGg6IDFcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHgxID0gYXR0cnMueDEsXG4gICAgICAgIHkxID0gYXR0cnMueTEsXG4gICAgICAgIHgyID0gYXR0cnMueDIsXG4gICAgICAgIHkyID0gYXR0cnMueTI7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyh4MSwgeTEpO1xuICAgIGNvbnRleHQubGluZVRvKHgyLCB5Mik7XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgeDEgPSBhdHRycy54MSxcbiAgICAgICAgeTEgPSBhdHRycy55MSxcbiAgICAgICAgeDIgPSBhdHRycy54MixcbiAgICAgICAgeTIgPSBhdHRycy55MixcbiAgICAgICAgbGluZVdpZHRoID0gYXR0cnMubGluZVdpZHRoO1xuICAgIHJldHVybiBiYm94LmdldEJCb3hGcm9tTGluZSh4MSwgeTEsIHgyLCB5MiwgbGluZVdpZHRoKTtcbiAgfTtcblxuICByZXR1cm4gTGluZTtcbn0oU2hhcGUpO1xuXG5TaGFwZS5MaW5lID0gTGluZTtcbm1vZHVsZS5leHBvcnRzID0gTGluZTtcblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGJib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIFBvbHlnb24gPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9TaGFwZSkge1xuICBfaW5oZXJpdHNMb29zZShQb2x5Z29uLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb24oKSB7XG4gICAgcmV0dXJuIF9TaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9seWdvbi5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICBfU2hhcGUucHJvdG90eXBlLl9pbml0UHJvcGVydGllcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fYXR0cnMuY2FuRmlsbCA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMuY2FuU3Ryb2tlID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy50eXBlID0gJ3BvbHlnb24nO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWZhdWx0QXR0cnMgPSBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogbnVsbCxcbiAgICAgIGxpbmVXaWR0aDogMFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmNyZWF0ZVBhdGggPSBmdW5jdGlvbiBjcmVhdGVQYXRoKGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHBvaW50cyA9IGF0dHJzLnBvaW50cztcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIHBvaW50ID0gcG9pbnRzW2ldO1xuXG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBjb250ZXh0Lm1vdmVUbyhwb2ludC54LCBwb2ludC55KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzO1xuICAgIHJldHVybiBiYm94LmdldEJCb3hGcm9tUG9pbnRzKHBvaW50cyk7XG4gIH07XG5cbiAgcmV0dXJuIFBvbHlnb247XG59KFNoYXBlKTtcblxuU2hhcGUuUG9seWdvbiA9IFBvbHlnb247XG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBTbW9vdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcblxudmFyIGJib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTsgLy8gZmlsdGVyIHRoZSBwb2ludCB3aGljaCB4IG9yIHkgaXMgTmFOXG5cblxuZnVuY3Rpb24gX2ZpbHRlclBvaW50cyhwb2ludHMpIHtcbiAgdmFyIGZpbHRlcmVkUG9pbnRzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgIGlmICghaXNOYU4ocG9pbnQueCkgJiYgIWlzTmFOKHBvaW50LnkpKSB7XG4gICAgICBmaWx0ZXJlZFBvaW50cy5wdXNoKHBvaW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmlsdGVyZWRQb2ludHM7XG59XG5cbnZhciBQb2x5bGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1NoYXBlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvbHlsaW5lLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIFBvbHlsaW5lKCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvbHlsaW5lLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX2luaXRQcm9wZXJ0aWVzKCkge1xuICAgIF9TaGFwZS5wcm90b3R5cGUuX2luaXRQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9hdHRycy5jYW5GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy5jYW5TdHJva2UgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLnR5cGUgPSAncG9seWxpbmUnO1xuICB9O1xuXG4gIF9wcm90by5nZXREZWZhdWx0QXR0cnMgPSBmdW5jdGlvbiBnZXREZWZhdWx0QXR0cnMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50czogbnVsbCxcbiAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgIHNtb290aDogZmFsc2VcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdHRycyA9IHNlbGYuZ2V0KCdhdHRycycpO1xuICAgIHZhciBwb2ludHMgPSBhdHRycy5wb2ludHMsXG4gICAgICAgIHNtb290aCA9IGF0dHJzLnNtb290aDtcblxuICAgIHZhciBmaWx0ZXJlZFBvaW50cyA9IF9maWx0ZXJQb2ludHMocG9pbnRzKTtcblxuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoZmlsdGVyZWRQb2ludHMubGVuZ3RoKSB7XG4gICAgICBjb250ZXh0Lm1vdmVUbyhmaWx0ZXJlZFBvaW50c1swXS54LCBmaWx0ZXJlZFBvaW50c1swXS55KTtcblxuICAgICAgaWYgKHNtb290aCkge1xuICAgICAgICB2YXIgY29uc3RhaW50ID0gW1swLCAwXSwgWzEsIDFdXTtcbiAgICAgICAgdmFyIHNwcyA9IFNtb290aC5zbW9vdGgoZmlsdGVyZWRQb2ludHMsIGZhbHNlLCBjb25zdGFpbnQpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gc3BzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIHZhciBzcCA9IHNwc1tpXTtcbiAgICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oc3BbMV0sIHNwWzJdLCBzcFszXSwgc3BbNF0sIHNwWzVdLCBzcFs2XSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfaTtcblxuICAgICAgICB2YXIgbDtcblxuICAgICAgICBmb3IgKF9pID0gMSwgbCA9IGZpbHRlcmVkUG9pbnRzLmxlbmd0aCAtIDE7IF9pIDwgbDsgX2krKykge1xuICAgICAgICAgIGNvbnRleHQubGluZVRvKGZpbHRlcmVkUG9pbnRzW19pXS54LCBmaWx0ZXJlZFBvaW50c1tfaV0ueSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0LmxpbmVUbyhmaWx0ZXJlZFBvaW50c1tsXS54LCBmaWx0ZXJlZFBvaW50c1tsXS55KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgcG9pbnRzID0gYXR0cnMucG9pbnRzLFxuICAgICAgICBzbW9vdGggPSBhdHRycy5zbW9vdGgsXG4gICAgICAgIGxpbmVXaWR0aCA9IGF0dHJzLmxpbmVXaWR0aDtcblxuICAgIHZhciBmaWx0ZXJlZFBvaW50cyA9IF9maWx0ZXJQb2ludHMocG9pbnRzKTtcblxuICAgIGlmIChzbW9vdGgpIHtcbiAgICAgIHZhciBuZXdQb2ludHMgPSBbXTtcbiAgICAgIHZhciBjb25zdGFpbnQgPSBbWzAsIDBdLCBbMSwgMV1dO1xuICAgICAgdmFyIHNwcyA9IFNtb290aC5zbW9vdGgoZmlsdGVyZWRQb2ludHMsIGZhbHNlLCBjb25zdGFpbnQpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbiA9IHNwcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgdmFyIHNwID0gc3BzW2ldO1xuXG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgbmV3UG9pbnRzLnB1c2goW2ZpbHRlcmVkUG9pbnRzWzBdLngsIGZpbHRlcmVkUG9pbnRzWzBdLnksIHNwWzFdLCBzcFsyXSwgc3BbM10sIHNwWzRdLCBzcFs1XSwgc3BbNl1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgbGFzdFBvaW50ID0gc3BzW2kgLSAxXTtcbiAgICAgICAgICBuZXdQb2ludHMucHVzaChbbGFzdFBvaW50WzVdLCBsYXN0UG9pbnRbNl0sIHNwWzFdLCBzcFsyXSwgc3BbM10sIHNwWzRdLCBzcFs1XSwgc3BbNl1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmJveC5nZXRCQm94RnJvbUJlemllckdyb3VwKG5ld1BvaW50cywgbGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmJveC5nZXRCQm94RnJvbVBvaW50cyhmaWx0ZXJlZFBvaW50cywgbGluZVdpZHRoKTtcbiAgfTtcblxuICByZXR1cm4gUG9seWxpbmU7XG59KFNoYXBlKTtcblxuU2hhcGUuUG9seWxpbmUgPSBQb2x5bGluZTtcbm1vZHVsZS5leHBvcnRzID0gUG9seWxpbmU7XG5cbi8qKiovIH0pLFxuLyogODYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbnZhciBiYm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG5cbnZhciBBcmMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9TaGFwZSkge1xuICBfaW5oZXJpdHNMb29zZShBcmMsIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gQXJjKCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFyYy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICBfU2hhcGUucHJvdG90eXBlLl9pbml0UHJvcGVydGllcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fYXR0cnMuY2FuU3Ryb2tlID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy5jYW5GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy50eXBlID0gJ2FyYyc7XG4gIH07XG5cbiAgX3Byb3RvLmdldERlZmF1bHRBdHRycyA9IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICByOiAwLFxuICAgICAgc3RhcnRBbmdsZTogMCxcbiAgICAgIGVuZEFuZ2xlOiBNYXRoLlBJICogMixcbiAgICAgIGNsb2Nrd2lzZTogZmFsc2UsXG4gICAgICBsaW5lV2lkdGg6IDFcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHggPSBhdHRycy54LFxuICAgICAgICB5ID0gYXR0cnMueSxcbiAgICAgICAgciA9IGF0dHJzLnIsXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlLFxuICAgICAgICBjbG9ja3dpc2UgPSBhdHRycy5jbG9ja3dpc2U7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChzdGFydEFuZ2xlICE9PSBlbmRBbmdsZSkge1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jYWxjdWxhdGVCb3ggPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHggPSBhdHRycy54LFxuICAgICAgICB5ID0gYXR0cnMueSxcbiAgICAgICAgciA9IGF0dHJzLnIsXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlLFxuICAgICAgICBjbG9ja3dpc2UgPSBhdHRycy5jbG9ja3dpc2U7XG4gICAgcmV0dXJuIGJib3guZ2V0QkJveEZyb21BcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gIH07XG5cbiAgcmV0dXJuIEFyYztcbn0oU2hhcGUpO1xuXG5TaGFwZS5BcmMgPSBBcmM7XG5tb2R1bGUuZXhwb3J0cyA9IEFyYztcblxuLyoqKi8gfSksXG4vKiA4NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIGJib3ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKTtcblxudmFyIFNlY3RvciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX1NoYXBlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFNlY3RvciwgX1NoYXBlKTtcblxuICBmdW5jdGlvbiBTZWN0b3IoKSB7XG4gICAgcmV0dXJuIF9TaGFwZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gU2VjdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gX2luaXRQcm9wZXJ0aWVzKCkge1xuICAgIF9TaGFwZS5wcm90b3R5cGUuX2luaXRQcm9wZXJ0aWVzLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLl9hdHRycy5jYW5GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy5jYW5TdHJva2UgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLnR5cGUgPSAnc2VjdG9yJztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdEF0dHJzID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGxpbmVXaWR0aDogMCxcbiAgICAgIHI6IDAsXG4gICAgICByMDogMCxcbiAgICAgIHN0YXJ0QW5nbGU6IDAsXG4gICAgICBlbmRBbmdsZTogTWF0aC5QSSAqIDIsXG4gICAgICBjbG9ja3dpc2U6IGZhbHNlXG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uY3JlYXRlUGF0aCA9IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY29udGV4dCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0KCdhdHRycycpO1xuICAgIHZhciB4ID0gYXR0cnMueCxcbiAgICAgICAgeSA9IGF0dHJzLnksXG4gICAgICAgIHN0YXJ0QW5nbGUgPSBhdHRycy5zdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSA9IGF0dHJzLmVuZEFuZ2xlLFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgcjAgPSBhdHRycy5yMCxcbiAgICAgICAgY2xvY2t3aXNlID0gYXR0cnMuY2xvY2t3aXNlO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdmFyIHVuaXRYID0gTWF0aC5jb3Moc3RhcnRBbmdsZSk7XG4gICAgdmFyIHVuaXRZID0gTWF0aC5zaW4oc3RhcnRBbmdsZSk7XG4gICAgY29udGV4dC5tb3ZlVG8odW5pdFggKiByMCArIHgsIHVuaXRZICogcjAgKyB5KTtcbiAgICBjb250ZXh0LmxpbmVUbyh1bml0WCAqIHIgKyB4LCB1bml0WSAqIHIgKyB5KTsgLy8g5b2T5omH5b2i55qE6KeS5bqm6Z2e5bi45bCP55qE5pe25YCZ77yM5bCx5LiN6L+b6KGM5byn57q/55qE57uY5Yi277yb5oiW6ICF5pW05Liq5Y+q5pyJMeS4quaJh+W9ouaXtu+8jOS8muWHuueOsGVuZDww55qE5oOF5Ya15LiN57uY5Yi2XG5cbiAgICBpZiAoTWF0aC5hYnMoZW5kQW5nbGUgLSBzdGFydEFuZ2xlKSA+IDAuMDAwMSB8fCBzdGFydEFuZ2xlID09PSAwICYmIGVuZEFuZ2xlIDwgMCkge1xuICAgICAgY29udGV4dC5hcmMoeCwgeSwgciwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhNYXRoLmNvcyhlbmRBbmdsZSkgKiByMCArIHgsIE1hdGguc2luKGVuZEFuZ2xlKSAqIHIwICsgeSk7XG5cbiAgICAgIGlmIChyMCAhPT0gMCkge1xuICAgICAgICBjb250ZXh0LmFyYyh4LCB5LCByMCwgZW5kQW5nbGUsIHN0YXJ0QW5nbGUsICFjbG9ja3dpc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNhbGN1bGF0ZUJveCA9IGZ1bmN0aW9uIGNhbGN1bGF0ZUJveCgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLmdldCgnYXR0cnMnKTtcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICByID0gYXR0cnMucixcbiAgICAgICAgcjAgPSBhdHRycy5yMCxcbiAgICAgICAgc3RhcnRBbmdsZSA9IGF0dHJzLnN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlID0gYXR0cnMuZW5kQW5nbGUsXG4gICAgICAgIGNsb2Nrd2lzZSA9IGF0dHJzLmNsb2Nrd2lzZTtcbiAgICB2YXIgb3V0ZXJCQm94ID0gYmJveC5nZXRCQm94RnJvbUFyYyh4LCB5LCByLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgY2xvY2t3aXNlKTtcbiAgICB2YXIgaW5uZXJCQm94ID0gYmJveC5nZXRCQm94RnJvbUFyYyh4LCB5LCByMCwgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGNsb2Nrd2lzZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pblg6IE1hdGgubWluKG91dGVyQkJveC5taW5YLCBpbm5lckJCb3gubWluWCksXG4gICAgICBtaW5ZOiBNYXRoLm1pbihvdXRlckJCb3gubWluWSwgaW5uZXJCQm94Lm1pblkpLFxuICAgICAgbWF4WDogTWF0aC5tYXgob3V0ZXJCQm94Lm1heFgsIGlubmVyQkJveC5tYXhYKSxcbiAgICAgIG1heFk6IE1hdGgubWF4KG91dGVyQkJveC5tYXhZLCBpbm5lckJCb3gubWF4WSlcbiAgICB9O1xuICB9O1xuXG4gIHJldHVybiBTZWN0b3I7XG59KFNoYXBlKTtcblxuU2hhcGUuU2VjdG9yID0gU2VjdG9yO1xubW9kdWxlLmV4cG9ydHMgPSBTZWN0b3I7XG5cbi8qKiovIH0pLFxuLyogODggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxudmFyIHRleHRXaWR0aENhY2hlQ291bnRlciA9IDA7XG52YXIgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbnZhciBURVhUX0NBQ0hFX01BWCA9IDUwMDA7XG5cbnZhciBUZXh0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoVGV4dCwgX1NoYXBlKTtcblxuICBmdW5jdGlvbiBUZXh0KCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBfaW5pdFByb3BlcnRpZXMoKSB7XG4gICAgX1NoYXBlLnByb3RvdHlwZS5faW5pdFByb3BlcnRpZXMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2F0dHJzLmNhbkZpbGwgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLmNhblN0cm9rZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMudHlwZSA9ICd0ZXh0JztcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdEF0dHJzID0gZnVuY3Rpb24gZ2V0RGVmYXVsdEF0dHJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsaW5lV2lkdGg6IDAsXG4gICAgICBsaW5lQ291bnQ6IDEsXG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmb250RmFtaWx5OiAnc2Fucy1zZXJpZicsXG4gICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgICBmb250VmFyaWFudDogJ25vcm1hbCcsXG4gICAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgICB0ZXh0QmFzZWxpbmU6ICdib3R0b20nLFxuICAgICAgbGluZUhlaWdodDogbnVsbCxcbiAgICAgIHRleHRBcnI6IG51bGxcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5fZ2V0Rm9udFN0eWxlID0gZnVuY3Rpb24gX2dldEZvbnRTdHlsZSgpIHtcbiAgICB2YXIgYXR0cnMgPSB0aGlzLl9hdHRycy5hdHRycztcbiAgICB2YXIgZm9udFNpemUgPSBhdHRycy5mb250U2l6ZSxcbiAgICAgICAgZm9udEZhbWlseSA9IGF0dHJzLmZvbnRGYW1pbHksXG4gICAgICAgIGZvbnRXZWlnaHQgPSBhdHRycy5mb250V2VpZ2h0LFxuICAgICAgICBmb250U3R5bGUgPSBhdHRycy5mb250U3R5bGUsXG4gICAgICAgIGZvbnRWYXJpYW50ID0gYXR0cnMuZm9udFZhcmlhbnQ7XG4gICAgcmV0dXJuIGZvbnRTdHlsZSArIFwiIFwiICsgZm9udFZhcmlhbnQgKyBcIiBcIiArIGZvbnRXZWlnaHQgKyBcIiBcIiArIGZvbnRTaXplICsgXCJweCBcIiArIGZvbnRGYW1pbHk7XG4gIH07XG5cbiAgX3Byb3RvLl9hZnRlckF0dHJzU2V0ID0gZnVuY3Rpb24gX2FmdGVyQXR0cnNTZXQoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG4gICAgYXR0cnMuZm9udCA9IHRoaXMuX2dldEZvbnRTdHlsZSgpO1xuXG4gICAgaWYgKGF0dHJzLnRleHQpIHtcbiAgICAgIHZhciB0ZXh0ID0gYXR0cnMudGV4dDtcbiAgICAgIHZhciB0ZXh0QXJyID0gbnVsbDtcbiAgICAgIHZhciBsaW5lQ291bnQgPSAxO1xuXG4gICAgICBpZiAoVXRpbC5pc1N0cmluZyh0ZXh0KSAmJiB0ZXh0LmluZGV4T2YoJ1xcbicpICE9PSAtMSkge1xuICAgICAgICB0ZXh0QXJyID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgICAgIGxpbmVDb3VudCA9IHRleHRBcnIubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICBhdHRycy5saW5lQ291bnQgPSBsaW5lQ291bnQ7XG4gICAgICBhdHRycy50ZXh0QXJyID0gdGV4dEFycjtcbiAgICB9XG5cbiAgICB0aGlzLnNldCgnYXR0cnMnLCBhdHRycyk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRUZXh0SGVpZ2h0ID0gZnVuY3Rpb24gX2dldFRleHRIZWlnaHQoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG5cbiAgICBpZiAoYXR0cnMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm4gYXR0cnMuaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBsaW5lQ291bnQgPSBhdHRycy5saW5lQ291bnQ7XG4gICAgdmFyIGZvbnRTaXplID0gYXR0cnMuZm9udFNpemUgKiAxO1xuXG4gICAgaWYgKGxpbmVDb3VudCA+IDEpIHtcbiAgICAgIHZhciBzcGFjZWluZ1kgPSB0aGlzLl9nZXRTcGFjZWluZ1koKTtcblxuICAgICAgcmV0dXJuIGZvbnRTaXplICogbGluZUNvdW50ICsgc3BhY2VpbmdZICogKGxpbmVDb3VudCAtIDEpO1xuICAgIH1cblxuICAgIHJldHVybiBmb250U2l6ZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFNwYWNlaW5nWSA9IGZ1bmN0aW9uIF9nZXRTcGFjZWluZ1koKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG4gICAgdmFyIGxpbmVIZWlnaHQgPSBhdHRycy5saW5lSGVpZ2h0O1xuICAgIHZhciBmb250U2l6ZSA9IGF0dHJzLmZvbnRTaXplICogMTtcbiAgICByZXR1cm4gbGluZUhlaWdodCA/IGxpbmVIZWlnaHQgLSBmb250U2l6ZSA6IGZvbnRTaXplICogMC4xNDtcbiAgfTtcblxuICBfcHJvdG8uZHJhd0lubmVyID0gZnVuY3Rpb24gZHJhd0lubmVyKGNvbnRleHQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGF0dHJzID0gc2VsZi5fYXR0cnMuYXR0cnM7XG4gICAgdmFyIHRleHQgPSBhdHRycy50ZXh0O1xuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG5cbiAgICBpZiAoVXRpbC5pc05pbCh0ZXh0KSB8fCBpc05hTih4KSB8fCBpc05hTih5KSkge1xuICAgICAgLy8gdGV4dCB3aWxsIGJlIDBcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdGV4dEFyciA9IGF0dHJzLnRleHRBcnI7XG4gICAgdmFyIGZvbnRTaXplID0gYXR0cnMuZm9udFNpemUgKiAxO1xuXG4gICAgdmFyIHNwYWNlaW5nWSA9IHNlbGYuX2dldFNwYWNlaW5nWSgpO1xuXG4gICAgaWYgKGF0dHJzLnJvdGF0ZSkge1xuICAgICAgLy8gZG8gcm90YXRpb25cbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY29udGV4dC5yb3RhdGUoYXR0cnMucm90YXRlKTtcbiAgICAgIHggPSAwO1xuICAgICAgeSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHRleHRCYXNlbGluZSA9IGF0dHJzLnRleHRCYXNlbGluZTtcbiAgICB2YXIgaGVpZ2h0O1xuXG4gICAgaWYgKHRleHRBcnIpIHtcbiAgICAgIGhlaWdodCA9IHNlbGYuX2dldFRleHRIZWlnaHQoKTtcbiAgICB9XG5cbiAgICB2YXIgc3ViWTsgLy8gY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgIGlmIChzZWxmLmhhc0ZpbGwoKSkge1xuICAgICAgdmFyIGZpbGxPcGFjaXR5ID0gYXR0cnMuZmlsbE9wYWNpdHk7XG5cbiAgICAgIGlmICghVXRpbC5pc05pbChmaWxsT3BhY2l0eSkgJiYgZmlsbE9wYWNpdHkgIT09IDEpIHtcbiAgICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IGZpbGxPcGFjaXR5O1xuICAgICAgfVxuXG4gICAgICBpZiAodGV4dEFycikge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGV4dEFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgIHZhciBzdWJUZXh0ID0gdGV4dEFycltpXTtcbiAgICAgICAgICBzdWJZID0geSArIGkgKiAoc3BhY2VpbmdZICsgZm9udFNpemUpIC0gaGVpZ2h0ICsgZm9udFNpemU7IC8vIGJvdHRvbTtcblxuICAgICAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBzdWJZICs9IGhlaWdodCAtIGZvbnRTaXplIC0gKGhlaWdodCAtIGZvbnRTaXplKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHN1YlkgKz0gaGVpZ2h0IC0gZm9udFNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5maWxsVGV4dChzdWJUZXh0LCB4LCBzdWJZKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5maWxsVGV4dCh0ZXh0LCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZi5oYXNTdHJva2UoKSkge1xuICAgICAgaWYgKHRleHRBcnIpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbGVuID0gdGV4dEFyci5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgICAgIHZhciBfc3ViVGV4dCA9IHRleHRBcnJbX2ldO1xuICAgICAgICAgIHN1YlkgPSB5ICsgX2kgKiAoc3BhY2VpbmdZICsgZm9udFNpemUpIC0gaGVpZ2h0ICsgZm9udFNpemU7IC8vIGJvdHRvbTtcblxuICAgICAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgICAgICBzdWJZICs9IGhlaWdodCAtIGZvbnRTaXplIC0gKGhlaWdodCAtIGZvbnRTaXplKSAvIDI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRleHRCYXNlbGluZSA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgIHN1YlkgKz0gaGVpZ2h0IC0gZm9udFNpemU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KF9zdWJUZXh0LCB4LCBzdWJZKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHRleHQsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2FsY3VsYXRlQm94ID0gZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgYXR0cnMgPSBzZWxmLl9hdHRycy5hdHRycztcbiAgICB2YXIgeCA9IGF0dHJzLngsXG4gICAgICAgIHkgPSBhdHRycy55LFxuICAgICAgICB0ZXh0QWxpZ24gPSBhdHRycy50ZXh0QWxpZ24sXG4gICAgICAgIHRleHRCYXNlbGluZSA9IGF0dHJzLnRleHRCYXNlbGluZTtcblxuICAgIHZhciB3aWR0aCA9IHNlbGYuX2dldFRleHRXaWR0aCgpOyAvLyBhdHRycy53aWR0aFxuXG5cbiAgICBpZiAoIXdpZHRoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiB4LFxuICAgICAgICBtaW5ZOiB5LFxuICAgICAgICBtYXhYOiB4LFxuICAgICAgICBtYXhZOiB5XG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciBoZWlnaHQgPSBzZWxmLl9nZXRUZXh0SGVpZ2h0KCk7IC8vIGF0dHJzLmhlaWdodFxuXG5cbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeSAtIGhlaWdodFxuICAgIH07IC8vIGRlZmF1bHQgdGV4dEFsaWduOiBzdGFydCwgdGV4dEJhc2VsaW5lOiBib3R0b21cblxuICAgIGlmICh0ZXh0QWxpZ24pIHtcbiAgICAgIGlmICh0ZXh0QWxpZ24gPT09ICdlbmQnIHx8IHRleHRBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICBwb2ludC54IC09IHdpZHRoO1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHBvaW50LnggLT0gd2lkdGggLyAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGlmICh0ZXh0QmFzZWxpbmUgPT09ICd0b3AnKSB7XG4gICAgICAgIHBvaW50LnkgKz0gaGVpZ2h0O1xuICAgICAgfSBlbHNlIGlmICh0ZXh0QmFzZWxpbmUgPT09ICdtaWRkbGUnKSB7XG4gICAgICAgIHBvaW50LnkgKz0gaGVpZ2h0IC8gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogcG9pbnQueCxcbiAgICAgIG1pblk6IHBvaW50LnksXG4gICAgICBtYXhYOiBwb2ludC54ICsgd2lkdGgsXG4gICAgICBtYXhZOiBwb2ludC55ICsgaGVpZ2h0XG4gICAgfTtcbiAgfTtcblxuICBfcHJvdG8uX2dldFRleHRXaWR0aCA9IGZ1bmN0aW9uIF9nZXRUZXh0V2lkdGgoKSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5fYXR0cnMuYXR0cnM7XG5cbiAgICBpZiAoYXR0cnMud2lkdGgpIHtcbiAgICAgIHJldHVybiBhdHRycy53aWR0aDtcbiAgICB9XG5cbiAgICB2YXIgdGV4dCA9IGF0dHJzLnRleHQ7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldCgnY29udGV4dCcpO1xuICAgIGlmIChVdGlsLmlzTmlsKHRleHQpKSByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHZhciBmb250ID0gYXR0cnMuZm9udDtcbiAgICB2YXIgdGV4dEFyciA9IGF0dHJzLnRleHRBcnI7XG4gICAgdmFyIGtleSA9IHRleHQgKyAnJyArIGZvbnQ7XG5cbiAgICBpZiAodGV4dFdpZHRoQ2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIHRleHRXaWR0aENhY2hlW2tleV07XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gMDtcblxuICAgIGlmICh0ZXh0QXJyKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gdGV4dEFyci5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViVGV4dCA9IHRleHRBcnJbaV07XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIFV0aWwubWVhc3VyZVRleHQoc3ViVGV4dCwgZm9udCwgY29udGV4dCkud2lkdGgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IFV0aWwubWVhc3VyZVRleHQodGV4dCwgZm9udCwgY29udGV4dCkud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKHRleHRXaWR0aENhY2hlQ291bnRlciA+IFRFWFRfQ0FDSEVfTUFYKSB7XG4gICAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIgPSAwO1xuICAgICAgdGV4dFdpZHRoQ2FjaGUgPSB7fTtcbiAgICB9XG5cbiAgICB0ZXh0V2lkdGhDYWNoZUNvdW50ZXIrKztcbiAgICB0ZXh0V2lkdGhDYWNoZVtrZXldID0gd2lkdGg7XG4gICAgcmV0dXJuIHdpZHRoO1xuICB9O1xuXG4gIHJldHVybiBUZXh0O1xufShTaGFwZSk7XG5cblNoYXBlLlRleHQgPSBUZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBUZXh0O1xuXG4vKioqLyB9KSxcbi8qIDg5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG52YXIgQ3VzdG9tID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfU2hhcGUpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ3VzdG9tLCBfU2hhcGUpO1xuXG4gIGZ1bmN0aW9uIEN1c3RvbSgpIHtcbiAgICByZXR1cm4gX1NoYXBlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDdXN0b20ucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBfaW5pdFByb3BlcnRpZXMoKSB7XG4gICAgX1NoYXBlLnByb3RvdHlwZS5faW5pdFByb3BlcnRpZXMuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuX2F0dHJzLmNhbkZpbGwgPSB0cnVlO1xuICAgIHRoaXMuX2F0dHJzLmNhblN0cm9rZSA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMuY3JlYXRlUGF0aCA9IG51bGw7XG4gICAgdGhpcy5fYXR0cnMudHlwZSA9ICdjdXN0b20nO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIGNyZWF0ZVBhdGggPSB0aGlzLmdldCgnY3JlYXRlUGF0aCcpO1xuICAgIGNyZWF0ZVBhdGggJiYgY3JlYXRlUGF0aC5jYWxsKHRoaXMsIGNvbnRleHQpO1xuICB9O1xuXG4gIF9wcm90by5jYWxjdWxhdGVCb3ggPSBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgdmFyIGNhbGN1bGF0ZUJveCA9IHRoaXMuZ2V0KCdjYWxjdWxhdGVCb3gnKTtcbiAgICByZXR1cm4gY2FsY3VsYXRlQm94ICYmIGNhbGN1bGF0ZUJveC5jYWxsKHRoaXMpO1xuICB9O1xuXG4gIHJldHVybiBDdXN0b207XG59KFNoYXBlKTtcblxuU2hhcGUuQ3VzdG9tID0gQ3VzdG9tO1xubW9kdWxlLmV4cG9ydHMgPSBDdXN0b207XG5cbi8qKiovIH0pLFxuLyogOTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBQYXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Mik7XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygzNyk7XG5cbnZhciBMaW5lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfUGF0aCkge1xuICBfaW5oZXJpdHNMb29zZShMaW5lLCBfUGF0aCk7XG5cbiAgZnVuY3Rpb24gTGluZSgpIHtcbiAgICByZXR1cm4gX1BhdGguYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX1BhdGgucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ2xpbmUnO1xuICAgIGNmZy5zb3J0YWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICByZXR1cm4gTGluZTtcbn0oUGF0aCk7XG5cbkdlb20uTGluZSA9IExpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7IGlmIChzZWxmID09PSB2b2lkIDApIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgR2VvbSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNpemVNaXhpbiA9IF9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkyKTtcblxudmFyIEludGVydmFsID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbSkge1xuICBfaW5oZXJpdHNMb29zZShJbnRlcnZhbCwgX0dlb20pO1xuXG4gIHZhciBfcHJvdG8gPSBJbnRlcnZhbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnaW50ZXJ2YWwnO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAnaW50ZXJ2YWwnO1xuICAgIGNmZy5nZW5lcmF0ZVBvaW50cyA9IHRydWU7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBmdW5jdGlvbiBJbnRlcnZhbChjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9HZW9tLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIFV0aWwubWl4KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBTaXplTWl4aW4pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9wcm90by5jcmVhdGVTaGFwZVBvaW50c0NmZyA9IGZ1bmN0aW9uIGNyZWF0ZVNoYXBlUG9pbnRzQ2ZnKG9iaikge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgY2ZnLnNpemUgPSB0aGlzLmdldE5vcm1hbGl6ZWRTaXplKG9iaik7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJJbm5lciA9IGZ1bmN0aW9uIGNsZWFySW5uZXIoKSB7XG4gICAgX0dlb20ucHJvdG90eXBlLmNsZWFySW5uZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc2V0KCdkZWZhdWx0U2l6ZScsIG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBJbnRlcnZhbDtcbn0oR2VvbSk7XG5cbkdlb20uSW50ZXJ2YWwgPSBJbnRlcnZhbDtcbm1vZHVsZS5leHBvcnRzID0gSW50ZXJ2YWw7XG5cbi8qKiovIH0pLFxuLyogOTIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgVmVjdG9yMiA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5mdW5jdGlvbiBnZXRSZWN0UG9pbnRzKGNmZykge1xuICB2YXIgeCA9IGNmZy54LFxuICAgICAgeSA9IGNmZy55LFxuICAgICAgeTAgPSBjZmcueTAsXG4gICAgICBzaXplID0gY2ZnLnNpemU7XG4gIHZhciB5bWluID0geTA7XG4gIHZhciB5bWF4ID0geTtcblxuICBpZiAoVXRpbC5pc0FycmF5KHkpKSB7XG4gICAgeW1heCA9IHlbMV07XG4gICAgeW1pbiA9IHlbMF07XG4gIH1cblxuICB2YXIgeG1pbjtcbiAgdmFyIHhtYXg7XG5cbiAgaWYgKFV0aWwuaXNBcnJheSh4KSkge1xuICAgIHhtaW4gPSB4WzBdO1xuICAgIHhtYXggPSB4WzFdO1xuICB9IGVsc2Uge1xuICAgIHhtaW4gPSB4IC0gc2l6ZSAvIDI7XG4gICAgeG1heCA9IHggKyBzaXplIC8gMjtcbiAgfVxuXG4gIHJldHVybiBbe1xuICAgIHg6IHhtaW4sXG4gICAgeTogeW1pblxuICB9LCB7XG4gICAgeDogeG1pbixcbiAgICB5OiB5bWF4XG4gIH0sIHtcbiAgICB4OiB4bWF4LFxuICAgIHk6IHltYXhcbiAgfSwge1xuICAgIHg6IHhtYXgsXG4gICAgeTogeW1pblxuICB9XTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVjdFJhbmdlKHBvaW50cykge1xuICB2YXIgeFZhbHVlcyA9IFtdO1xuICB2YXIgeVZhbHVlcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG4gICAgeFZhbHVlcy5wdXNoKHBvaW50LngpO1xuICAgIHlWYWx1ZXMucHVzaChwb2ludC55KTtcbiAgfVxuXG4gIHZhciB4TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeFZhbHVlcyk7XG4gIHZhciB5TWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgeVZhbHVlcyk7XG4gIHZhciB4TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeFZhbHVlcyk7XG4gIHZhciB5TWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgeVZhbHVlcyk7XG4gIHJldHVybiB7XG4gICAgeDogeE1pbixcbiAgICB5OiB5TWluLFxuICAgIHdpZHRoOiB4TWF4IC0geE1pbixcbiAgICBoZWlnaHQ6IHlNYXggLSB5TWluXG4gIH07XG59XG5cbnZhciBJbnRlcnZhbCA9IFNoYXBlLnJlZ2lzdGVyRmFjdG9yeSgnaW50ZXJ2YWwnLCB7XG4gIGRlZmF1bHRTaGFwZVR5cGU6ICdyZWN0JyxcbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cyhjZmcpIHtcbiAgICByZXR1cm4gZ2V0UmVjdFBvaW50cyhjZmcpO1xuICB9XG59KTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ2ludGVydmFsJywgJ3JlY3QnLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wYXJzZVBvaW50cyhjZmcucG9pbnRzKTtcbiAgICB2YXIgc3R5bGUgPSBVdGlsLm1peCh7XG4gICAgICBmaWxsOiBjZmcuY29sb3JcbiAgICB9LCBHbG9iYWwuc2hhcGUuaW50ZXJ2YWwsIGNmZy5zdHlsZSk7XG5cbiAgICBpZiAoY2ZnLmlzSW5DaXJjbGUpIHtcbiAgICAgIHZhciBuZXdQb2ludHMgPSBwb2ludHMuc2xpY2UoMCk7XG5cbiAgICAgIGlmICh0aGlzLl9jb29yZC50cmFuc3Bvc2VkKSB7XG4gICAgICAgIG5ld1BvaW50cyA9IFtwb2ludHNbMF0sIHBvaW50c1szXSwgcG9pbnRzWzJdLCBwb2ludHNbMV1dO1xuICAgICAgfVxuXG4gICAgICB2YXIgX2NmZyRjZW50ZXIgPSBjZmcuY2VudGVyLFxuICAgICAgICAgIHggPSBfY2ZnJGNlbnRlci54LFxuICAgICAgICAgIHkgPSBfY2ZnJGNlbnRlci55O1xuICAgICAgdmFyIHYgPSBbMSwgMF07XG4gICAgICB2YXIgdjAgPSBbbmV3UG9pbnRzWzBdLnggLSB4LCBuZXdQb2ludHNbMF0ueSAtIHldO1xuICAgICAgdmFyIHYxID0gW25ld1BvaW50c1sxXS54IC0geCwgbmV3UG9pbnRzWzFdLnkgLSB5XTtcbiAgICAgIHZhciB2MiA9IFtuZXdQb2ludHNbMl0ueCAtIHgsIG5ld1BvaW50c1syXS55IC0geV07XG4gICAgICB2YXIgc3RhcnRBbmdsZSA9IFZlY3RvcjIuYW5nbGVUbyh2LCB2MSk7XG4gICAgICB2YXIgZW5kQW5nbGUgPSBWZWN0b3IyLmFuZ2xlVG8odiwgdjIpO1xuICAgICAgdmFyIHIwID0gVmVjdG9yMi5sZW5ndGgodjApO1xuICAgICAgdmFyIHIgPSBWZWN0b3IyLmxlbmd0aCh2MSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID49IDEuNSAqIE1hdGguUEkpIHtcbiAgICAgICAgc3RhcnRBbmdsZSA9IHN0YXJ0QW5nbGUgLSAyICogTWF0aC5QSTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZEFuZ2xlID49IDEuNSAqIE1hdGguUEkpIHtcbiAgICAgICAgZW5kQW5nbGUgPSBlbmRBbmdsZSAtIDIgKiBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGFpbmVyLmFkZFNoYXBlKCdTZWN0b3InLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2ludGVydmFsJyxcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHksXG4gICAgICAgICAgcjogcixcbiAgICAgICAgICByMDogcjAsXG4gICAgICAgICAgc3RhcnRBbmdsZTogc3RhcnRBbmdsZSxcbiAgICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICAgICAgfSwgc3R5bGUpXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgcmVjdENmZyA9IGdldFJlY3RSYW5nZShwb2ludHMpO1xuICAgIHJldHVybiBjb250YWluZXIuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBjbGFzc05hbWU6ICdpbnRlcnZhbCcsXG4gICAgICBhdHRyczogVXRpbC5taXgocmVjdENmZywgc3R5bGUpXG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBJbnRlcnZhbDtcblxuLyoqKi8gfSksXG4vKiA5MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgU3RhY2s6IF9fd2VicGFja19yZXF1aXJlX18oOTQpLFxuICBEb2RnZTogX193ZWJwYWNrX3JlcXVpcmVfXyg5Nilcbn07XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFN0YWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG5cbi8qKiovIH0pLFxuLyogOTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7XG4gIHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzO1xuICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xufVxuXG52YXIgaXNBcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG52YXIgaXNOaWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuXG52YXIgQWRqdXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMyk7XG5cbnZhciBTdGFjayA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0FkanVzdCkge1xuICBfaW5oZXJpdHNMb29zZShTdGFjaywgX0FkanVzdCk7XG5cbiAgZnVuY3Rpb24gU3RhY2soKSB7XG4gICAgcmV0dXJuIF9BZGp1c3QuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFN0YWNrLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIHRoaXMueEZpZWxkID0gbnVsbDsgLy8g6LCD5pW05a+55bqU55qEIHgg5pa55ZCR5a+55bqU55qE5a2X5q615ZCN56ewXG5cbiAgICB0aGlzLnlGaWVsZCA9IG51bGw7IC8vIOiwg+aVtOWvueW6lOeahCB5IOaWueWQkeWvueW6lOeahOWtl+auteWQjeensFxuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzQWRqdXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0FkanVzdChkYXRhQXJyYXkpIHtcbiAgICB0aGlzLnByb2Nlc3NTdGFjayhkYXRhQXJyYXkpO1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzU3RhY2sgPSBmdW5jdGlvbiBwcm9jZXNzU3RhY2soZGF0YUFycmF5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB4RmllbGQgPSBzZWxmLnhGaWVsZDtcbiAgICB2YXIgeUZpZWxkID0gc2VsZi55RmllbGQ7XG4gICAgdmFyIGNvdW50ID0gZGF0YUFycmF5Lmxlbmd0aDtcbiAgICB2YXIgc3RhY2tDYWNoZSA9IHtcbiAgICAgIHBvc2l0aXZlOiB7fSxcbiAgICAgIG5lZ2F0aXZlOiB7fVxuICAgIH07IC8vIOWxguWPoOmhuuW6j+e/u+i9rFxuXG4gICAgaWYgKHNlbGYucmV2ZXJzZU9yZGVyKSB7XG4gICAgICBkYXRhQXJyYXkgPSBkYXRhQXJyYXkuc2xpY2UoMCkucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgdmFyIGRhdGEgPSBkYXRhQXJyYXlbaV07XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgIHZhciBpdGVtID0gZGF0YVtqXTtcbiAgICAgICAgdmFyIHggPSBpdGVtW3hGaWVsZF0gfHwgMDtcbiAgICAgICAgdmFyIHkgPSBpdGVtW3lGaWVsZF07XG4gICAgICAgIHZhciB4a2V5ID0geC50b1N0cmluZygpO1xuICAgICAgICB5ID0gaXNBcnJheSh5KSA/IHlbMV0gOiB5O1xuXG4gICAgICAgIGlmICghaXNOaWwoeSkpIHtcbiAgICAgICAgICB2YXIgZGlyZWN0aW9uID0geSA+PSAwID8gJ3Bvc2l0aXZlJyA6ICduZWdhdGl2ZSc7XG5cbiAgICAgICAgICBpZiAoIXN0YWNrQ2FjaGVbZGlyZWN0aW9uXVt4a2V5XSkge1xuICAgICAgICAgICAgc3RhY2tDYWNoZVtkaXJlY3Rpb25dW3hrZXldID0gMDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpdGVtW3lGaWVsZF0gPSBbc3RhY2tDYWNoZVtkaXJlY3Rpb25dW3hrZXldLCB5ICsgc3RhY2tDYWNoZVtkaXJlY3Rpb25dW3hrZXldXTtcbiAgICAgICAgICBzdGFja0NhY2hlW2RpcmVjdGlvbl1beGtleV0gKz0geTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3RhY2s7XG59KEFkanVzdCk7XG5cbkFkanVzdC5TdGFjayA9IFN0YWNrO1xubW9kdWxlLmV4cG9ydHMgPSBTdGFjaztcblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRG9kZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDk3KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb2RnZTtcblxuLyoqKi8gfSksXG4vKiA5NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBBZGp1c3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxudmFyIGVhY2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuXG52YXIgTUFSR0lOX1JBVElPID0gMSAvIDI7XG52YXIgRE9ER0VfUkFUSU8gPSAxIC8gMjtcblxudmFyIERvZGdlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQWRqdXN0KSB7XG4gIF9pbmhlcml0c0xvb3NlKERvZGdlLCBfQWRqdXN0KTtcblxuICBmdW5jdGlvbiBEb2RnZSgpIHtcbiAgICByZXR1cm4gX0FkanVzdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gRG9kZ2UucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgLyoqXG4gICAgICog6LCD5pW06L+H56iL5LitLDLkuKrmlbDmja7nmoTpl7Tot51cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubWFyZ2luUmF0aW8gPSBNQVJHSU5fUkFUSU87XG4gICAgLyoqXG4gICAgICog6LCD5pW05Y2g5Y2V5L2N5a695bqm55qE5q+U5L6LLOS+i+Wmgu+8muWNoDLkuKrliIbnsbvpl7Tot53nmoQgMS8yXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMuZG9kZ2VSYXRpbyA9IERPREdFX1JBVElPO1xuICAgIHRoaXMuYWRqdXN0TmFtZXMgPSBbJ3gnLCAneSddOyAvLyDosIPmlbTnmoTnu7TluqbvvIzpu5jorqQseCx56YO95YGa6LCD5pW0XG4gIH07XG5cbiAgX3Byb3RvLmdldERvZGdlT2Zmc2V0ID0gZnVuY3Rpb24gZ2V0RG9kZ2VPZmZzZXQocmFuZ2UsIGluZGV4LCBjb3VudCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcHJlID0gcmFuZ2UucHJlO1xuICAgIHZhciBuZXh0ID0gcmFuZ2UubmV4dDtcbiAgICB2YXIgdGlja0xlbmd0aCA9IG5leHQgLSBwcmU7XG4gICAgdmFyIHdpZHRoID0gdGlja0xlbmd0aCAqIHNlbGYuZG9kZ2VSYXRpbyAvIGNvdW50O1xuICAgIHZhciBtYXJnaW4gPSBzZWxmLm1hcmdpblJhdGlvICogd2lkdGg7XG4gICAgdmFyIG9mZnNldCA9IDEgLyAyICogKHRpY2tMZW5ndGggLSBjb3VudCAqIHdpZHRoIC0gKGNvdW50IC0gMSkgKiBtYXJnaW4pICsgKChpbmRleCArIDEpICogd2lkdGggKyBpbmRleCAqIG1hcmdpbikgLSAxIC8gMiAqIHdpZHRoIC0gMSAvIDIgKiB0aWNrTGVuZ3RoO1xuICAgIHJldHVybiAocHJlICsgbmV4dCkgLyAyICsgb2Zmc2V0O1xuICB9O1xuXG4gIF9wcm90by5wcm9jZXNzQWRqdXN0ID0gZnVuY3Rpb24gcHJvY2Vzc0FkanVzdChkYXRhQXJyYXkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNvdW50ID0gZGF0YUFycmF5Lmxlbmd0aDtcbiAgICB2YXIgeEZpZWxkID0gc2VsZi54RmllbGQ7XG4gICAgZWFjaChkYXRhQXJyYXksIGZ1bmN0aW9uIChkYXRhLCBpbmRleCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIG9iaiA9IGRhdGFbaV07XG4gICAgICAgIHZhciB2YWx1ZSA9IG9ialt4RmllbGRdO1xuICAgICAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICAgICAgcHJlOiBsZW4gPT09IDEgPyB2YWx1ZSAtIDEgOiB2YWx1ZSAtIDAuNSxcbiAgICAgICAgICBuZXh0OiBsZW4gPT09IDEgPyB2YWx1ZSArIDEgOiB2YWx1ZSArIDAuNVxuICAgICAgICB9O1xuICAgICAgICB2YXIgZG9kZ2VWYWx1ZSA9IHNlbGYuZ2V0RG9kZ2VPZmZzZXQocmFuZ2UsIGluZGV4LCBjb3VudCk7XG4gICAgICAgIG9ialt4RmllbGRdID0gZG9kZ2VWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gRG9kZ2U7XG59KEFkanVzdCk7XG5cbkFkanVzdC5Eb2RnZSA9IERvZGdlO1xubW9kdWxlLmV4cG9ydHMgPSBEb2RnZTtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIEJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxudmFyIFZlY3RvcjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG52YXIgTWF0cml4ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XG5cbnZhciBQb2xhciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0Jhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoUG9sYXIsIF9CYXNlKTtcblxuICBmdW5jdGlvbiBQb2xhcigpIHtcbiAgICByZXR1cm4gX0Jhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvbGFyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIHRoaXMudHlwZSA9ICdwb2xhcic7XG4gICAgdGhpcy5zdGFydEFuZ2xlID0gLU1hdGguUEkgLyAyO1xuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMyAvIDI7XG4gICAgdGhpcy5pbm5lciA9IDA7XG4gICAgdGhpcy5pbm5lclJhZGl1cyA9IDA7IC8vIGFsaWFzXG5cbiAgICB0aGlzLmlzUG9sYXIgPSB0cnVlO1xuICAgIHRoaXMudHJhbnNwb3NlZCA9IGZhbHNlO1xuICAgIHRoaXMuY2VudGVyID0gbnVsbDtcbiAgICB0aGlzLnJhZGl1cyA9IG51bGw7IC8vIHJlbGF0aXZlLCAwIH4gMVxuICB9O1xuXG4gIF9wcm90by5pbml0ID0gZnVuY3Rpb24gaW5pdChzdGFydCwgZW5kKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBpbm5lciA9IHNlbGYuaW5uZXIgfHwgc2VsZi5pbm5lclJhZGl1cztcbiAgICB2YXIgd2lkdGggPSBNYXRoLmFicyhlbmQueCAtIHN0YXJ0LngpO1xuICAgIHZhciBoZWlnaHQgPSBNYXRoLmFicyhlbmQueSAtIHN0YXJ0LnkpO1xuICAgIHZhciBtYXhSYWRpdXM7XG4gICAgdmFyIGNlbnRlcjtcblxuICAgIGlmIChzZWxmLnN0YXJ0QW5nbGUgPT09IC1NYXRoLlBJICYmIHNlbGYuZW5kQW5nbGUgPT09IDApIHtcbiAgICAgIG1heFJhZGl1cyA9IE1hdGgubWluKHdpZHRoIC8gMiwgaGVpZ2h0KTtcbiAgICAgIGNlbnRlciA9IHtcbiAgICAgICAgeDogKHN0YXJ0LnggKyBlbmQueCkgLyAyLFxuICAgICAgICB5OiBzdGFydC55XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBtYXhSYWRpdXMgPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAvIDI7XG4gICAgICBjZW50ZXIgPSB7XG4gICAgICAgIHg6IChzdGFydC54ICsgZW5kLngpIC8gMixcbiAgICAgICAgeTogKHN0YXJ0LnkgKyBlbmQueSkgLyAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciByYWRpdXMgPSBzZWxmLnJhZGl1cztcblxuICAgIGlmIChyYWRpdXMgPiAwICYmIHJhZGl1cyA8PSAxKSB7XG4gICAgICBtYXhSYWRpdXMgPSBtYXhSYWRpdXMgKiByYWRpdXM7XG4gICAgfVxuXG4gICAgdGhpcy54ID0ge1xuICAgICAgc3RhcnQ6IHNlbGYuc3RhcnRBbmdsZSxcbiAgICAgIGVuZDogc2VsZi5lbmRBbmdsZVxuICAgIH07XG4gICAgdGhpcy55ID0ge1xuICAgICAgc3RhcnQ6IG1heFJhZGl1cyAqIGlubmVyLFxuICAgICAgZW5kOiBtYXhSYWRpdXNcbiAgICB9O1xuICAgIHRoaXMuY2VudGVyID0gY2VudGVyO1xuICAgIHRoaXMuY2lyY2xlUmFkaXVzID0gbWF4UmFkaXVzOyAvLyB0aGUgcmFkaXVzIHZhbHVlIGluIHB4XG4gIH07XG5cbiAgX3Byb3RvLmNvbnZlcnRQb2ludCA9IGZ1bmN0aW9uIGNvbnZlcnRQb2ludChwb2ludCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2VudGVyID0gc2VsZi5jZW50ZXI7XG4gICAgdmFyIHRyYW5zcG9zZWQgPSBzZWxmLnRyYW5zcG9zZWQ7XG4gICAgdmFyIHhEaW0gPSB0cmFuc3Bvc2VkID8gJ3knIDogJ3gnO1xuICAgIHZhciB5RGltID0gdHJhbnNwb3NlZCA/ICd4JyA6ICd5JztcbiAgICB2YXIgeCA9IHNlbGYueDtcbiAgICB2YXIgeSA9IHNlbGYueTtcbiAgICB2YXIgYW5nbGUgPSB4LnN0YXJ0ICsgKHguZW5kIC0geC5zdGFydCkgKiBwb2ludFt4RGltXTtcbiAgICB2YXIgcmFkaXVzID0geS5zdGFydCArICh5LmVuZCAtIHkuc3RhcnQpICogcG9pbnRbeURpbV07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGNlbnRlci54ICsgTWF0aC5jb3MoYW5nbGUpICogcmFkaXVzLFxuICAgICAgeTogY2VudGVyLnkgKyBNYXRoLnNpbihhbmdsZSkgKiByYWRpdXNcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5pbnZlcnRQb2ludCA9IGZ1bmN0aW9uIGludmVydFBvaW50KHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjZW50ZXIgPSBzZWxmLmNlbnRlcixcbiAgICAgICAgdHJhbnNwb3NlZCA9IHNlbGYudHJhbnNwb3NlZCxcbiAgICAgICAgeCA9IHNlbGYueCxcbiAgICAgICAgeSA9IHNlbGYueTtcbiAgICB2YXIgeERpbSA9IHRyYW5zcG9zZWQgPyAneScgOiAneCc7XG4gICAgdmFyIHlEaW0gPSB0cmFuc3Bvc2VkID8gJ3gnIDogJ3knO1xuICAgIHZhciBtID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuICAgIE1hdHJpeC5yb3RhdGUobSwgbSwgeC5zdGFydCk7XG4gICAgdmFyIHN0YXJ0ViA9IFsxLCAwXTtcbiAgICBWZWN0b3IyLnRyYW5zZm9ybU1hdDJkKHN0YXJ0Viwgc3RhcnRWLCBtKTtcbiAgICBzdGFydFYgPSBbc3RhcnRWWzBdLCBzdGFydFZbMV1dO1xuICAgIHZhciBwb2ludFYgPSBbcG9pbnQueCAtIGNlbnRlci54LCBwb2ludC55IC0gY2VudGVyLnldO1xuXG4gICAgaWYgKFZlY3RvcjIuemVybyhwb2ludFYpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHZhciB0aGV0YSA9IFZlY3RvcjIuYW5nbGVUbyhzdGFydFYsIHBvaW50ViwgeC5lbmQgPCB4LnN0YXJ0KTtcblxuICAgIGlmIChNYXRoLmFicyh0aGV0YSAtIE1hdGguUEkgKiAyKSA8IDAuMDAxKSB7XG4gICAgICB0aGV0YSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGwgPSBWZWN0b3IyLmxlbmd0aChwb2ludFYpO1xuICAgIHZhciBwZXJjZW50WCA9IHRoZXRhIC8gKHguZW5kIC0geC5zdGFydCk7XG4gICAgcGVyY2VudFggPSB4LmVuZCAtIHguc3RhcnQgPiAwID8gcGVyY2VudFggOiAtcGVyY2VudFg7XG4gICAgdmFyIHBlcmNlbnRZID0gKGwgLSB5LnN0YXJ0KSAvICh5LmVuZCAtIHkuc3RhcnQpO1xuICAgIHZhciByc3QgPSB7fTtcbiAgICByc3RbeERpbV0gPSBwZXJjZW50WDtcbiAgICByc3RbeURpbV0gPSBwZXJjZW50WTtcbiAgICByZXR1cm4gcnN0O1xuICB9O1xuXG4gIHJldHVybiBQb2xhcjtcbn0oQmFzZSk7XG5cbkJhc2UuUG9sYXIgPSBQb2xhcjtcbm1vZHVsZS5leHBvcnRzID0gUG9sYXI7XG5cbi8qKiovIH0pLFxuLyogOTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBAZmlsZU92ZXJ2aWV3IOaPkOWPluWFrOWFseS7o+eggeWIsHV0aWzmlrnms5VcbiAqIEBhdXRob3IgZHhxNjEzQGdtYWlsLmNvbVxuICovXG52YXIgaXNTdHJpbmcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcblxudmFyIGlzRGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTE4KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHRvVGltZVN0YW1wOiBmdW5jdGlvbiB0b1RpbWVTdGFtcCh2YWx1ZSkge1xuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgIGlmICh2YWx1ZS5pbmRleE9mKCdUJykgPiAwKSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUpLmdldFRpbWUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmV3IERhdGUodmFsdWUucmVwbGFjZSgvLS9pZywgJy8nKSkuZ2V0VGltZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlLmdldFRpbWUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIG1hcmtlciBzaGFwZXPvvIx1c2VkIGZvciB0b29sdGlwIGFuZCBsZWdlbmRcbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxuICAgIFNoYXBlID0gX3JlcXVpcmUuU2hhcGU7XG5cbnZhciBTWU1CT0xTID0ge1xuICBjaXJjbGU6IGZ1bmN0aW9uIGNpcmNsZSh4LCB5LCByLCBjdHgpIHtcbiAgICBjdHguYXJjKHgsIHksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gIH0sXG4gIHNxdWFyZTogZnVuY3Rpb24gc3F1YXJlKHgsIHksIHIsIGN0eCkge1xuICAgIGN0eC5tb3ZlVG8oeCAtIHIsIHkgLSByKTtcbiAgICBjdHgubGluZVRvKHggKyByLCB5IC0gcik7XG4gICAgY3R4LmxpbmVUbyh4ICsgciwgeSArIHIpO1xuICAgIGN0eC5saW5lVG8oeCAtIHIsIHkgKyByKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG4gIH1cbn07XG5cbnZhciBNYXJrZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9TaGFwZSkge1xuICBfaW5oZXJpdHNMb29zZShNYXJrZXIsIF9TaGFwZSk7XG5cbiAgZnVuY3Rpb24gTWFya2VyKCkge1xuICAgIHJldHVybiBfU2hhcGUuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IE1hcmtlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9pbml0UHJvcGVydGllcygpIHtcbiAgICBfU2hhcGUucHJvdG90eXBlLl9pbml0UHJvcGVydGllcy5jYWxsKHRoaXMpO1xuXG4gICAgdGhpcy5fYXR0cnMuY2FuRmlsbCA9IHRydWU7XG4gICAgdGhpcy5fYXR0cnMuY2FuU3Ryb2tlID0gdHJ1ZTtcbiAgICB0aGlzLl9hdHRycy50eXBlID0gJ21hcmtlcic7XG4gIH07XG5cbiAgX3Byb3RvLmdldERlZmF1bHRBdHRycyA9IGZ1bmN0aW9uIGdldERlZmF1bHRBdHRycygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBsaW5lV2lkdGg6IDBcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVQYXRoID0gZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgdmFyIGF0dHJzID0gdGhpcy5nZXQoJ2F0dHJzJyk7XG4gICAgdmFyIHggPSBhdHRycy54LFxuICAgICAgICB5ID0gYXR0cnMueSxcbiAgICAgICAgcmFkaXVzID0gYXR0cnMucmFkaXVzO1xuICAgIHZhciBzeW1ib2wgPSBhdHRycy5zeW1ib2wgfHwgJ2NpcmNsZSc7XG4gICAgdmFyIG1ldGhvZDtcblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oc3ltYm9sKSkge1xuICAgICAgbWV0aG9kID0gc3ltYm9sO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXRob2QgPSBTWU1CT0xTW3N5bWJvbF07XG4gICAgfVxuXG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBtZXRob2QoeCwgeSwgcmFkaXVzLCBjb250ZXh0LCB0aGlzKTtcbiAgfTtcblxuICBfcHJvdG8uY2FsY3VsYXRlQm94ID0gZnVuY3Rpb24gY2FsY3VsYXRlQm94KCkge1xuICAgIHZhciBhdHRycyA9IHRoaXMuZ2V0KCdhdHRycycpO1xuICAgIHZhciB4ID0gYXR0cnMueCxcbiAgICAgICAgeSA9IGF0dHJzLnksXG4gICAgICAgIHJhZGl1cyA9IGF0dHJzLnJhZGl1cztcbiAgICByZXR1cm4ge1xuICAgICAgbWluWDogeCAtIHJhZGl1cyxcbiAgICAgIG1pblk6IHkgLSByYWRpdXMsXG4gICAgICBtYXhYOiB4ICsgcmFkaXVzLFxuICAgICAgbWF4WTogeSArIHJhZGl1c1xuICAgIH07XG4gIH07XG5cbiAgcmV0dXJuIE1hcmtlcjtcbn0oU2hhcGUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcmtlcjtcblxuLyoqKi8gfSksXG4vKiAxMDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpLFxuICAgIEdyb3VwID0gX3JlcXVpcmUuR3JvdXA7XG5cbnZhciBNYXJrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG5cbnZhciBNQVJLRVJfUkFESVVTID0gMztcblxudmFyIExpc3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gTGlzdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaG93VGl0bGU6IGZhbHNlLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRpdGxlIHN0cmluZ1xuICAgICAgICogQHR5cGUgez9TdHJpbmd9XG4gICAgICAgKi9cbiAgICAgIHRpdGxlOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIGl0ZW1zIGFycmF5XG4gICAgICAgKiBAdHlwZSB7P0FycmF5fVxuICAgICAgICovXG4gICAgICBpdGVtczogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBvZmZzZXQgYmV0d2VlbiB0aXRsZSBhbmQgaXRlbXNcbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIHRpdGxlR2FwOiAxMixcblxuICAgICAgLyoqXG4gICAgICAgKiBvZmZzZXQgYmV0d2VlbiBlYWNoIGl0ZW1cbiAgICAgICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAgICAgKi9cbiAgICAgIGl0ZW1HYXA6IDEwLFxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSBvZmZzZXQgYmV0d2VlbiBlYWNoIGl0ZW0gaW4gdmVydGljYWwgZGlyZWFjdGlvblxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgaXRlbU1hcmdpbkJvdHRvbTogMTIsXG5cbiAgICAgIC8qKlxuICAgICAgICogdGhlIGZvcm1hdHRlciBmb3IgaXRlbSB0ZXh0XG4gICAgICAgKiBAdHlwZSB7W3R5cGVdfVxuICAgICAgICovXG4gICAgICBpdGVtRm9ybWF0dGVyOiBudWxsLFxuICAgICAgaXRlbVdpZHRoOiBudWxsLFxuXG4gICAgICAvKipcbiAgICAgICAqIG9mZnNldCBiZXR3ZWVuIG1hcmtlciBhbmQgdGV4dFxuICAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICAqL1xuICAgICAgd29yZFNwYWNlOiA2LFxuICAgICAgeDogMCxcbiAgICAgIHk6IDAsXG4gICAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgam9pbiBzdHJpbmcgb2YgYG5hbWVgIGFuZCBgdmFsdWVgXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBqb2luU3RyaW5nOiAnOiAnXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBMaXN0KGNmZykge1xuICAgIFV0aWwuZGVlcE1peCh0aGlzLCB0aGlzLmdldERlZmF1bHRDZmcoKSwgY2ZnKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIHRoaXMuX3JlbmRlclRpdGxlKCk7XG5cbiAgICB0aGlzLl9yZW5kZXJJdGVtcygpO1xuICB9XG5cbiAgX3Byb3RvLl9pbml0ID0gZnVuY3Rpb24gX2luaXQoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IG5ldyBHcm91cCh7XG4gICAgICB6SW5kZXg6IHRoaXMuekluZGV4IHx8IDBcbiAgICB9KTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB2YXIgd3JhcHBlciA9IGNvbnRhaW5lci5hZGRHcm91cCgpO1xuICAgIHRoaXMud3JhcHBlciA9IHdyYXBwZXI7XG4gICAgdmFyIGl0ZW1zR3JvdXAgPSB3cmFwcGVyLmFkZEdyb3VwKHtcbiAgICAgIGNsYXNzTmFtZTogJ2l0ZW1zR3JvdXAnXG4gICAgfSk7XG4gICAgdGhpcy5pdGVtc0dyb3VwID0gaXRlbXNHcm91cDtcblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKGNvbnRhaW5lcik7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyVGl0bGUgPSBmdW5jdGlvbiBfcmVuZGVyVGl0bGUodGl0bGUpIHtcbiAgICB0aXRsZSA9IHRpdGxlIHx8IHRoaXMudGl0bGU7XG4gICAgdmFyIHRpdGxlU2hhcGUgPSB0aGlzLnRpdGxlU2hhcGU7XG4gICAgdmFyIHRpdGxlSGVpZ2h0ID0gMDtcblxuICAgIGlmICh0aGlzLnNob3dUaXRsZSAmJiB0aXRsZSkge1xuICAgICAgaWYgKHRpdGxlU2hhcGUgJiYgIXRpdGxlU2hhcGUuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgICB0aXRsZVNoYXBlLmF0dHIoJ3RleHQnLCB0aXRsZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlcixcbiAgICAgICAgICAgIHRpdGxlU3R5bGUgPSB0aGlzLnRpdGxlU3R5bGU7XG4gICAgICAgIHRpdGxlU2hhcGUgPSB3cmFwcGVyLmFkZFNoYXBlKCd0ZXh0Jywge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB0ZXh0OiB0aXRsZVxuICAgICAgICAgIH0sIHRpdGxlU3R5bGUpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnRpdGxlU2hhcGUgPSB0aXRsZVNoYXBlO1xuICAgICAgfVxuXG4gICAgICB0aXRsZUhlaWdodCA9IHRpdGxlU2hhcGUuZ2V0QkJveCgpLmhlaWdodCArIHRoaXMudGl0bGVHYXA7XG4gICAgfVxuXG4gICAgdGhpcy5fdGl0bGVIZWlnaHQgPSB0aXRsZUhlaWdodDtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckl0ZW1zID0gZnVuY3Rpb24gX3JlbmRlckl0ZW1zKGl0ZW1zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGl0ZW1zID0gaXRlbXMgfHwgc2VsZi5pdGVtcztcblxuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5yZXZlcnNlZCkge1xuICAgICAgaXRlbXMucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XG4gICAgICBzZWxmLl9hZGRJdGVtKGl0ZW0sIGluZGV4KTtcbiAgICB9KTtcblxuICAgIGlmIChpdGVtcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9hZGp1c3RJdGVtcygpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlckJhY2tncm91bmQoKTtcbiAgfTtcblxuICBfcHJvdG8uX3JlbmRlckJhY2tncm91bmQgPSBmdW5jdGlvbiBfcmVuZGVyQmFja2dyb3VuZCgpIHtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZDtcblxuICAgIGlmIChiYWNrZ3JvdW5kKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICB2YXIgd3JhcHBlciA9IHRoaXMud3JhcHBlcjtcblxuICAgICAgdmFyIF93cmFwcGVyJGdldEJCb3ggPSB3cmFwcGVyLmdldEJCb3goKSxcbiAgICAgICAgICBtaW5YID0gX3dyYXBwZXIkZ2V0QkJveC5taW5YLFxuICAgICAgICAgIG1pblkgPSBfd3JhcHBlciRnZXRCQm94Lm1pblksXG4gICAgICAgICAgd2lkdGggPSBfd3JhcHBlciRnZXRCQm94LndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IF93cmFwcGVyJGdldEJCb3guaGVpZ2h0O1xuXG4gICAgICB2YXIgcGFkZGluZyA9IGJhY2tncm91bmQucGFkZGluZyB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBwYWRkaW5nID0gVXRpbC5wYXJzZVBhZGRpbmcocGFkZGluZyk7XG4gICAgICB2YXIgYXR0cnMgPSBVdGlsLm1peCh7XG4gICAgICAgIHg6IG1pblggLSBwYWRkaW5nWzNdLFxuICAgICAgICB5OiBtaW5ZIC0gcGFkZGluZ1swXSxcbiAgICAgICAgd2lkdGg6IHdpZHRoICsgcGFkZGluZ1sxXSArIHBhZGRpbmdbM10sXG4gICAgICAgIGhlaWdodDogaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl1cbiAgICAgIH0sIGJhY2tncm91bmQpO1xuICAgICAgdmFyIGJhY2tTaGFwZSA9IHRoaXMuYmFja1NoYXBlO1xuXG4gICAgICBpZiAoYmFja1NoYXBlKSB7XG4gICAgICAgIGJhY2tTaGFwZS5hdHRyKGF0dHJzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhY2tTaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnUmVjdCcsIHtcbiAgICAgICAgICB6SW5kZXg6IC0xLFxuICAgICAgICAgIGF0dHJzOiBhdHRyc1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iYWNrU2hhcGUgPSBiYWNrU2hhcGU7XG4gICAgICBjb250YWluZXIuc29ydCgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2FkZEl0ZW0gPSBmdW5jdGlvbiBfYWRkSXRlbShpdGVtKSB7XG4gICAgdmFyIGl0ZW1zR3JvdXAgPSB0aGlzLml0ZW1zR3JvdXA7XG4gICAgdmFyIGl0ZW1Hcm91cCA9IGl0ZW1zR3JvdXAuYWRkR3JvdXAoe1xuICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgdmFsdWU6IGl0ZW0udmFsdWUsXG4gICAgICBkYXRhVmFsdWU6IGl0ZW0uZGF0YVZhbHVlLFxuICAgICAgY2hlY2tlZDogaXRlbS5jaGVja2VkXG4gICAgfSk7XG4gICAgdmFyIHVuQ2hlY2tTdHlsZSA9IHRoaXMudW5DaGVja1N0eWxlLFxuICAgICAgICB1bkNoZWNrQ29sb3IgPSB0aGlzLnVuQ2hlY2tDb2xvcixcbiAgICAgICAgbmFtZVN0eWxlID0gdGhpcy5uYW1lU3R5bGUsXG4gICAgICAgIHZhbHVlU3R5bGUgPSB0aGlzLnZhbHVlU3R5bGUsXG4gICAgICAgIHdvcmRTcGFjZSA9IHRoaXMud29yZFNwYWNlO1xuICAgIHZhciBtYXJrZXIgPSBpdGVtLm1hcmtlcixcbiAgICAgICAgdmFsdWUgPSBpdGVtLnZhbHVlO1xuICAgIHZhciBzdGFydFggPSAwO1xuXG4gICAgaWYgKHVuQ2hlY2tDb2xvcikge1xuICAgICAgdW5DaGVja1N0eWxlLmZpbGwgPSB1bkNoZWNrQ29sb3I7XG4gICAgfVxuXG4gICAgaWYgKG1hcmtlcikge1xuICAgICAgdmFyIHJhZGl1cyA9IG1hcmtlci5yYWRpdXMgfHwgTUFSS0VSX1JBRElVUztcbiAgICAgIHZhciBtYXJrZXJBdHRycyA9IFV0aWwubWl4KHtcbiAgICAgICAgeDogcmFkaXVzLFxuICAgICAgICB5OiB0aGlzLl90aXRsZUhlaWdodFxuICAgICAgfSwgbWFya2VyKTtcblxuICAgICAgaWYgKGl0ZW0uY2hlY2tlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgVXRpbC5taXgobWFya2VyQXR0cnMsIHVuQ2hlY2tTdHlsZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXJrZXJTaGFwZSA9IG5ldyBNYXJrZXIoe1xuICAgICAgICBjbGFzc05hbWU6ICdpdGVtLW1hcmtlcicsXG4gICAgICAgIGF0dHJzOiBtYXJrZXJBdHRyc1xuICAgICAgfSk7XG4gICAgICBpdGVtR3JvdXAuYWRkKG1hcmtlclNoYXBlKTtcbiAgICAgIHN0YXJ0WCArPSBtYXJrZXJTaGFwZS5nZXRCQm94KCkud2lkdGggKyB3b3JkU3BhY2U7XG4gICAgfVxuXG4gICAgdmFyIG5hbWVUZXh0O1xuICAgIHZhciBuYW1lID0gaXRlbS5uYW1lO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciBqb2luU3RyaW5nID0gdGhpcy5qb2luU3RyaW5nIHx8ICcnO1xuICAgICAgbmFtZSA9IHZhbHVlID8gbmFtZSArIGpvaW5TdHJpbmcgOiBuYW1lO1xuICAgICAgbmFtZVRleHQgPSBpdGVtR3JvdXAuYWRkU2hhcGUoJ3RleHQnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IHN0YXJ0WCxcbiAgICAgICAgICB5OiB0aGlzLl90aXRsZUhlaWdodCxcbiAgICAgICAgICB0ZXh0OiB0aGlzLl9mb3JtYXRJdGVtVmFsdWUobmFtZSlcbiAgICAgICAgfSwgbmFtZVN0eWxlLCBpdGVtLmNoZWNrZWQgPT09IGZhbHNlID8gdW5DaGVja1N0eWxlIDogbnVsbClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdmFyIHZhbHVlWCA9IHN0YXJ0WDtcblxuICAgICAgaWYgKG5hbWVUZXh0KSB7XG4gICAgICAgIHZhbHVlWCArPSBuYW1lVGV4dC5nZXRCQm94KCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1Hcm91cC5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndmFsdWUnLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IHZhbHVlWCxcbiAgICAgICAgICB5OiB0aGlzLl90aXRsZUhlaWdodCxcbiAgICAgICAgICB0ZXh0OiB2YWx1ZVxuICAgICAgICB9LCB2YWx1ZVN0eWxlLCBpdGVtLmNoZWNrZWQgPT09IGZhbHNlID8gdW5DaGVja1N0eWxlIDogbnVsbClcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBpdGVtR3JvdXA7XG4gIH07XG5cbiAgX3Byb3RvLl9mb3JtYXRJdGVtVmFsdWUgPSBmdW5jdGlvbiBfZm9ybWF0SXRlbVZhbHVlKHZhbHVlKSB7XG4gICAgdmFyIGZvcm1hdHRlciA9IHRoaXMuaXRlbUZvcm1hdHRlcjtcblxuICAgIGlmIChmb3JtYXR0ZXIpIHtcbiAgICAgIHZhbHVlID0gZm9ybWF0dGVyLmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICBfcHJvdG8uX2dldE1heEl0ZW1XaWR0aCA9IGZ1bmN0aW9uIF9nZXRNYXhJdGVtV2lkdGgoKSB7XG4gICAgdmFyIHdpZHRoO1xuICAgIHZhciBpdGVtV2lkdGggPSB0aGlzLml0ZW1XaWR0aDtcblxuICAgIGlmIChVdGlsLmlzTnVtYmVyKGl0ZW1XaWR0aCkgfHwgVXRpbC5pc05pbChpdGVtV2lkdGgpKSB7XG4gICAgICByZXR1cm4gaXRlbVdpZHRoO1xuICAgIH1cblxuICAgIGlmIChpdGVtV2lkdGggPT09ICdhdXRvJykge1xuICAgICAgdmFyIGl0ZW1zR3JvdXAgPSB0aGlzLml0ZW1zR3JvdXA7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBpdGVtc0dyb3VwLmdldCgnY2hpbGRyZW4nKTtcbiAgICAgIHZhciBjb3VudCA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgIHZhciBtYXhJdGVtV2lkdGggPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIF9jaGlsZHJlbiRpJGdldEJCb3ggPSBjaGlsZHJlbltpXS5nZXRCQm94KCksXG4gICAgICAgICAgICBfd2lkdGggPSBfY2hpbGRyZW4kaSRnZXRCQm94LndpZHRoO1xuXG4gICAgICAgIG1heEl0ZW1XaWR0aCA9IE1hdGgubWF4KG1heEl0ZW1XaWR0aCwgX3dpZHRoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExlbmd0aCA9IHRoaXMubWF4TGVuZ3RoO1xuICAgICAgdmFyIGl0ZW1HYXAgPSB0aGlzLml0ZW1HYXA7XG4gICAgICB2YXIgdHdvQXZnV2lkdGggPSAobWF4TGVuZ3RoIC0gaXRlbUdhcCkgLyAyO1xuICAgICAgdmFyIHRocmVlQXZnV2lkdGggPSAobWF4TGVuZ3RoIC0gaXRlbUdhcCAqIDIpIC8gMztcblxuICAgICAgaWYgKGNvdW50ID09PSAyKSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgobWF4SXRlbVdpZHRoLCB0d29BdmdXaWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyAxLiBtYXggPD0gM0F2ZywgM0F2Z1xuICAgICAgICAvLyAyLiAzQXZnIDwgbWF4ICYmIG1heCA8IDJhdmcsIDJhdmdcbiAgICAgICAgLy8gMy4gbWF4ID4gMmF2ZywgbWF4LCBvbmUgY29sdW1uXG4gICAgICAgIGlmIChtYXhJdGVtV2lkdGggPD0gdGhyZWVBdmdXaWR0aCkge1xuICAgICAgICAgIHdpZHRoID0gdGhyZWVBdmdXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmIChtYXhJdGVtV2lkdGggPD0gdHdvQXZnV2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IHR3b0F2Z1dpZHRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdpZHRoID0gbWF4SXRlbVdpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9hZGp1c3RIb3Jpem9udGFsID0gZnVuY3Rpb24gX2FkanVzdEhvcml6b250YWwoKSB7XG4gICAgdmFyIG1heExlbmd0aCA9IHRoaXMubWF4TGVuZ3RoLFxuICAgICAgICBpdGVtc0dyb3VwID0gdGhpcy5pdGVtc0dyb3VwO1xuICAgIHZhciBjaGlsZHJlbiA9IGl0ZW1zR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciBpdGVtR2FwID0gdGhpcy5pdGVtR2FwLFxuICAgICAgICBpdGVtTWFyZ2luQm90dG9tID0gdGhpcy5pdGVtTWFyZ2luQm90dG9tO1xuICAgIHZhciB0aXRsZUhlaWdodCA9IHRoaXMuX3RpdGxlSGVpZ2h0O1xuICAgIHZhciByb3cgPSAwO1xuICAgIHZhciByb3dXaWR0aCA9IDA7XG4gICAgdmFyIHdpZHRoO1xuICAgIHZhciBoZWlnaHQ7XG5cbiAgICB2YXIgaXRlbVdpZHRoID0gdGhpcy5fZ2V0TWF4SXRlbVdpZHRoKCk7XG5cbiAgICB2YXIgbGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgYm94ID0gY2hpbGQuZ2V0QkJveCgpO1xuICAgICAgdmFyIGNoaWxkSGVpZ2h0ID0gYm94LmhlaWdodDtcbiAgICAgIHZhciBjaGlsZFdpZHRoID0gYm94LndpZHRoO1xuICAgICAgd2lkdGggPSBpdGVtV2lkdGggfHwgY2hpbGRXaWR0aDtcbiAgICAgIGhlaWdodCA9IGNoaWxkSGVpZ2h0ICsgaXRlbU1hcmdpbkJvdHRvbTtcblxuICAgICAgaWYgKHdpZHRoIC0gKG1heExlbmd0aCAtIHJvd1dpZHRoKSA+IDAuMDAwMSkge1xuICAgICAgICByb3crKztcbiAgICAgICAgcm93V2lkdGggPSAwO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC5tb3ZlVG8ocm93V2lkdGgsIHJvdyAqIGhlaWdodCk7XG4gICAgICBsZWdlbmRIaXRCb3hlcy5wdXNoKHtcbiAgICAgICAgeDogcm93V2lkdGgsXG4gICAgICAgIHk6IHJvdyAqIGhlaWdodCArIHRpdGxlSGVpZ2h0IC0gY2hpbGRIZWlnaHQgLyAyLFxuICAgICAgICB3aWR0aDogY2hpbGRXaWR0aCAqIDEuMzc1LFxuICAgICAgICBoZWlnaHQ6IGNoaWxkSGVpZ2h0ICogMS4zNzVcbiAgICAgIH0pO1xuICAgICAgcm93V2lkdGggKz0gd2lkdGggKyBpdGVtR2FwO1xuICAgIH1cblxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBsZWdlbmRIaXRCb3hlcztcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLl9hZGp1c3RWZXJ0aWNhbCA9IGZ1bmN0aW9uIF9hZGp1c3RWZXJ0aWNhbCgpIHtcbiAgICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5tYXhMZW5ndGgsXG4gICAgICAgIGl0ZW1zR3JvdXAgPSB0aGlzLml0ZW1zR3JvdXA7XG4gICAgdmFyIGl0ZW1HYXAgPSB0aGlzLml0ZW1HYXAsXG4gICAgICAgIGl0ZW1NYXJnaW5Cb3R0b20gPSB0aGlzLml0ZW1NYXJnaW5Cb3R0b20sXG4gICAgICAgIGl0ZW1XaWR0aCA9IHRoaXMuaXRlbVdpZHRoO1xuICAgIHZhciB0aXRsZUhlaWdodCA9IHRoaXMuX3RpdGxlSGVpZ2h0O1xuICAgIHZhciBjaGlsZHJlbiA9IGl0ZW1zR3JvdXAuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciBjb2xIZWlnaHQgPSAwO1xuICAgIHZhciB3aWR0aDtcbiAgICB2YXIgaGVpZ2h0O1xuICAgIHZhciBtYXhJdGVtV2lkdGggPSAwO1xuICAgIHZhciB0b3RhbFdpZHRoID0gMDtcbiAgICB2YXIgbGVnZW5kSGl0Qm94ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICB2YXIgYmJveCA9IGNoaWxkLmdldEJCb3goKTtcbiAgICAgIHdpZHRoID0gYmJveC53aWR0aDtcbiAgICAgIGhlaWdodCA9IGJib3guaGVpZ2h0O1xuXG4gICAgICBpZiAoVXRpbC5pc051bWJlcihpdGVtV2lkdGgpKSB7XG4gICAgICAgIG1heEl0ZW1XaWR0aCA9IGl0ZW1XaWR0aCArIGl0ZW1HYXA7XG4gICAgICB9IGVsc2UgaWYgKHdpZHRoID4gbWF4SXRlbVdpZHRoKSB7XG4gICAgICAgIG1heEl0ZW1XaWR0aCA9IHdpZHRoICsgaXRlbUdhcDtcbiAgICAgIH1cblxuICAgICAgaWYgKG1heExlbmd0aCAtIGNvbEhlaWdodCA8IGhlaWdodCkge1xuICAgICAgICBjb2xIZWlnaHQgPSAwO1xuICAgICAgICB0b3RhbFdpZHRoICs9IG1heEl0ZW1XaWR0aDtcbiAgICAgICAgY2hpbGQubW92ZVRvKHRvdGFsV2lkdGgsIDApO1xuICAgICAgICBsZWdlbmRIaXRCb3hlcy5wdXNoKHtcbiAgICAgICAgICB4OiB0b3RhbFdpZHRoLFxuICAgICAgICAgIHk6IHRpdGxlSGVpZ2h0IC0gaGVpZ2h0IC8gMixcbiAgICAgICAgICB3aWR0aDogd2lkdGggKiAxLjM3NSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAqIDEuMzc1XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQubW92ZVRvKHRvdGFsV2lkdGgsIGNvbEhlaWdodCk7XG4gICAgICAgIGxlZ2VuZEhpdEJveGVzLnB1c2goe1xuICAgICAgICAgIHg6IHRvdGFsV2lkdGgsXG4gICAgICAgICAgeTogY29sSGVpZ2h0IC0gaGVpZ2h0IC8gMiArIHRpdGxlSGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCAqIDEuMzc1LFxuICAgICAgICAgIGhlaWdodDogaGVpZ2h0ICogMS4zNzVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbEhlaWdodCArPSBoZWlnaHQgKyBpdGVtTWFyZ2luQm90dG9tO1xuICAgIH1cblxuICAgIHRoaXMubGVnZW5kSGl0Qm94ZXMgPSBsZWdlbmRIaXRCb3hlcztcbiAgICByZXR1cm47XG4gIH07XG5cbiAgX3Byb3RvLl9hZGp1c3RJdGVtcyA9IGZ1bmN0aW9uIF9hZGp1c3RJdGVtcygpIHtcbiAgICB2YXIgbGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG5cbiAgICBpZiAobGF5b3V0ID09PSAnaG9yaXpvbnRhbCcpIHtcbiAgICAgIHRoaXMuX2FkanVzdEhvcml6b250YWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYWRqdXN0VmVydGljYWwoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm1vdmVUbyA9IGZ1bmN0aW9uIG1vdmVUbyh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBjb250YWluZXIgJiYgY29udGFpbmVyLm1vdmVUbyh4LCB5KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8uc2V0SXRlbXMgPSBmdW5jdGlvbiBzZXRJdGVtcyhpdGVtcykge1xuICAgIHRoaXMuY2xlYXJJdGVtcygpO1xuXG4gICAgdGhpcy5fcmVuZGVySXRlbXMoaXRlbXMpO1xuICB9O1xuXG4gIF9wcm90by5zZXRUaXRsZSA9IGZ1bmN0aW9uIHNldFRpdGxlKHRpdGxlKSB7XG4gICAgdGhpcy5fcmVuZGVyVGl0bGUodGl0bGUpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhckl0ZW1zID0gZnVuY3Rpb24gY2xlYXJJdGVtcygpIHtcbiAgICB2YXIgaXRlbXNHcm91cCA9IHRoaXMuaXRlbXNHcm91cDtcbiAgICBpdGVtc0dyb3VwLmNsZWFyKCk7XG4gIH07XG5cbiAgX3Byb3RvLmdldFdpZHRoID0gZnVuY3Rpb24gZ2V0V2lkdGgoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIHZhciBiYm94ID0gY29udGFpbmVyLmdldEJCb3goKTtcbiAgICByZXR1cm4gYmJveC53aWR0aDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gZ2V0SGVpZ2h0KCkge1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB2YXIgYmJveCA9IGNvbnRhaW5lci5nZXRCQm94KCk7XG4gICAgcmV0dXJuIGJib3guaGVpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29udGFpbmVyLnNob3coKTtcbiAgfTtcblxuICBfcHJvdG8uaGlkZSA9IGZ1bmN0aW9uIGhpZGUoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnRhaW5lci5oaWRlKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIGNvbnRhaW5lci5jbGVhcigpO1xuICAgIGNvbnRhaW5lci5yZW1vdmUodHJ1ZSk7XG4gIH07XG5cbiAgcmV0dXJuIExpc3Q7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdDtcblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBbmltYXRlIGNvbmZpZ3VyYXRpb24gYW5kIHJlZ2lzdGVyXG4gKiBAYXV0aG9yIHNpbWEuemhhbmcxOTkwQGdtYWlsLmNvbVxuICovXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBkZWZhdWx0QW5pbWF0aW9uQ2ZnID0ge1xuICBhcHBlYXI6IHtcbiAgICBkdXJhdGlvbjogNDUwLFxuICAgIGVhc2luZzogJ3F1YWRyYXRpY091dCdcbiAgfSxcbiAgLy8gJ2FwcGVhcicgYW5pbWF0aW9uIG9wdGlvbnNcbiAgdXBkYXRlOiB7XG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnXG4gIH0sXG4gIC8vICd1cGRhdGUnIGFuaW1hdGlvbiBvcHRpb25zXG4gIGVudGVyOiB7XG4gICAgZHVyYXRpb246IDMwMCxcbiAgICBlYXNpbmc6ICdxdWFkcmF0aWNPdXQnXG4gIH0sXG4gIC8vICdlbnRlcicgYW5pbWF0aW9uIG9wdGlvbnNcbiAgbGVhdmU6IHtcbiAgICBkdXJhdGlvbjogMzUwLFxuICAgIGVhc2luZzogJ3F1YWRyYXRpY0luJyAvLyAnbGVhdmUnIGFuaW1hdGlvbiBvcHRpb25zXG5cbiAgfVxufTtcbnZhciBBbmltYXRlID0ge1xuICBkZWZhdWx0Q2ZnOiB7fSxcbiAgQWN0aW9uOiB7fSxcbiAgZ2V0QW5pbWF0aW9uOiBmdW5jdGlvbiBnZXRBbmltYXRpb24oZ2VvbVR5cGUsIGNvb3JkLCBhbmltYXRpb25UeXBlKSB7XG4gICAgdmFyIGdlb21BbmltYXRlQ2ZnID0gdGhpcy5kZWZhdWx0Q2ZnW2dlb21UeXBlXTtcblxuICAgIGlmIChnZW9tQW5pbWF0ZUNmZykge1xuICAgICAgdmFyIGFuaW1hdGlvbiA9IGdlb21BbmltYXRlQ2ZnW2FuaW1hdGlvblR5cGVdO1xuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGFuaW1hdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbihjb29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuICBnZXRBbmltYXRlQ2ZnOiBmdW5jdGlvbiBnZXRBbmltYXRlQ2ZnKGdlb21UeXBlLCBhbmltYXRpb25UeXBlKSB7XG4gICAgdmFyIGRlZmF1bHRDZmcgPSBkZWZhdWx0QW5pbWF0aW9uQ2ZnW2FuaW1hdGlvblR5cGVdO1xuICAgIHZhciBnZW9tQ29uZmlnID0gdGhpcy5kZWZhdWx0Q2ZnW2dlb21UeXBlXTtcblxuICAgIGlmIChnZW9tQ29uZmlnICYmIGdlb21Db25maWcuY2ZnICYmIGdlb21Db25maWcuY2ZnW2FuaW1hdGlvblR5cGVdKSB7XG4gICAgICByZXR1cm4gVXRpbC5kZWVwTWl4KHt9LCBkZWZhdWx0Q2ZnLCBnZW9tQ29uZmlnLmNmZ1thbmltYXRpb25UeXBlXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZmF1bHRDZmc7XG4gIH0sXG4gIHJlZ2lzdGVyQW5pbWF0aW9uOiBmdW5jdGlvbiByZWdpc3RlckFuaW1hdGlvbihhbmltYXRpb25OYW1lLCBhbmltYXRpb25GdW4pIHtcbiAgICBpZiAoIXRoaXMuQWN0aW9uKSB7XG4gICAgICB0aGlzLkFjdGlvbiA9IHt9O1xuICAgIH1cblxuICAgIHRoaXMuQWN0aW9uW2FuaW1hdGlvbk5hbWVdID0gYW5pbWF0aW9uRnVuO1xuICB9XG59O1xubW9kdWxlLmV4cG9ydHMgPSBBbmltYXRlO1xuXG4vKioqLyB9KSxcbi8qIDEwMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIFV0aWxpdHlcbiAqIEBhdXRob3Igc2ltYS56aGFuZzE5OTBAZ21haWwuY29tXG4gKi9cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gICAgTWF0cml4ID0gX3JlcXVpcmUuTWF0cml4O1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBIZWxwZXJzID0ge1xuICBnZXRDb29yZEluZm86IGZ1bmN0aW9uIGdldENvb3JkSW5mbyhjb29yZCkge1xuICAgIHZhciBzdGFydCA9IGNvb3JkLnN0YXJ0O1xuICAgIHZhciBlbmQgPSBjb29yZC5lbmQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogZW5kLFxuICAgICAgd2lkdGg6IGVuZC54IC0gc3RhcnQueCxcbiAgICAgIGhlaWdodDogTWF0aC5hYnMoZW5kLnkgLSBzdGFydC55KVxuICAgIH07XG4gIH0sXG4gIGdldFNjYWxlZE1hdHJpeDogZnVuY3Rpb24gZ2V0U2NhbGVkTWF0cml4KHNoYXBlLCB2LCBkaXJlY3QpIHtcbiAgICB2YXIgc2NhbGVkTWF0cml4O1xuICAgIHNoYXBlLmFwcGx5KHYpO1xuICAgIHZhciB4ID0gdlswXTtcbiAgICB2YXIgeSA9IHZbMV07XG5cbiAgICBpZiAoZGlyZWN0ID09PSAneCcpIHtcbiAgICAgIHNoYXBlLnRyYW5zZm9ybShbWyd0JywgeCwgeV0sIFsncycsIDAuMDEsIDFdLCBbJ3QnLCAteCwgLXldXSk7XG4gICAgICB2YXIgbWF0cml4ID0gc2hhcGUuZ2V0TWF0cml4KCk7XG4gICAgICBzY2FsZWRNYXRyaXggPSBNYXRyaXgudHJhbnNmb3JtKG1hdHJpeCwgW1sndCcsIHgsIHldLCBbJ3MnLCAxMDAsIDFdLCBbJ3QnLCAteCwgLXldXSk7XG4gICAgfSBlbHNlIGlmIChkaXJlY3QgPT09ICd5Jykge1xuICAgICAgc2hhcGUudHJhbnNmb3JtKFtbJ3QnLCB4LCB5XSwgWydzJywgMSwgMC4wMV0sIFsndCcsIC14LCAteV1dKTtcblxuICAgICAgdmFyIF9tYXRyaXggPSBzaGFwZS5nZXRNYXRyaXgoKTtcblxuICAgICAgc2NhbGVkTWF0cml4ID0gTWF0cml4LnRyYW5zZm9ybShfbWF0cml4LCBbWyd0JywgeCwgeV0sIFsncycsIDEsIDEwMF0sIFsndCcsIC14LCAteV1dKTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdCA9PT0gJ3h5Jykge1xuICAgICAgc2hhcGUudHJhbnNmb3JtKFtbJ3QnLCB4LCB5XSwgWydzJywgMC4wMSwgMC4wMV0sIFsndCcsIC14LCAteV1dKTtcblxuICAgICAgdmFyIF9tYXRyaXgyID0gc2hhcGUuZ2V0TWF0cml4KCk7XG5cbiAgICAgIHNjYWxlZE1hdHJpeCA9IE1hdHJpeC50cmFuc2Zvcm0oX21hdHJpeDIsIFtbJ3QnLCB4LCB5XSwgWydzJywgMTAwLCAxMDBdLCBbJ3QnLCAteCwgLXldXSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjYWxlZE1hdHJpeDtcbiAgfSxcbiAgZ2V0QW5pbWF0ZVBhcmFtOiBmdW5jdGlvbiBnZXRBbmltYXRlUGFyYW0oYW5pbWF0ZUNmZywgaW5kZXgsIGlkKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgaWYgKGFuaW1hdGVDZmcuZGVsYXkpIHtcbiAgICAgIHJlc3VsdC5kZWxheSA9IFV0aWwuaXNGdW5jdGlvbihhbmltYXRlQ2ZnLmRlbGF5KSA/IGFuaW1hdGVDZmcuZGVsYXkoaW5kZXgsIGlkKSA6IGFuaW1hdGVDZmcuZGVsYXk7XG4gICAgfVxuXG4gICAgcmVzdWx0LmVhc2luZyA9IGFuaW1hdGVDZmcuZWFzaW5nO1xuICAgIHJlc3VsdC5kdXJhdGlvbiA9IGFuaW1hdGVDZmcuZHVyYXRpb247XG4gICAgcmVzdWx0LmRlbGF5ID0gYW5pbWF0ZUNmZy5kZWxheTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuICBkb0FuaW1hdGlvbjogZnVuY3Rpb24gZG9BbmltYXRpb24oc2hhcGUsIGVuZFN0YXRlLCBhbmltYXRlQ2ZnLCBjYWxsYmFjaykge1xuICAgIHZhciBpZCA9IHNoYXBlLl9pZDtcbiAgICB2YXIgaW5kZXggPSBzaGFwZS5nZXQoJ2luZGV4Jyk7XG5cbiAgICB2YXIgX0hlbHBlcnMkZ2V0QW5pbWF0ZVBhID0gSGVscGVycy5nZXRBbmltYXRlUGFyYW0oYW5pbWF0ZUNmZywgaW5kZXgsIGlkKSxcbiAgICAgICAgZWFzaW5nID0gX0hlbHBlcnMkZ2V0QW5pbWF0ZVBhLmVhc2luZyxcbiAgICAgICAgZGVsYXkgPSBfSGVscGVycyRnZXRBbmltYXRlUGEuZGVsYXksXG4gICAgICAgIGR1cmF0aW9uID0gX0hlbHBlcnMkZ2V0QW5pbWF0ZVBhLmR1cmF0aW9uO1xuXG4gICAgdmFyIGFuaW0gPSBzaGFwZS5hbmltYXRlKCkudG8oe1xuICAgICAgYXR0cnM6IGVuZFN0YXRlLFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZGVsYXk6IGRlbGF5LFxuICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICB9KTtcblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgYW5pbS5vbkVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IEhlbHBlcnM7XG5cbi8qKiovIH0pLFxuLyogMTA0ICovLFxuLyogMTA1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMDYpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDQyKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg5MCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTA4KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg5MSk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTEwKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMTIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEdlb207XG5cbi8qKiovIH0pLFxuLyogMTA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMDcpO1xuXG52YXIgUG9pbnQgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HZW9tKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50LCBfR2VvbSk7XG5cbiAgZnVuY3Rpb24gUG9pbnQoKSB7XG4gICAgcmV0dXJuIF9HZW9tLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBQb2ludC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAncG9pbnQnO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAncG9pbnQnO1xuICAgIGNmZy5nZW5lcmF0ZVBvaW50cyA9IHRydWU7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uZHJhdyA9IGZ1bmN0aW9uIGRyYXcoZGF0YSwgc2hhcGVGYWN0b3J5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmdldCgnY29udGFpbmVyJyk7XG4gICAgVXRpbC5lYWNoKGRhdGEsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHZhciBzaGFwZSA9IG9iai5zaGFwZTtcbiAgICAgIHZhciBjZmcgPSBzZWxmLmdldERyYXdDZmcob2JqKTtcblxuICAgICAgaWYgKFV0aWwuaXNBcnJheShvYmoueSkpIHtcbiAgICAgICAgdmFyIGhhc1N0YWNrID0gc2VsZi5oYXNBZGp1c3QoJ3N0YWNrJyk7XG4gICAgICAgIFV0aWwuZWFjaChvYmoueSwgZnVuY3Rpb24gKHksIGlkeCkge1xuICAgICAgICAgIGNmZy55ID0geTtcblxuICAgICAgICAgIGlmICghaGFzU3RhY2sgfHwgaWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBzZWxmLmRyYXdTaGFwZShzaGFwZSwgb2JqLCBjZmcsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICghVXRpbC5pc05pbChvYmoueSkpIHtcbiAgICAgICAgc2VsZi5kcmF3U2hhcGUoc2hhcGUsIG9iaiwgY2ZnLCBjb250YWluZXIsIHNoYXBlRmFjdG9yeSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFBvaW50O1xufShHZW9tKTtcblxuR2VvbS5Qb2ludCA9IFBvaW50O1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxudmFyIFNoYXBlVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgU0hBUEVTID0gWydjaXJjbGUnLCAnaG9sbG93Q2lyY2xlJywgJ3JlY3QnXTtcbnZhciBQb2ludCA9IFNoYXBlLnJlZ2lzdGVyRmFjdG9yeSgncG9pbnQnLCB7XG4gIGRlZmF1bHRTaGFwZVR5cGU6ICdjaXJjbGUnLFxuICBnZXREZWZhdWx0UG9pbnRzOiBmdW5jdGlvbiBnZXREZWZhdWx0UG9pbnRzKHBvaW50SW5mbykge1xuICAgIHJldHVybiBTaGFwZVV0aWwuc3BsaXRQb2ludHMocG9pbnRJbmZvKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGdldFBvaW50c0NmZyhjZmcpIHtcbiAgdmFyIHN0eWxlID0ge1xuICAgIGxpbmVXaWR0aDogMCxcbiAgICBzdHJva2U6IGNmZy5jb2xvcixcbiAgICBmaWxsOiBjZmcuY29sb3JcbiAgfTtcblxuICBpZiAoY2ZnLnNpemUpIHtcbiAgICBzdHlsZS5zaXplID0gY2ZnLnNpemU7XG4gIH1cblxuICBVdGlsLm1peChzdHlsZSwgY2ZnLnN0eWxlKTtcbiAgcmV0dXJuIFV0aWwubWl4KHt9LCBHbG9iYWwuc2hhcGUucG9pbnQsIHN0eWxlKTtcbn1cblxuZnVuY3Rpb24gZHJhd1NoYXBlKGNmZywgY29udGFpbmVyLCBzaGFwZSkge1xuICBpZiAoY2ZnLnNpemUgPT09IDApIHJldHVybjtcbiAgdmFyIHBvaW50Q2ZnID0gZ2V0UG9pbnRzQ2ZnKGNmZyk7XG4gIHZhciBzaXplID0gcG9pbnRDZmcuciB8fCBwb2ludENmZy5zaXplO1xuICB2YXIgeCA9IGNmZy54O1xuICB2YXIgeSA9ICFVdGlsLmlzQXJyYXkoY2ZnLnkpID8gW2NmZy55XSA6IGNmZy55O1xuXG4gIGlmIChzaGFwZSA9PT0gJ2hvbGxvd0NpcmNsZScpIHtcbiAgICBwb2ludENmZy5saW5lV2lkdGggPSAxO1xuICAgIHBvaW50Q2ZnLmZpbGwgPSBudWxsO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoc2hhcGUgPT09ICdyZWN0Jykge1xuICAgICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnUmVjdCcsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAncG9pbnQnLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHg6IHggLSBzaXplLFxuICAgICAgICAgIHk6IHlbaV0gLSBzaXplLFxuICAgICAgICAgIHdpZHRoOiBzaXplICogMixcbiAgICAgICAgICBoZWlnaHQ6IHNpemUgKiAyXG4gICAgICAgIH0sIHBvaW50Q2ZnKVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnQ2lyY2xlJywge1xuICAgICAgY2xhc3NOYW1lOiAncG9pbnQnLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeVtpXSxcbiAgICAgICAgcjogc2l6ZVxuICAgICAgfSwgcG9pbnRDZmcpXG4gICAgfSk7XG4gIH1cbn1cblxuVXRpbC5lYWNoKFNIQVBFUywgZnVuY3Rpb24gKHNoYXBlVHlwZSkge1xuICBTaGFwZS5yZWdpc3RlclNoYXBlKCdwb2ludCcsIHNoYXBlVHlwZSwge1xuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICAgIHJldHVybiBkcmF3U2hhcGUoY2ZnLCBjb250YWluZXIsIHNoYXBlVHlwZSk7XG4gICAgfVxuICB9KTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQb2ludDtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbi8qKlxuICogQGZpbGVPdmVydmlldyBhcmVhIGdlb21ldHJ5XG4gKiBAYXV0aG9yIGR4cTYxMyBAZ21haWwuY29tXG4gKiBAYXV0aG9yIHNpbWEuemhhbmcxOTkwQGdtYWlsLmNvbVxuICovXG52YXIgR2VvbSA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG5cbnZhciBTaGFwZVV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEwOSk7XG5cbnZhciBBcmVhID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbSkge1xuICBfaW5oZXJpdHNMb29zZShBcmVhLCBfR2VvbSk7XG5cbiAgZnVuY3Rpb24gQXJlYSgpIHtcbiAgICByZXR1cm4gX0dlb20uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFyZWEucHJvdG90eXBlO1xuXG4gIC8qKlxuICAgKiBnZXQgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvblxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEByZXR1cm4ge09iamVjdH0gcmV0dXJuIHRoZSByZXN1bHRcbiAgICovXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0dlb20ucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ2FyZWEnO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAnYXJlYSc7XG4gICAgY2ZnLmdlbmVyYXRlUG9pbnRzID0gdHJ1ZTtcbiAgICBjZmcuc29ydGFibGUgPSB0cnVlO1xuICAgIHJldHVybiBjZmc7XG4gIH07XG5cbiAgX3Byb3RvLmRyYXcgPSBmdW5jdGlvbiBkcmF3KGRhdGEsIHNoYXBlRmFjdG9yeSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyID0gc2VsZi5nZXQoJ2NvbnRhaW5lcicpO1xuICAgIHZhciBjZmcgPSB0aGlzLmdldERyYXdDZmcoZGF0YVswXSk7XG4gICAgdmFyIHlTY2FsZSA9IHNlbGYuZ2V0WVNjYWxlKCk7XG4gICAgdmFyIGNvbm5lY3ROdWxscyA9IHNlbGYuZ2V0KCdjb25uZWN0TnVsbHMnKTtcbiAgICB2YXIgc3BsaXRBcnJheSA9IFNoYXBlVXRpbC5zcGxpdEFycmF5KGRhdGEsIHlTY2FsZS5maWVsZCwgY29ubmVjdE51bGxzKTtcbiAgICBjZmcub3JpZ2luID0gZGF0YTtcbiAgICBVdGlsLmVhY2goc3BsaXRBcnJheSwgZnVuY3Rpb24gKHN1YkRhdGEsIHNwbGl0ZWRJbmRleCkge1xuICAgICAgY2ZnLnNwbGl0ZWRJbmRleCA9IHNwbGl0ZWRJbmRleDtcbiAgICAgIHZhciBwb2ludHMgPSBzdWJEYXRhLm1hcChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmoucG9pbnRzO1xuICAgICAgfSk7XG4gICAgICBjZmcucG9pbnRzID0gcG9pbnRzO1xuICAgICAgc2VsZi5kcmF3U2hhcGUoY2ZnLnNoYXBlLCBkYXRhWzBdLCBjZmcsIGNvbnRhaW5lciwgc2hhcGVGYWN0b3J5KTtcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQXJlYTtcbn0oR2VvbSk7XG5cbkdlb20uQXJlYSA9IEFyZWE7XG5tb2R1bGUuZXhwb3J0cyA9IEFyZWE7XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFNoYXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxudmFyIFNtb290aCA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuXG52YXIgYmJveCA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuZnVuY3Rpb24gZXF1YWxzKHYxLCB2Mikge1xuICByZXR1cm4gTWF0aC5hYnModjEgLSB2MikgPCAwLjAwMDAxO1xufVxuXG5mdW5jdGlvbiBub3RFbXB0eSh2YWx1ZSkge1xuICByZXR1cm4gIWlzTmFOKHZhbHVlKSAmJiAhVXRpbC5pc05pbCh2YWx1ZSk7XG59XG5cbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhwb2ludHMpIHtcbiAgdmFyIGZpbHRlcmVkUG9pbnRzID0gW107IC8vIGZpbHRlciB0aGUgcG9pbnQgd2hpY2ggeCBvciB5IGlzIE5hTlxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICBpZiAobm90RW1wdHkocG9pbnQueCkgJiYgbm90RW1wdHkocG9pbnQueSkpIHtcbiAgICAgIGZpbHRlcmVkUG9pbnRzLnB1c2gocG9pbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaWx0ZXJlZFBvaW50cztcbn1cblxuZnVuY3Rpb24gZXF1YWxzQ2VudGVyKHBvaW50cywgY2VudGVyKSB7XG4gIHZhciBlcWxzID0gdHJ1ZTtcbiAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgaWYgKCFlcXVhbHMocG9pbnQueCwgY2VudGVyLngpIHx8ICFlcXVhbHMocG9pbnQueSwgY2VudGVyLnkpKSB7XG4gICAgICBlcWxzID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVxbHM7XG59XG5cbmZ1bmN0aW9uIGRyYXdSZWN0U2hhcGUodG9wUG9pbnRzLCBib3R0b21Qb2ludHMsIGNvbnRhaW5lciwgc3R5bGUsIGlzU21vb3RoKSB7XG4gIHZhciBzaGFwZTtcbiAgdmFyIHBvaW50cyA9IHRvcFBvaW50cy5jb25jYXQoYm90dG9tUG9pbnRzKTtcblxuICBpZiAoaXNTbW9vdGgpIHtcbiAgICBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnQ3VzdG9tJywge1xuICAgICAgY2xhc3NOYW1lOiAnYXJlYScsXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICBwb2ludHM6IHBvaW50c1xuICAgICAgfSwgc3R5bGUpLFxuICAgICAgY3JlYXRlUGF0aDogZnVuY3Rpb24gY3JlYXRlUGF0aChjb250ZXh0KSB7XG4gICAgICAgIHZhciBjb25zdGFpbnQgPSBbWzAsIDBdLCBbMSwgMV1dO1xuICAgICAgICB2YXIgcG9pbnRzID0gZmlsdGVyUG9pbnRzKHRoaXMuX2F0dHJzLmF0dHJzLnBvaW50cyk7XG4gICAgICAgIHZhciBwb2ludHNMZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgICB2YXIgdG9wUG9pbnRzID0gcG9pbnRzLnNsaWNlKDAsIHBvaW50c0xlbiAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tUG9pbnRzID0gcG9pbnRzLnNsaWNlKHBvaW50c0xlbiAvIDIsIHBvaW50c0xlbik7XG4gICAgICAgIHZhciB0b3BTcHMgPSBTbW9vdGguc21vb3RoKHRvcFBvaW50cywgZmFsc2UsIGNvbnN0YWludCk7XG4gICAgICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHRvcFBvaW50c1swXS54LCB0b3BQb2ludHNbMF0ueSk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b3BTcHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwID0gdG9wU3BzW2ldO1xuICAgICAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhzcFsxXSwgc3BbMl0sIHNwWzNdLCBzcFs0XSwgc3BbNV0sIHNwWzZdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChib3R0b21Qb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGJvdHRvbVNwcyA9IFNtb290aC5zbW9vdGgoYm90dG9tUG9pbnRzLCBmYWxzZSwgY29uc3RhaW50KTtcbiAgICAgICAgICBjb250ZXh0LmxpbmVUbyhib3R0b21Qb2ludHNbMF0ueCwgYm90dG9tUG9pbnRzWzBdLnkpO1xuXG4gICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbiA9IGJvdHRvbVNwcy5sZW5ndGg7IF9pIDwgX247IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBfc3AgPSBib3R0b21TcHNbX2ldO1xuICAgICAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKF9zcFsxXSwgX3NwWzJdLCBfc3BbM10sIF9zcFs0XSwgX3NwWzVdLCBfc3BbNl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICB9LFxuICAgICAgY2FsY3VsYXRlQm94OiBmdW5jdGlvbiBjYWxjdWxhdGVCb3goKSB7XG4gICAgICAgIHZhciBwb2ludHMgPSBmaWx0ZXJQb2ludHModGhpcy5fYXR0cnMuYXR0cnMucG9pbnRzKTtcbiAgICAgICAgcmV0dXJuIGJib3guZ2V0QkJveEZyb21Qb2ludHMocG9pbnRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgnUG9seWxpbmUnLCB7XG4gICAgICBjbGFzc05hbWU6ICdhcmVhJyxcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHBvaW50czogcG9pbnRzXG4gICAgICB9LCBzdHlsZSlcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaGFwZTtcbn1cblxuZnVuY3Rpb24gZHJhd1NoYXBlKGNmZywgY29udGFpbmVyLCBpc1Ntb290aCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2ludHMgPSBjZmcucG9pbnRzO1xuICB2YXIgdG9wUG9pbnRzID0gW107XG4gIHZhciBib3R0b21Qb2ludHMgPSBbXTtcbiAgVXRpbC5lYWNoKHBvaW50cywgZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgYm90dG9tUG9pbnRzLnB1c2gocG9pbnRbMF0pO1xuICAgIHRvcFBvaW50cy5wdXNoKHBvaW50WzFdKTtcbiAgfSk7XG4gIHZhciBzdHlsZSA9IFV0aWwubWl4KHtcbiAgICBmaWxsU3R5bGU6IGNmZy5jb2xvclxuICB9LCBHbG9iYWwuc2hhcGUuYXJlYSwgY2ZnLnN0eWxlKTtcbiAgYm90dG9tUG9pbnRzLnJldmVyc2UoKTtcbiAgdG9wUG9pbnRzID0gc2VsZi5wYXJzZVBvaW50cyh0b3BQb2ludHMpO1xuICBib3R0b21Qb2ludHMgPSBzZWxmLnBhcnNlUG9pbnRzKGJvdHRvbVBvaW50cyk7XG5cbiAgaWYgKGNmZy5pc0luQ2lyY2xlKSB7XG4gICAgdG9wUG9pbnRzLnB1c2godG9wUG9pbnRzWzBdKTtcbiAgICBib3R0b21Qb2ludHMudW5zaGlmdChib3R0b21Qb2ludHNbYm90dG9tUG9pbnRzLmxlbmd0aCAtIDFdKTtcblxuICAgIGlmIChlcXVhbHNDZW50ZXIoYm90dG9tUG9pbnRzLCBjZmcuY2VudGVyKSkge1xuICAgICAgYm90dG9tUG9pbnRzID0gW107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRyYXdSZWN0U2hhcGUodG9wUG9pbnRzLCBib3R0b21Qb2ludHMsIGNvbnRhaW5lciwgc3R5bGUsIGlzU21vb3RoKTtcbn1cblxudmFyIEFyZWEgPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ2FyZWEnLCB7XG4gIGRlZmF1bHRTaGFwZVR5cGU6ICdhcmVhJyxcbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cyhvYmopIHtcbiAgICB2YXIgeCA9IG9iai54O1xuICAgIHZhciB5ID0gb2JqLnk7XG4gICAgdmFyIHkwID0gb2JqLnkwO1xuICAgIHkgPSBVdGlsLmlzQXJyYXkoeSkgPyB5IDogW3kwLCB5XTtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgcG9pbnRzLnB1c2goe1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlbMF1cbiAgICB9LCB7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVsxXVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbn0pO1xudmFyIFNIQVBFUyA9IFsnYXJlYScsICdzbW9vdGgnXTtcblV0aWwuZWFjaChTSEFQRVMsIGZ1bmN0aW9uIChzaGFwZVR5cGUpIHtcbiAgU2hhcGUucmVnaXN0ZXJTaGFwZSgnYXJlYScsIHNoYXBlVHlwZSwge1xuICAgIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICAgIHZhciBzbW9vdGggPSBzaGFwZVR5cGUgPT09ICdzbW9vdGgnO1xuICAgICAgcmV0dXJuIGRyYXdTaGFwZS5jYWxsKHRoaXMsIGNmZywgY29udGFpbmVyLCBzbW9vdGgpO1xuICAgIH1cbiAgfSk7XG59KTtcbm1vZHVsZS5leHBvcnRzID0gQXJlYTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExMSk7XG5cbnZhciBQb2x5Z29uID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR2VvbSkge1xuICBfaW5oZXJpdHNMb29zZShQb2x5Z29uLCBfR2VvbSk7XG5cbiAgZnVuY3Rpb24gUG9seWdvbigpIHtcbiAgICByZXR1cm4gX0dlb20uYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFBvbHlnb24ucHJvdG90eXBlO1xuXG4gIF9wcm90by5nZXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gZ2V0RGVmYXVsdENmZygpIHtcbiAgICB2YXIgY2ZnID0gX0dlb20ucHJvdG90eXBlLmdldERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIGNmZy50eXBlID0gJ3BvbHlnb24nO1xuICAgIGNmZy5zaGFwZVR5cGUgPSAncG9seWdvbic7XG4gICAgY2ZnLmdlbmVyYXRlUG9pbnRzID0gdHJ1ZTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5jcmVhdGVTaGFwZVBvaW50c0NmZyA9IGZ1bmN0aW9uIGNyZWF0ZVNoYXBlUG9pbnRzQ2ZnKG9iaikge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB4ID0gY2ZnLng7XG4gICAgdmFyIHkgPSBjZmcueTtcbiAgICB2YXIgdGVtcDtcblxuICAgIGlmICghKFV0aWwuaXNBcnJheSh4KSAmJiBVdGlsLmlzQXJyYXkoeSkpKSB7XG4gICAgICB2YXIgeFNjYWxlID0gc2VsZi5nZXRYU2NhbGUoKTtcbiAgICAgIHZhciB5U2NhbGUgPSBzZWxmLmdldFlTY2FsZSgpO1xuICAgICAgdmFyIHhDb3VudCA9IHhTY2FsZS52YWx1ZXMgPyB4U2NhbGUudmFsdWVzLmxlbmd0aCA6IHhTY2FsZS50aWNrcy5sZW5ndGg7XG4gICAgICB2YXIgeUNvdW50ID0geVNjYWxlLnZhbHVlcyA/IHlTY2FsZS52YWx1ZXMubGVuZ3RoIDogeVNjYWxlLnRpY2tzLmxlbmd0aDtcbiAgICAgIHZhciB4T2Zmc2V0ID0gMC41ICogMSAvIHhDb3VudDtcbiAgICAgIHZhciB5T2Zmc2V0ID0gMC41ICogMSAvIHlDb3VudDtcblxuICAgICAgaWYgKHhTY2FsZS5pc0NhdGVnb3J5ICYmIHlTY2FsZS5pc0NhdGVnb3J5KSB7XG4gICAgICAgIHggPSBbeCAtIHhPZmZzZXQsIHggLSB4T2Zmc2V0LCB4ICsgeE9mZnNldCwgeCArIHhPZmZzZXRdO1xuICAgICAgICB5ID0gW3kgLSB5T2Zmc2V0LCB5ICsgeU9mZnNldCwgeSArIHlPZmZzZXQsIHkgLSB5T2Zmc2V0XTtcbiAgICAgIH0gZWxzZSBpZiAoVXRpbC5pc0FycmF5KHgpKSB7XG4gICAgICAgIHRlbXAgPSB4O1xuICAgICAgICB4ID0gW3RlbXBbMF0sIHRlbXBbMF0sIHRlbXBbMV0sIHRlbXBbMV1dO1xuICAgICAgICB5ID0gW3kgLSB5T2Zmc2V0IC8gMiwgeSArIHlPZmZzZXQgLyAyLCB5ICsgeU9mZnNldCAvIDIsIHkgLSB5T2Zmc2V0IC8gMl07XG4gICAgICB9IGVsc2UgaWYgKFV0aWwuaXNBcnJheSh5KSkge1xuICAgICAgICB0ZW1wID0geTtcbiAgICAgICAgeSA9IFt0ZW1wWzBdLCB0ZW1wWzFdLCB0ZW1wWzFdLCB0ZW1wWzBdXTtcbiAgICAgICAgeCA9IFt4IC0geE9mZnNldCAvIDIsIHggLSB4T2Zmc2V0IC8gMiwgeCArIHhPZmZzZXQgLyAyLCB4ICsgeE9mZnNldCAvIDJdO1xuICAgICAgfVxuXG4gICAgICBjZmcueCA9IHg7XG4gICAgICBjZmcueSA9IHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICByZXR1cm4gUG9seWdvbjtcbn0oR2VvbSk7XG5cbkdlb20uUG9seWdvbiA9IFBvbHlnb247XG5tb2R1bGUuZXhwb3J0cyA9IFBvbHlnb247XG5cbi8qKiovIH0pLFxuLyogMTExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBTaGFwZSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIFBvbHlnb24gPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ3BvbHlnb24nLCB7XG4gIGRlZmF1bHRTaGFwZVR5cGU6ICdwb2x5Z29uJyxcbiAgZ2V0RGVmYXVsdFBvaW50czogZnVuY3Rpb24gZ2V0RGVmYXVsdFBvaW50cyhwb2ludEluZm8pIHtcbiAgICB2YXIgcG9pbnRzID0gW107XG4gICAgdmFyIHggPSBwb2ludEluZm8ueCxcbiAgICAgICAgeSA9IHBvaW50SW5mby55O1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHgubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHBvaW50cy5wdXNoKHtcbiAgICAgICAgeDogeFtpXSxcbiAgICAgICAgeTogeVtpXVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxufSk7XG5TaGFwZS5yZWdpc3RlclNoYXBlKCdwb2x5Z29uJywgJ3BvbHlnb24nLCB7XG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wYXJzZVBvaW50cyhjZmcucG9pbnRzKTtcbiAgICB2YXIgc3R5bGUgPSBVdGlsLm1peCh7XG4gICAgICBmaWxsOiBjZmcuY29sb3IsXG4gICAgICBwb2ludHM6IHBvaW50c1xuICAgIH0sIGNmZy5zdHlsZSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnUG9seWdvbicsIHtcbiAgICAgIGNsYXNzTmFtZTogJ3BvbHlnb24nLFxuICAgICAgYXR0cnM6IHN0eWxlXG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBQb2x5Z29uO1xuXG4vKioqLyB9KSxcbi8qIDExMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHsgaWYgKHNlbGYgPT09IHZvaWQgMCkgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBHZW9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgU2l6ZU1peGluID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Myk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTEzKTtcblxudmFyIFNjaGVtYSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0dlb20pIHtcbiAgX2luaGVyaXRzTG9vc2UoU2NoZW1hLCBfR2VvbSk7XG5cbiAgdmFyIF9wcm90byA9IFNjaGVtYS5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuZ2V0RGVmYXVsdENmZy5jYWxsKHRoaXMpO1xuXG4gICAgY2ZnLnR5cGUgPSAnc2NoZW1hJztcbiAgICBjZmcuc2hhcGVUeXBlID0gJ3NjaGVtYSc7XG4gICAgY2ZnLmdlbmVyYXRlUG9pbnRzID0gdHJ1ZTtcbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFNjaGVtYShjZmcpIHtcbiAgICB2YXIgX3RoaXM7XG5cbiAgICBfdGhpcyA9IF9HZW9tLmNhbGwodGhpcywgY2ZnKSB8fCB0aGlzO1xuICAgIFV0aWwubWl4KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBTaXplTWl4aW4pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIF9wcm90by5jcmVhdGVTaGFwZVBvaW50c0NmZyA9IGZ1bmN0aW9uIGNyZWF0ZVNoYXBlUG9pbnRzQ2ZnKG9iaikge1xuICAgIHZhciBjZmcgPSBfR2VvbS5wcm90b3R5cGUuY3JlYXRlU2hhcGVQb2ludHNDZmcuY2FsbCh0aGlzLCBvYmopO1xuXG4gICAgY2ZnLnNpemUgPSB0aGlzLmdldE5vcm1hbGl6ZWRTaXplKG9iaik7XG4gICAgcmV0dXJuIGNmZztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXJJbm5lciA9IGZ1bmN0aW9uIGNsZWFySW5uZXIoKSB7XG4gICAgX0dlb20ucHJvdG90eXBlLmNsZWFySW5uZXIuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc2V0KCdkZWZhdWx0U2l6ZScsIG51bGwpO1xuICB9O1xuXG4gIHJldHVybiBTY2hlbWE7XG59KEdlb20pO1xuXG5HZW9tLlNjaGVtYSA9IFNjaGVtYTtcbm1vZHVsZS5leHBvcnRzID0gU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDExMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgU2hhcGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbmZ1bmN0aW9uIF9zb3J0VmFsdWUodmFsdWUpIHtcbiAgdmFyIHNvcnRlZCA9IHZhbHVlLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYSA8IGIgPyAxIDogLTE7XG4gIH0pO1xuICB2YXIgbGVuZ3RoID0gc29ydGVkLmxlbmd0aDtcblxuICBpZiAobGVuZ3RoIDwgNCkge1xuICAgIHZhciBtaW4gPSBzb3J0ZWRbbGVuZ3RoIC0gMV07XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgLSBsZW5ndGg7IGkrKykge1xuICAgICAgc29ydGVkLnB1c2gobWluKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc29ydGVkO1xufSAvLyBmcm9tIGxlZnQgYm90dG9tIGNvcm5lciwgYW5kIGNsb2Nrd2lzZVxuXG5cbmZ1bmN0aW9uIGdldENhbmRsZVBvaW50cyh4LCB5LCB3aWR0aCkge1xuICB2YXIgeVZhbHVlcyA9IF9zb3J0VmFsdWUoeSk7XG5cbiAgdmFyIHBvaW50cyA9IFt7XG4gICAgeDogeCxcbiAgICB5OiB5VmFsdWVzWzBdXG4gIH0sIHtcbiAgICB4OiB4LFxuICAgIHk6IHlWYWx1ZXNbMV1cbiAgfSwge1xuICAgIHg6IHggLSB3aWR0aCAvIDIsXG4gICAgeTogeVZhbHVlc1syXVxuICB9LCB7XG4gICAgeDogeCAtIHdpZHRoIC8gMixcbiAgICB5OiB5VmFsdWVzWzFdXG4gIH0sIHtcbiAgICB4OiB4ICsgd2lkdGggLyAyLFxuICAgIHk6IHlWYWx1ZXNbMV1cbiAgfSwge1xuICAgIHg6IHggKyB3aWR0aCAvIDIsXG4gICAgeTogeVZhbHVlc1syXVxuICB9LCB7XG4gICAgeDogeCxcbiAgICB5OiB5VmFsdWVzWzJdXG4gIH0sIHtcbiAgICB4OiB4LFxuICAgIHk6IHlWYWx1ZXNbM11cbiAgfV07XG4gIHJldHVybiBwb2ludHM7XG59XG5cbnZhciBTY2hlbWEgPSBTaGFwZS5yZWdpc3RlckZhY3RvcnkoJ3NjaGVtYScsIHt9KTtcblNoYXBlLnJlZ2lzdGVyU2hhcGUoJ3NjaGVtYScsICdjYW5kbGUnLCB7XG4gIGdldFBvaW50czogZnVuY3Rpb24gZ2V0UG9pbnRzKGNmZykge1xuICAgIHJldHVybiBnZXRDYW5kbGVQb2ludHMoY2ZnLngsIGNmZy55LCBjZmcuc2l6ZSk7XG4gIH0sXG4gIGRyYXc6IGZ1bmN0aW9uIGRyYXcoY2ZnLCBjb250YWluZXIpIHtcbiAgICB2YXIgcG9pbnRzID0gdGhpcy5wYXJzZVBvaW50cyhjZmcucG9pbnRzKTtcbiAgICB2YXIgc3R5bGUgPSBVdGlsLm1peCh7XG4gICAgICBzdHJva2U6IGNmZy5jb2xvcixcbiAgICAgIGZpbGw6IGNmZy5jb2xvcixcbiAgICAgIGxpbmVXaWR0aDogMVxuICAgIH0sIGNmZy5zdHlsZSk7XG4gICAgcmV0dXJuIGNvbnRhaW5lci5hZGRTaGFwZSgnQ3VzdG9tJywge1xuICAgICAgY2xhc3NOYW1lOiAnc2NoZW1hJyxcbiAgICAgIGF0dHJzOiBzdHlsZSxcbiAgICAgIGNyZWF0ZVBhdGg6IGZ1bmN0aW9uIGNyZWF0ZVBhdGgoY3R4KSB7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbMF0ueCwgcG9pbnRzWzBdLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1sxXS54LCBwb2ludHNbMV0ueSk7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9pbnRzWzJdLngsIHBvaW50c1syXS55KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMzsgaSA8IDY7IGkrKykge1xuICAgICAgICAgIGN0eC5saW5lVG8ocG9pbnRzW2ldLngsIHBvaW50c1tpXS55KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyhwb2ludHNbNl0ueCwgcG9pbnRzWzZdLnkpO1xuICAgICAgICBjdHgubGluZVRvKHBvaW50c1s3XS54LCBwb2ludHNbN10ueSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xubW9kdWxlLmV4cG9ydHMgPSBTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBBYnN0cmFjdCA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuXG52YXIgQ2lyY2xlID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfQWJzdHJhY3QpIHtcbiAgX2luaGVyaXRzTG9vc2UoQ2lyY2xlLCBfQWJzdHJhY3QpO1xuXG4gIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICByZXR1cm4gX0Fic3RyYWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBDaXJjbGUucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgX0Fic3RyYWN0LnByb3RvdHlwZS5faW5pdERlZmF1bHRDZmcuY2FsbCh0aGlzKTtcblxuICAgIHRoaXMuc3RhcnRBbmdsZSA9IC1NYXRoLlBJIC8gMjsgLy8gc3RhcnQgYW5nbGXvvIxpbiByYWRpYW5cblxuICAgIHRoaXMuZW5kQW5nbGUgPSBNYXRoLlBJICogMyAvIDI7IC8vIGVuZCBhbmdsZSwgaW4gcmFkaWFuXG5cbiAgICB0aGlzLnJhZGl1cyA9IG51bGw7IC8vIHJhZGl1c1xuXG4gICAgdGhpcy5jZW50ZXIgPSBudWxsOyAvLyBjZW50ZXJcbiAgfTtcblxuICBfcHJvdG8uZ2V0T2Zmc2V0UG9pbnQgPSBmdW5jdGlvbiBnZXRPZmZzZXRQb2ludCh2YWx1ZSkge1xuICAgIHZhciBzdGFydEFuZ2xlID0gdGhpcy5zdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZSA9IHRoaXMuZW5kQW5nbGU7XG4gICAgdmFyIGFuZ2xlID0gc3RhcnRBbmdsZSArIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpICogdmFsdWU7XG4gICAgcmV0dXJuIHRoaXMuX2dldENpcmNsZVBvaW50KGFuZ2xlKTtcbiAgfTtcblxuICBfcHJvdG8uX2dldENpcmNsZVBvaW50ID0gZnVuY3Rpb24gX2dldENpcmNsZVBvaW50KGFuZ2xlLCByYWRpdXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNlbnRlciA9IHNlbGYuY2VudGVyO1xuICAgIHJhZGl1cyA9IHJhZGl1cyB8fCBzZWxmLnJhZGl1cztcbiAgICByZXR1cm4ge1xuICAgICAgeDogY2VudGVyLnggKyBNYXRoLmNvcyhhbmdsZSkgKiByYWRpdXMsXG4gICAgICB5OiBjZW50ZXIueSArIE1hdGguc2luKGFuZ2xlKSAqIHJhZGl1c1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFRleHRBbGlnbkluZm8gPSBmdW5jdGlvbiBnZXRUZXh0QWxpZ25JbmZvKHBvaW50LCBvZmZzZXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIG9mZnNldFZlY3RvciA9IHNlbGYuZ2V0T2Zmc2V0VmVjdG9yKHBvaW50LCBvZmZzZXQpO1xuICAgIHZhciBhbGlnbjtcbiAgICB2YXIgYmFzZUxpbmUgPSAnbWlkZGxlJztcblxuICAgIGlmIChvZmZzZXRWZWN0b3JbMF0gPiAwKSB7XG4gICAgICBhbGlnbiA9ICdsZWZ0JztcbiAgICB9IGVsc2UgaWYgKG9mZnNldFZlY3RvclswXSA8IDApIHtcbiAgICAgIGFsaWduID0gJ3JpZ2h0JztcbiAgICB9IGVsc2Uge1xuICAgICAgYWxpZ24gPSAnY2VudGVyJztcblxuICAgICAgaWYgKG9mZnNldFZlY3RvclsxXSA+IDApIHtcbiAgICAgICAgYmFzZUxpbmUgPSAndG9wJztcbiAgICAgIH0gZWxzZSBpZiAob2Zmc2V0VmVjdG9yWzFdIDwgMCkge1xuICAgICAgICBiYXNlTGluZSA9ICdib3R0b20nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0QWxpZ246IGFsaWduLFxuICAgICAgdGV4dEJhc2VsaW5lOiBiYXNlTGluZVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldEF4aXNWZWN0b3IgPSBmdW5jdGlvbiBnZXRBeGlzVmVjdG9yKHBvaW50KSB7XG4gICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyO1xuICAgIHZhciBmYWN0b3IgPSB0aGlzLm9mZnNldEZhY3RvcjtcbiAgICByZXR1cm4gWyhwb2ludC55IC0gY2VudGVyLnkpICogZmFjdG9yLCAocG9pbnQueCAtIGNlbnRlci54KSAqIC0xICogZmFjdG9yXTtcbiAgfTtcblxuICBfcHJvdG8uZHJhd0xpbmUgPSBmdW5jdGlvbiBkcmF3TGluZShsaW5lQ2ZnKSB7XG4gICAgdmFyIGNlbnRlciA9IHRoaXMuY2VudGVyLFxuICAgICAgICByYWRpdXMgPSB0aGlzLnJhZGl1cyxcbiAgICAgICAgc3RhcnRBbmdsZSA9IHRoaXMuc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUgPSB0aGlzLmVuZEFuZ2xlO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmdldENvbnRhaW5lcihsaW5lQ2ZnLnRvcCk7XG4gICAgY29udGFpbmVyLmFkZFNoYXBlKCdhcmMnLCB7XG4gICAgICBjbGFzc05hbWU6ICdheGlzLWxpbmUnLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogY2VudGVyLngsXG4gICAgICAgIHk6IGNlbnRlci55LFxuICAgICAgICByOiByYWRpdXMsXG4gICAgICAgIHN0YXJ0QW5nbGU6IHN0YXJ0QW5nbGUsXG4gICAgICAgIGVuZEFuZ2xlOiBlbmRBbmdsZVxuICAgICAgfSwgbGluZUNmZylcbiAgICB9KTtcbiAgfTtcblxuICByZXR1cm4gQ2lyY2xlO1xufShBYnN0cmFjdCk7XG5cbkFic3RyYWN0LkNpcmNsZSA9IENpcmNsZTtcbm1vZHVsZS5leHBvcnRzID0gQ2lyY2xlO1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVGltZUNhdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTE2KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUaW1lQ2F0O1xuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykge1xuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7XG4gIHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcg5pe26Ze05pWw5o2u5L2c5Li65YiG57G757G75Z6LXG4gKiBAYXV0aG9yIGR4cTYxM0BnbWFpbC5jb21cbiAqL1xuXG5cbnZhciBCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG5cbnZhciBDYXRlZ29yeSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG52YXIgZmVjaGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExNyk7XG5cbnZhciBjYXRBdXRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbnZhciBUaW1lVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oOTkpO1xuXG52YXIgZWFjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG5cbnZhciBpc051bWJlciA9IF9fd2VicGFja19yZXF1aXJlX18oMTcpO1xuXG52YXIgaXNPYmplY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxudmFyIGlzU3RyaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKipcbiAqIOW6pumHj+eahOaehOmAoOWHveaVsFxuICogQGNsYXNzIFNjYWxlLlRpbWVDYXRlZ29yeVxuICovXG5cblxudmFyIFRpbWVDYXRlZ29yeSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0NhdGVnb3J5KSB7XG4gIF9pbmhlcml0c0xvb3NlKFRpbWVDYXRlZ29yeSwgX0NhdGVnb3J5KTtcblxuICBmdW5jdGlvbiBUaW1lQ2F0ZWdvcnkoKSB7XG4gICAgcmV0dXJuIF9DYXRlZ29yeS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGltZUNhdGVnb3J5LnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIF9DYXRlZ29yeS5wcm90b3R5cGUuX2luaXREZWZhdWx0Q2ZnLmNhbGwodGhpcyk7XG5cbiAgICB0aGlzLnR5cGUgPSAndGltZUNhdCc7XG4gICAgLyoqXG4gICAgICog5piv5ZCm6ZyA6KaB5o6S5bqP77yM6buY6K6k6L+b6KGM5o6S5bqPXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICovXG5cbiAgICB0aGlzLnNvcnRhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLnRpY2tDb3VudCA9IDU7XG4gICAgLyoqXG4gICAgICog5pe26Ze05qC85byP5YyWXG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMubWFzayA9ICdZWVlZLU1NLUREJztcbiAgfTtcblxuICBfcHJvdG8uaW5pdCA9IGZ1bmN0aW9uIGluaXQoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB2YWx1ZXMgPSB0aGlzLnZhbHVlczsgLy8g6ZKI5a+55pe26Ze05YiG57G757G75Z6L77yM5Lya5bCG5pe26Ze057uf5LiA6L2s5o2i5Li65pe26Ze05oizXG5cbiAgICBlYWNoKHZhbHVlcywgZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgIHZhbHVlc1tpXSA9IHNlbGYuX3RvVGltZVN0YW1wKHYpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuc29ydGFibGUpIHtcbiAgICAgIC8vIOWFgeiuuOaOkuW6j1xuICAgICAgdmFsdWVzLnNvcnQoZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICByZXR1cm4gdjEgLSB2MjtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghc2VsZi50aWNrcykge1xuICAgICAgc2VsZi50aWNrcyA9IHRoaXMuY2FsY3VsYXRlVGlja3MoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIOiuoeeulyB0aWNrc1xuICAgKiBAcmV0dXJuIHthcnJheX0g6L+U5ZueIHRpY2tzIOaVsOe7hFxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5jYWxjdWxhdGVUaWNrcyA9IGZ1bmN0aW9uIGNhbGN1bGF0ZVRpY2tzKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY291bnQgPSBzZWxmLnRpY2tDb3VudDtcbiAgICB2YXIgdGlja3M7XG5cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIHZhciB0ZW1wID0gY2F0QXV0byh7XG4gICAgICAgIG1heENvdW50OiBjb3VudCxcbiAgICAgICAgZGF0YTogc2VsZi52YWx1ZXMsXG4gICAgICAgIGlzUm91bmRpbmc6IHNlbGYuaXNSb3VuZGluZ1xuICAgICAgfSk7XG4gICAgICB0aWNrcyA9IHRlbXAudGlja3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRpY2tzID0gc2VsZi52YWx1ZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRpY2tzO1xuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIDtcblxuICBfcHJvdG8udHJhbnNsYXRlID0gZnVuY3Rpb24gdHJhbnNsYXRlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB0aGlzLl90b1RpbWVTdGFtcCh2YWx1ZSk7XG4gICAgdmFyIGluZGV4ID0gdGhpcy52YWx1ZXMuaW5kZXhPZih2YWx1ZSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICBpZiAoaXNOdW1iZXIodmFsdWUpICYmIHZhbHVlIDwgdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGluZGV4ID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmRleCA9IE5hTjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5kZXg7XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5zY2FsZSA9IGZ1bmN0aW9uIHNjYWxlKHZhbHVlKSB7XG4gICAgdmFyIHJhbmdlTWluID0gdGhpcy5yYW5nZU1pbigpO1xuICAgIHZhciByYW5nZU1heCA9IHRoaXMucmFuZ2VNYXgoKTtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRyYW5zbGF0ZSh2YWx1ZSk7XG4gICAgdmFyIHBlcmNlbnQ7XG5cbiAgICBpZiAodGhpcy52YWx1ZXMubGVuZ3RoID09PSAxIHx8IGlzTmFOKGluZGV4KSkge1xuICAgICAgLy8gaXMgaW5kZXggaXMgTkFOIHNob3VsZCBub3QgYmUgc2V0IGFzIDBcbiAgICAgIHBlcmNlbnQgPSBpbmRleDtcbiAgICB9IGVsc2UgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHBlcmNlbnQgPSBpbmRleCAvICh0aGlzLnZhbHVlcy5sZW5ndGggLSAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGVyY2VudCA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlTWluICsgcGVyY2VudCAqIChyYW5nZU1heCAtIHJhbmdlTWluKTtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFRleHQgPSBmdW5jdGlvbiBnZXRUZXh0KHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHZhciBpbmRleCA9IHRoaXMudHJhbnNsYXRlKHZhbHVlKTtcblxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICByZXN1bHQgPSB0aGlzLnZhbHVlc1tpbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBmb3JtYXR0ZXIgPSB0aGlzLmZvcm1hdHRlcjtcbiAgICByZXN1bHQgPSBwYXJzZUludChyZXN1bHQsIDEwKTtcbiAgICByZXN1bHQgPSBmb3JtYXR0ZXIgPyBmb3JtYXR0ZXIocmVzdWx0KSA6IGZlY2hhLmZvcm1hdChyZXN1bHQsIHRoaXMubWFzayk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLmdldFRpY2tzID0gZnVuY3Rpb24gZ2V0VGlja3MoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB0aWNrcyA9IHRoaXMudGlja3M7XG4gICAgdmFyIHJzdCA9IFtdO1xuICAgIGVhY2godGlja3MsIGZ1bmN0aW9uICh0aWNrKSB7XG4gICAgICB2YXIgb2JqO1xuXG4gICAgICBpZiAoaXNPYmplY3QodGljaykpIHtcbiAgICAgICAgb2JqID0gdGljaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9iaiA9IHtcbiAgICAgICAgICB0ZXh0OiBpc1N0cmluZyh0aWNrKSA/IHRpY2sgOiBzZWxmLmdldFRleHQodGljayksXG4gICAgICAgICAgdmFsdWU6IHNlbGYuc2NhbGUodGljayksXG4gICAgICAgICAgdGlja1ZhbHVlOiB0aWNrIC8vIOeUqOS6juWdkOagh+i9tOS4iuaWh+acrOWKqOeUu+aXtuehruWumuWJjeWQjuW4p+eahOWvueW6lOWFs+ezu1xuXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJzdC5wdXNoKG9iaik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJzdDtcbiAgfSAvLyDlsIbml7bpl7TovazmjaLkuLrml7bpl7TmiLNcbiAgO1xuXG4gIF9wcm90by5fdG9UaW1lU3RhbXAgPSBmdW5jdGlvbiBfdG9UaW1lU3RhbXAodmFsdWUpIHtcbiAgICByZXR1cm4gVGltZVV0aWwudG9UaW1lU3RhbXAodmFsdWUpO1xuICB9O1xuXG4gIHJldHVybiBUaW1lQ2F0ZWdvcnk7XG59KENhdGVnb3J5KTtcblxuQmFzZS5UaW1lQ2F0ID0gVGltZUNhdGVnb3J5O1xubW9kdWxlLmV4cG9ydHMgPSBUaW1lQ2F0ZWdvcnk7XG5cbi8qKiovIH0pLFxuLyogMTE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfX1dFQlBBQ0tfQU1EX0RFRklORV9SRVNVTFRfXzsoZnVuY3Rpb24gKG1haW4pIHtcbiAgJ3VzZSBzdHJpY3QnO1xuICAvKipcbiAgICogUGFyc2Ugb3IgZm9ybWF0IGRhdGVzXG4gICAqIEBjbGFzcyBmZWNoYVxuICAgKi9cblxuICB2YXIgZmVjaGEgPSB7fTtcbiAgdmFyIHRva2VuID0gL2R7MSw0fXxNezEsNH18WVkoPzpZWSk/fFN7MSwzfXxEb3xaWnwoW0hoTXNEbV0pXFwxP3xbYUFdfFwiW15cIl0qXCJ8J1teJ10qJy9nO1xuICB2YXIgdHdvRGlnaXRzID0gL1xcZFxcZD8vO1xuICB2YXIgdGhyZWVEaWdpdHMgPSAvXFxkezN9LztcbiAgdmFyIGZvdXJEaWdpdHMgPSAvXFxkezR9LztcbiAgdmFyIHdvcmQgPSAvWzAtOV0qWydhLXpcXHUwMEEwLVxcdTA1RkZcXHUwNzAwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdK3xbXFx1MDYwMC1cXHUwNkZGXFwvXSsoXFxzKj9bXFx1MDYwMC1cXHUwNkZGXSspezEsMn0vaTtcbiAgdmFyIGxpdGVyYWwgPSAvXFxbKFteXSo/KVxcXS9nbTtcblxuICB2YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIGZ1bmN0aW9uIHNob3J0ZW4oYXJyLCBzTGVuKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgbmV3QXJyLnB1c2goYXJyW2ldLnN1YnN0cigwLCBzTGVuKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vbnRoVXBkYXRlKGFyck5hbWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIHYsIGkxOG4pIHtcbiAgICAgIHZhciBpbmRleCA9IGkxOG5bYXJyTmFtZV0uaW5kZXhPZih2LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdi5zdWJzdHIoMSkudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgIGlmICh+aW5kZXgpIHtcbiAgICAgICAgZC5tb250aCA9IGluZGV4O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBwYWQodmFsLCBsZW4pIHtcbiAgICB2YWwgPSBTdHJpbmcodmFsKTtcbiAgICBsZW4gPSBsZW4gfHwgMjtcblxuICAgIHdoaWxlICh2YWwubGVuZ3RoIDwgbGVuKSB7XG4gICAgICB2YWwgPSAnMCcgKyB2YWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIHZhciBkYXlOYW1lcyA9IFsnU3VuZGF5JywgJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknXTtcbiAgdmFyIG1vbnRoTmFtZXMgPSBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXTtcbiAgdmFyIG1vbnRoTmFtZXNTaG9ydCA9IHNob3J0ZW4obW9udGhOYW1lcywgMyk7XG4gIHZhciBkYXlOYW1lc1Nob3J0ID0gc2hvcnRlbihkYXlOYW1lcywgMyk7XG4gIGZlY2hhLmkxOG4gPSB7XG4gICAgZGF5TmFtZXNTaG9ydDogZGF5TmFtZXNTaG9ydCxcbiAgICBkYXlOYW1lczogZGF5TmFtZXMsXG4gICAgbW9udGhOYW1lc1Nob3J0OiBtb250aE5hbWVzU2hvcnQsXG4gICAgbW9udGhOYW1lczogbW9udGhOYW1lcyxcbiAgICBhbVBtOiBbJ2FtJywgJ3BtJ10sXG4gICAgRG9GbjogZnVuY3Rpb24gRG9GbihEKSB7XG4gICAgICByZXR1cm4gRCArIFsndGgnLCAnc3QnLCAnbmQnLCAncmQnXVtEICUgMTAgPiAzID8gMCA6IChEIC0gRCAlIDEwICE9PSAxMCkgKiBEICUgMTBdO1xuICAgIH1cbiAgfTtcbiAgdmFyIGZvcm1hdEZsYWdzID0ge1xuICAgIEQ6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXREYXRlKCk7XG4gICAgfSxcbiAgICBERDogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXREYXRlKCkpO1xuICAgIH0sXG4gICAgRG86IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5Eb0ZuKGRhdGVPYmouZ2V0RGF0ZSgpKTtcbiAgICB9LFxuICAgIGQ6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXREYXkoKTtcbiAgICB9LFxuICAgIGRkOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldERheSgpKTtcbiAgICB9LFxuICAgIGRkZDogZnVuY3Rpb24gKGRhdGVPYmosIGkxOG4pIHtcbiAgICAgIHJldHVybiBpMThuLmRheU5hbWVzU2hvcnRbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBkZGRkOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgcmV0dXJuIGkxOG4uZGF5TmFtZXNbZGF0ZU9iai5nZXREYXkoKV07XG4gICAgfSxcbiAgICBNOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0TW9udGgoKSArIDE7XG4gICAgfSxcbiAgICBNTTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBwYWQoZGF0ZU9iai5nZXRNb250aCgpICsgMSk7XG4gICAgfSxcbiAgICBNTU06IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzU2hvcnRbZGF0ZU9iai5nZXRNb250aCgpXTtcbiAgICB9LFxuICAgIE1NTU06IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gaTE4bi5tb250aE5hbWVzW2RhdGVPYmouZ2V0TW9udGgoKV07XG4gICAgfSxcbiAgICBZWTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBTdHJpbmcoZGF0ZU9iai5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMik7XG4gICAgfSxcbiAgICBZWVlZOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEZ1bGxZZWFyKCksIDQpO1xuICAgIH0sXG4gICAgaDogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9LFxuICAgIGhoOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkgJSAxMiB8fCAxMik7XG4gICAgfSxcbiAgICBIOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKTtcbiAgICB9LFxuICAgIEhIOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldEhvdXJzKCkpO1xuICAgIH0sXG4gICAgbTogZnVuY3Rpb24gKGRhdGVPYmopIHtcbiAgICAgIHJldHVybiBkYXRlT2JqLmdldE1pbnV0ZXMoKTtcbiAgICB9LFxuICAgIG1tOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldE1pbnV0ZXMoKSk7XG4gICAgfSxcbiAgICBzOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0U2Vjb25kcygpO1xuICAgIH0sXG4gICAgc3M6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gcGFkKGRhdGVPYmouZ2V0U2Vjb25kcygpKTtcbiAgICB9LFxuICAgIFM6IGZ1bmN0aW9uIChkYXRlT2JqKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpIC8gMTAwKTtcbiAgICB9LFxuICAgIFNTOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChNYXRoLnJvdW5kKGRhdGVPYmouZ2V0TWlsbGlzZWNvbmRzKCkgLyAxMCksIDIpO1xuICAgIH0sXG4gICAgU1NTOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgcmV0dXJuIHBhZChkYXRlT2JqLmdldE1pbGxpc2Vjb25kcygpLCAzKTtcbiAgICB9LFxuICAgIGE6IGZ1bmN0aW9uIChkYXRlT2JqLCBpMThuKSB7XG4gICAgICByZXR1cm4gZGF0ZU9iai5nZXRIb3VycygpIDwgMTIgPyBpMThuLmFtUG1bMF0gOiBpMThuLmFtUG1bMV07XG4gICAgfSxcbiAgICBBOiBmdW5jdGlvbiAoZGF0ZU9iaiwgaTE4bikge1xuICAgICAgcmV0dXJuIGRhdGVPYmouZ2V0SG91cnMoKSA8IDEyID8gaTE4bi5hbVBtWzBdLnRvVXBwZXJDYXNlKCkgOiBpMThuLmFtUG1bMV0udG9VcHBlckNhc2UoKTtcbiAgICB9LFxuICAgIFpaOiBmdW5jdGlvbiAoZGF0ZU9iaikge1xuICAgICAgdmFyIG8gPSBkYXRlT2JqLmdldFRpbWV6b25lT2Zmc2V0KCk7XG4gICAgICByZXR1cm4gKG8gPiAwID8gJy0nIDogJysnKSArIHBhZChNYXRoLmZsb29yKE1hdGguYWJzKG8pIC8gNjApICogMTAwICsgTWF0aC5hYnMobykgJSA2MCwgNCk7XG4gICAgfVxuICB9O1xuICB2YXIgcGFyc2VGbGFncyA9IHtcbiAgICBEOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5kYXkgPSB2O1xuICAgIH1dLFxuICAgIERvOiBbbmV3IFJlZ0V4cCh0d29EaWdpdHMuc291cmNlICsgd29yZC5zb3VyY2UpLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5kYXkgPSBwYXJzZUludCh2LCAxMCk7XG4gICAgfV0sXG4gICAgTTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubW9udGggPSB2IC0gMTtcbiAgICB9XSxcbiAgICBZWTogW3R3b0RpZ2l0cywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIHZhciBkYSA9IG5ldyBEYXRlKCksXG4gICAgICAgICAgY2VudCA9ICsoJycgKyBkYS5nZXRGdWxsWWVhcigpKS5zdWJzdHIoMCwgMik7XG4gICAgICBkLnllYXIgPSAnJyArICh2ID4gNjggPyBjZW50IC0gMSA6IGNlbnQpICsgdjtcbiAgICB9XSxcbiAgICBoOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5ob3VyID0gdjtcbiAgICB9XSxcbiAgICBtOiBbdHdvRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5taW51dGUgPSB2O1xuICAgIH1dLFxuICAgIHM6IFt0d29EaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLnNlY29uZCA9IHY7XG4gICAgfV0sXG4gICAgWVlZWTogW2ZvdXJEaWdpdHMsIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLnllYXIgPSB2O1xuICAgIH1dLFxuICAgIFM6IFsvXFxkLywgZnVuY3Rpb24gKGQsIHYpIHtcbiAgICAgIGQubWlsbGlzZWNvbmQgPSB2ICogMTAwO1xuICAgIH1dLFxuICAgIFNTOiBbL1xcZHsyfS8sIGZ1bmN0aW9uIChkLCB2KSB7XG4gICAgICBkLm1pbGxpc2Vjb25kID0gdiAqIDEwO1xuICAgIH1dLFxuICAgIFNTUzogW3RocmVlRGlnaXRzLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgZC5taWxsaXNlY29uZCA9IHY7XG4gICAgfV0sXG4gICAgZDogW3R3b0RpZ2l0cywgbm9vcF0sXG4gICAgZGRkOiBbd29yZCwgbm9vcF0sXG4gICAgTU1NOiBbd29yZCwgbW9udGhVcGRhdGUoJ21vbnRoTmFtZXNTaG9ydCcpXSxcbiAgICBNTU1NOiBbd29yZCwgbW9udGhVcGRhdGUoJ21vbnRoTmFtZXMnKV0sXG4gICAgYTogW3dvcmQsIGZ1bmN0aW9uIChkLCB2LCBpMThuKSB7XG4gICAgICB2YXIgdmFsID0gdi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICBpZiAodmFsID09PSBpMThuLmFtUG1bMF0pIHtcbiAgICAgICAgZC5pc1BtID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZhbCA9PT0gaTE4bi5hbVBtWzFdKSB7XG4gICAgICAgIGQuaXNQbSA9IHRydWU7XG4gICAgICB9XG4gICAgfV0sXG4gICAgWlo6IFsvKFtcXCtcXC1dXFxkXFxkOj9cXGRcXGR8WikvLCBmdW5jdGlvbiAoZCwgdikge1xuICAgICAgaWYgKHYgPT09ICdaJykgdiA9ICcrMDA6MDAnO1xuICAgICAgdmFyIHBhcnRzID0gKHYgKyAnJykubWF0Y2goLyhbXFwrXFwtXXxcXGRcXGQpL2dpKSxcbiAgICAgICAgICBtaW51dGVzO1xuXG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyBwYXJzZUludChwYXJ0c1syXSwgMTApO1xuICAgICAgICBkLnRpbWV6b25lT2Zmc2V0ID0gcGFydHNbMF0gPT09ICcrJyA/IG1pbnV0ZXMgOiAtbWludXRlcztcbiAgICAgIH1cbiAgICB9XVxuICB9O1xuICBwYXJzZUZsYWdzLmRkID0gcGFyc2VGbGFncy5kO1xuICBwYXJzZUZsYWdzLmRkZGQgPSBwYXJzZUZsYWdzLmRkZDtcbiAgcGFyc2VGbGFncy5ERCA9IHBhcnNlRmxhZ3MuRDtcbiAgcGFyc2VGbGFncy5tbSA9IHBhcnNlRmxhZ3MubTtcbiAgcGFyc2VGbGFncy5oaCA9IHBhcnNlRmxhZ3MuSCA9IHBhcnNlRmxhZ3MuSEggPSBwYXJzZUZsYWdzLmg7XG4gIHBhcnNlRmxhZ3MuTU0gPSBwYXJzZUZsYWdzLk07XG4gIHBhcnNlRmxhZ3Muc3MgPSBwYXJzZUZsYWdzLnM7XG4gIHBhcnNlRmxhZ3MuQSA9IHBhcnNlRmxhZ3MuYTsgLy8gU29tZSBjb21tb24gZm9ybWF0IHN0cmluZ3NcblxuICBmZWNoYS5tYXNrcyA9IHtcbiAgICBkZWZhdWx0OiAnZGRkIE1NTSBERCBZWVlZIEhIOm1tOnNzJyxcbiAgICBzaG9ydERhdGU6ICdNL0QvWVknLFxuICAgIG1lZGl1bURhdGU6ICdNTU0gRCwgWVlZWScsXG4gICAgbG9uZ0RhdGU6ICdNTU1NIEQsIFlZWVknLFxuICAgIGZ1bGxEYXRlOiAnZGRkZCwgTU1NTSBELCBZWVlZJyxcbiAgICBzaG9ydFRpbWU6ICdISDptbScsXG4gICAgbWVkaXVtVGltZTogJ0hIOm1tOnNzJyxcbiAgICBsb25nVGltZTogJ0hIOm1tOnNzLlNTUydcbiAgfTtcbiAgLyoqKlxuICAgKiBGb3JtYXQgYSBkYXRlXG4gICAqIEBtZXRob2QgZm9ybWF0XG4gICAqIEBwYXJhbSB7RGF0ZXxudW1iZXJ9IGRhdGVPYmpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hc2sgRm9ybWF0IG9mIHRoZSBkYXRlLCBpLmUuICdtbS1kZC15eScgb3IgJ3Nob3J0RGF0ZSdcbiAgICovXG5cbiAgZmVjaGEuZm9ybWF0ID0gZnVuY3Rpb24gKGRhdGVPYmosIG1hc2ssIGkxOG5TZXR0aW5ncykge1xuICAgIHZhciBpMThuID0gaTE4blNldHRpbmdzIHx8IGZlY2hhLmkxOG47XG5cbiAgICBpZiAodHlwZW9mIGRhdGVPYmogPT09ICdudW1iZXInKSB7XG4gICAgICBkYXRlT2JqID0gbmV3IERhdGUoZGF0ZU9iaik7XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRlT2JqKSAhPT0gJ1tvYmplY3QgRGF0ZV0nIHx8IGlzTmFOKGRhdGVPYmouZ2V0VGltZSgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIERhdGUgaW4gZmVjaGEuZm9ybWF0Jyk7XG4gICAgfVxuXG4gICAgbWFzayA9IGZlY2hhLm1hc2tzW21hc2tdIHx8IG1hc2sgfHwgZmVjaGEubWFza3NbJ2RlZmF1bHQnXTtcbiAgICB2YXIgbGl0ZXJhbHMgPSBbXTsgLy8gTWFrZSBsaXRlcmFscyBpbmFjdGl2ZSBieSByZXBsYWNpbmcgdGhlbSB3aXRoID8/XG5cbiAgICBtYXNrID0gbWFzay5yZXBsYWNlKGxpdGVyYWwsIGZ1bmN0aW9uICgkMCwgJDEpIHtcbiAgICAgIGxpdGVyYWxzLnB1c2goJDEpO1xuICAgICAgcmV0dXJuICc/Pyc7XG4gICAgfSk7IC8vIEFwcGx5IGZvcm1hdHRpbmcgcnVsZXNcblxuICAgIG1hc2sgPSBtYXNrLnJlcGxhY2UodG9rZW4sIGZ1bmN0aW9uICgkMCkge1xuICAgICAgcmV0dXJuICQwIGluIGZvcm1hdEZsYWdzID8gZm9ybWF0RmxhZ3NbJDBdKGRhdGVPYmosIGkxOG4pIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSk7XG4gICAgfSk7IC8vIElubGluZSBsaXRlcmFsIHZhbHVlcyBiYWNrIGludG8gdGhlIGZvcm1hdHRlZCB2YWx1ZVxuXG4gICAgcmV0dXJuIG1hc2sucmVwbGFjZSgvXFw/XFw/L2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBsaXRlcmFscy5zaGlmdCgpO1xuICAgIH0pO1xuICB9O1xuICAvKipcbiAgICogUGFyc2UgYSBkYXRlIHN0cmluZyBpbnRvIGFuIG9iamVjdCwgY2hhbmdlcyAtIGludG8gL1xuICAgKiBAbWV0aG9kIHBhcnNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRlU3RyIERhdGUgc3RyaW5nXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgRGF0ZSBwYXJzZSBmb3JtYXRcbiAgICogQHJldHVybnMge0RhdGV8Ym9vbGVhbn1cbiAgICovXG5cblxuICBmZWNoYS5wYXJzZSA9IGZ1bmN0aW9uIChkYXRlU3RyLCBmb3JtYXQsIGkxOG5TZXR0aW5ncykge1xuICAgIHZhciBpMThuID0gaTE4blNldHRpbmdzIHx8IGZlY2hhLmkxOG47XG5cbiAgICBpZiAodHlwZW9mIGZvcm1hdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmb3JtYXQgaW4gZmVjaGEucGFyc2UnKTtcbiAgICB9XG5cbiAgICBmb3JtYXQgPSBmZWNoYS5tYXNrc1tmb3JtYXRdIHx8IGZvcm1hdDsgLy8gQXZvaWQgcmVndWxhciBleHByZXNzaW9uIGRlbmlhbCBvZiBzZXJ2aWNlLCBmYWlsIGVhcmx5IGZvciByZWFsbHkgbG9uZyBzdHJpbmdzXG4gICAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9SZWd1bGFyX2V4cHJlc3Npb25fRGVuaWFsX29mX1NlcnZpY2VfLV9SZURvU1xuXG4gICAgaWYgKGRhdGVTdHIubGVuZ3RoID4gMTAwMCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB2YXIgZGF0ZUluZm8gPSB7fTtcbiAgICBmb3JtYXQucmVwbGFjZSh0b2tlbiwgZnVuY3Rpb24gKCQwKSB7XG4gICAgICBpZiAocGFyc2VGbGFnc1skMF0pIHtcbiAgICAgICAgdmFyIGluZm8gPSBwYXJzZUZsYWdzWyQwXTtcbiAgICAgICAgdmFyIGluZGV4ID0gZGF0ZVN0ci5zZWFyY2goaW5mb1swXSk7XG5cbiAgICAgICAgaWYgKCF+aW5kZXgpIHtcbiAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGF0ZVN0ci5yZXBsYWNlKGluZm9bMF0sIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgIGluZm9bMV0oZGF0ZUluZm8sIHJlc3VsdCwgaTE4bik7XG4gICAgICAgICAgICBkYXRlU3RyID0gZGF0ZVN0ci5zdWJzdHIoaW5kZXggKyByZXN1bHQubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcnNlRmxhZ3NbJDBdID8gJycgOiAkMC5zbGljZSgxLCAkMC5sZW5ndGggLSAxKTtcbiAgICB9KTtcblxuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0b2RheSA9IG5ldyBEYXRlKCk7XG5cbiAgICBpZiAoZGF0ZUluZm8uaXNQbSA9PT0gdHJ1ZSAmJiBkYXRlSW5mby5ob3VyICE9IG51bGwgJiYgK2RhdGVJbmZvLmhvdXIgIT09IDEyKSB7XG4gICAgICBkYXRlSW5mby5ob3VyID0gK2RhdGVJbmZvLmhvdXIgKyAxMjtcbiAgICB9IGVsc2UgaWYgKGRhdGVJbmZvLmlzUG0gPT09IGZhbHNlICYmICtkYXRlSW5mby5ob3VyID09PSAxMikge1xuICAgICAgZGF0ZUluZm8uaG91ciA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGRhdGU7XG5cbiAgICBpZiAoZGF0ZUluZm8udGltZXpvbmVPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgZGF0ZUluZm8ubWludXRlID0gKyhkYXRlSW5mby5taW51dGUgfHwgMCkgLSArZGF0ZUluZm8udGltZXpvbmVPZmZzZXQ7XG4gICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMoZGF0ZUluZm8ueWVhciB8fCB0b2RheS5nZXRGdWxsWWVhcigpLCBkYXRlSW5mby5tb250aCB8fCAwLCBkYXRlSW5mby5kYXkgfHwgMSwgZGF0ZUluZm8uaG91ciB8fCAwLCBkYXRlSW5mby5taW51dGUgfHwgMCwgZGF0ZUluZm8uc2Vjb25kIHx8IDAsIGRhdGVJbmZvLm1pbGxpc2Vjb25kIHx8IDApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0ZSA9IG5ldyBEYXRlKGRhdGVJbmZvLnllYXIgfHwgdG9kYXkuZ2V0RnVsbFllYXIoKSwgZGF0ZUluZm8ubW9udGggfHwgMCwgZGF0ZUluZm8uZGF5IHx8IDEsIGRhdGVJbmZvLmhvdXIgfHwgMCwgZGF0ZUluZm8ubWludXRlIHx8IDAsIGRhdGVJbmZvLnNlY29uZCB8fCAwLCBkYXRlSW5mby5taWxsaXNlY29uZCB8fCAwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0ZTtcbiAgfTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblxuXG4gIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZmVjaGE7XG4gIH0gZWxzZSBpZiAodHJ1ZSkge1xuICAgICEoX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZmVjaGE7XG4gICAgfS5jYWxsKGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18sIGV4cG9ydHMsIG1vZHVsZSksXG5cdFx0XHRcdF9fV0VCUEFDS19BTURfREVGSU5FX1JFU1VMVF9fICE9PSB1bmRlZmluZWQgJiYgKG1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0FNRF9ERUZJTkVfUkVTVUxUX18pKTtcbiAgfSBlbHNlIHtcbiAgICBtYWluLmZlY2hhID0gZmVjaGE7XG4gIH1cbn0pKHRoaXMpO1xuXG4vKioqLyB9KSxcbi8qIDExOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgaXNUeXBlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG5cbnZhciBpc0RhdGUgPSBmdW5jdGlvbiBpc0RhdGUodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ0RhdGUnKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gaXNEYXRlO1xuXG4vKioqLyB9KSxcbi8qIDExOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR3VpZGVCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBBcmMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoQXJjLCBfR3VpZGVCYXNlKTtcblxuICBmdW5jdGlvbiBBcmMoKSB7XG4gICAgcmV0dXJuIF9HdWlkZUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEFyYy5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENmZygpIHtcbiAgICB0aGlzLnR5cGUgPSAnYXJjJztcbiAgICAvKipcbiAgICAgKiBzdGFydCBwb2ludFxuICAgICAqIEB0eXBlIHtBcnJheSB8IEZ1bmN0aW9ufVxuICAgICAqL1xuXG4gICAgdGhpcy5zdGFydCA9IFtdO1xuICAgIC8qKlxuICAgICAqIGVuZCBwb2ludFxuICAgICAqIEB0eXBlIHtBcnJheSB8IEZ1bmN0aW9ufVxuICAgICAqL1xuXG4gICAgdGhpcy5lbmQgPSBbXTtcbiAgICAvKipcbiAgICAgKiBzdHlsZSBjb25maWd1cmF0aW9uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cblxuICAgIHRoaXMuc3R5bGUgPSB7XG4gICAgICBzdHJva2U6ICcjOTk5JyxcbiAgICAgIGxpbmVXaWR0aDogMVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBzdGFydCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5zdGFydCk7XG4gICAgdmFyIGVuZCA9IHNlbGYucGFyc2VQb2ludChjb29yZCwgc2VsZi5lbmQpO1xuXG4gICAgaWYgKCFzdGFydCB8fCAhZW5kKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNvb3JkQ2VudGVyID0gY29vcmQuY2VudGVyO1xuICAgIHZhciByYWRpdXMgPSBNYXRoLnNxcnQoKHN0YXJ0LnggLSBjb29yZENlbnRlci54KSAqIChzdGFydC54IC0gY29vcmRDZW50ZXIueCkgKyAoc3RhcnQueSAtIGNvb3JkQ2VudGVyLnkpICogKHN0YXJ0LnkgLSBjb29yZENlbnRlci55KSk7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSBNYXRoLmF0YW4yKHN0YXJ0LnkgLSBjb29yZENlbnRlci55LCBzdGFydC54IC0gY29vcmRDZW50ZXIueCk7XG4gICAgdmFyIGVuZEFuZ2xlID0gTWF0aC5hdGFuMihlbmQueSAtIGNvb3JkQ2VudGVyLnksIGVuZC54IC0gY29vcmRDZW50ZXIueCk7XG4gICAgdmFyIHNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdhcmMnLCB7XG4gICAgICBjbGFzc05hbWU6ICdndWlkZS1hcmMnLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogY29vcmRDZW50ZXIueCxcbiAgICAgICAgeTogY29vcmRDZW50ZXIueSxcbiAgICAgICAgcjogcmFkaXVzLFxuICAgICAgICBzdGFydEFuZ2xlOiBzdGFydEFuZ2xlLFxuICAgICAgICBlbmRBbmdsZTogZW5kQW5nbGVcbiAgICAgIH0sIHNlbGYuc3R5bGUpXG4gICAgfSk7XG4gICAgc2VsZi5lbGVtZW50ID0gc2hhcGU7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBBcmM7XG59KEd1aWRlQmFzZSk7XG5cbkd1aWRlQmFzZS5BcmMgPSBBcmM7XG5tb2R1bGUuZXhwb3J0cyA9IEFyYztcblxuLyoqKi8gfSksXG4vKiAxMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEd1aWRlQmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5mdW5jdGlvbiBnZXRPZmZzZXRGcm9tQWxpZ24oYWxpZ25YLCBhbGlnblksIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gIGlmIChhbGlnblggPT09ICdsZWZ0JyAmJiBhbGlnblkgPT09ICd0b3AnKSB7XG4gICAgcmVzdWx0WzBdID0gMDtcbiAgICByZXN1bHRbMV0gPSAwO1xuICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ3JpZ2h0JyAmJiBhbGlnblkgPT09ICd0b3AnKSB7XG4gICAgcmVzdWx0WzBdID0gLXdpZHRoO1xuICAgIHJlc3VsdFsxXSA9IDA7XG4gIH0gZWxzZSBpZiAoYWxpZ25YID09PSAnbGVmdCcgJiYgYWxpZ25ZID09PSAnYm90dG9tJykge1xuICAgIHJlc3VsdFswXSA9IDA7XG4gICAgcmVzdWx0WzFdID0gTWF0aC5mbG9vcigtaGVpZ2h0KTtcbiAgfSBlbHNlIGlmIChhbGlnblggPT09ICdyaWdodCcgJiYgYWxpZ25ZID09PSAnYm90dG9tJykge1xuICAgIHJlc3VsdFswXSA9IE1hdGguZmxvb3IoLXdpZHRoKTtcbiAgICByZXN1bHRbMV0gPSBNYXRoLmZsb29yKC1oZWlnaHQpO1xuICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ3JpZ2h0JyAmJiBhbGlnblkgPT09ICdtaWRkbGUnKSB7XG4gICAgcmVzdWx0WzBdID0gTWF0aC5mbG9vcigtd2lkdGgpO1xuICAgIHJlc3VsdFsxXSA9IE1hdGguZmxvb3IoLWhlaWdodCAvIDIpO1xuICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ2xlZnQnICYmIGFsaWduWSA9PT0gJ21pZGRsZScpIHtcbiAgICByZXN1bHRbMF0gPSAwO1xuICAgIHJlc3VsdFsxXSA9IE1hdGguZmxvb3IoLWhlaWdodCAvIDIpO1xuICB9IGVsc2UgaWYgKGFsaWduWCA9PT0gJ2NlbnRlcicgJiYgYWxpZ25ZID09PSAnYm90dG9tJykge1xuICAgIHJlc3VsdFswXSA9IE1hdGguZmxvb3IoLXdpZHRoIC8gMik7XG4gICAgcmVzdWx0WzFdID0gTWF0aC5mbG9vcigtaGVpZ2h0KTtcbiAgfSBlbHNlIGlmIChhbGlnblggPT09ICdjZW50ZXInICYmIGFsaWduWSA9PT0gJ3RvcCcpIHtcbiAgICByZXN1bHRbMF0gPSBNYXRoLmZsb29yKC13aWR0aCAvIDIpO1xuICAgIHJlc3VsdFsxXSA9IDA7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0WzBdID0gTWF0aC5mbG9vcigtd2lkdGggLyAyKTtcbiAgICByZXN1bHRbMV0gPSBNYXRoLmZsb29yKC1oZWlnaHQgLyAyKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1vZGlmeUNTUyhET00sIENTUykge1xuICBmb3IgKHZhciBrZXkgaW4gQ1NTKSB7XG4gICAgaWYgKENTUy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBET00uc3R5bGVba2V5XSA9IENTU1trZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBET007XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURvbShzdHIpIHtcbiAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBzdHIgPSBzdHIucmVwbGFjZSgvKF5cXHMqKXwoXFxzKiQpL2csICcnKTtcbiAgY29udGFpbmVyLmlubmVySFRNTCA9ICcnICsgc3RyO1xuICByZXR1cm4gY29udGFpbmVyLmNoaWxkTm9kZXNbMF07XG59XG5cbnZhciBIdG1sID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3VpZGVCYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKEh0bWwsIF9HdWlkZUJhc2UpO1xuXG4gIGZ1bmN0aW9uIEh0bWwoKSB7XG4gICAgcmV0dXJuIF9HdWlkZUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEh0bWwucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ2h0bWwnO1xuICAgIC8qKlxuICAgICAqIGRvbSBwb3NpdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3QgfCBBcnJheX1cbiAgICAgKi9cblxuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgIC8qKlxuICAgICAgKiBhbGlnbm1lbnQgZm9yIGhvcml6b250YWwgZGlyZWN0aW9u77yMY2FuIGJlICdsZWZ0JywnY2VudGVyJywncmlnaHQnXG4gICAgICAqIEB0eXBlIHtTdHJpbmd9XG4gICAgICAqL1xuXG4gICAgdGhpcy5hbGlnblggPSAnY2VudGVyJztcbiAgICAvKipcbiAgICAgICogYWxpZ25tZW50IGZvciB2ZXJ0aWNhbCBkaXJlY3Rpb27vvIxjYW4gYmUgJ3RvcCcsICdtaWRkbGUnLCAnYm90dG9tJ1xuICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgKi9cblxuICAgIHRoaXMuYWxpZ25ZID0gJ21pZGRsZSc7XG4gICAgLyoqXG4gICAgICAqIG9mZnNldCBmb3IgaG9yaXpvbnRhbCBkaXJlY3Rpb25cbiAgICAgICogQHR5cGUge051bWJlcn1cbiAgICAgICovXG5cbiAgICB0aGlzLm9mZnNldFggPSBudWxsO1xuICAgIC8qKlxuICAgICAgKiBvZmZzZXQgZm9yIHZlcnRpY2FsIGRpcmVjdGlvblxuICAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAgKi9cblxuICAgIHRoaXMub2Zmc2V0WSA9IG51bGw7XG4gICAgLyoqXG4gICAgKiB0aGUgaHRtbCBzdHJpbmdcbiAgICAqQHR5cGUge1N0cmluZyB8IEZ1bmN0aW9ufVxuICAgICovXG5cbiAgICB0aGlzLmh0bWwgPSBudWxsO1xuICB9IC8vIG92ZXJyaWRlIHBhaW50XG4gIDtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkLCBjb250YWluZXIpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBvc2l0aW9uID0gc2VsZi5wYXJzZVBvaW50KGNvb3JkLCBzZWxmLnBvc2l0aW9uKTtcblxuICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbXlOb2RlID0gY3JlYXRlRG9tKHNlbGYuaHRtbCk7XG4gICAgbXlOb2RlID0gbW9kaWZ5Q1NTKG15Tm9kZSwge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3A6IE1hdGguZmxvb3IocG9zaXRpb24ueSkgKyAncHgnLFxuICAgICAgbGVmdDogTWF0aC5mbG9vcihwb3NpdGlvbi54KSArICdweCcsXG4gICAgICB2aXNpYmlsaXR5OiAnaGlkZGVuJ1xuICAgIH0pO1xuICAgIHZhciBjYW52YXNEb20gPSBjb250YWluZXIuZ2V0KCdjYW52YXMnKS5nZXQoJ2VsJyk7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBjYW52YXNEb20ucGFyZW50Tm9kZTtcbiAgICBwYXJlbnROb2RlID0gbW9kaWZ5Q1NTKHBhcmVudE5vZGUsIHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgfSk7XG4gICAgdmFyIHdyYXBwZXJOb2RlID0gY3JlYXRlRG9tKCc8ZGl2IGNsYXNzPVwiZ3VpZGVXYXBwZXJcIiBzdHlsZT1cInBvc2l0aW9uOiBhYnNvbHV0ZTt0b3A6IDA7IGxlZnQ6IDA7XCI+PC9kaXY+Jyk7XG4gICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh3cmFwcGVyTm9kZSk7XG4gICAgd3JhcHBlck5vZGUuYXBwZW5kQ2hpbGQobXlOb2RlKTtcbiAgICB2YXIgY2FudmFzT2Zmc2V0VG9wID0gY2FudmFzRG9tLm9mZnNldFRvcDtcbiAgICB2YXIgY2FudmFzT2Zmc2V0TGVmdCA9IGNhbnZhc0RvbS5vZmZzZXRMZWZ0O1xuICAgIHZhciBhbGlnblggPSBzZWxmLmFsaWduWCxcbiAgICAgICAgYWxpZ25ZID0gc2VsZi5hbGlnblksXG4gICAgICAgIG9mZnNldFggPSBzZWxmLm9mZnNldFgsXG4gICAgICAgIG9mZnNldFkgPSBzZWxmLm9mZnNldFk7XG4gICAgdmFyIHdpZHRoID0gVXRpbC5nZXRXaWR0aChteU5vZGUpO1xuICAgIHZhciBoZWlnaHQgPSBVdGlsLmdldEhlaWdodChteU5vZGUpO1xuICAgIHZhciBuZXdPZmZzZXQgPSBnZXRPZmZzZXRGcm9tQWxpZ24oYWxpZ25YLCBhbGlnblksIHdpZHRoLCBoZWlnaHQpO1xuICAgIHBvc2l0aW9uLnggPSBwb3NpdGlvbi54ICsgbmV3T2Zmc2V0WzBdICsgY2FudmFzT2Zmc2V0TGVmdDtcbiAgICBwb3NpdGlvbi55ID0gcG9zaXRpb24ueSArIG5ld09mZnNldFsxXSArIGNhbnZhc09mZnNldFRvcDtcblxuICAgIGlmIChvZmZzZXRYKSB7XG4gICAgICBwb3NpdGlvbi54ICs9IG9mZnNldFg7XG4gICAgfVxuXG4gICAgaWYgKG9mZnNldFkpIHtcbiAgICAgIHBvc2l0aW9uLnkgKz0gb2Zmc2V0WTtcbiAgICB9XG5cbiAgICBtb2RpZnlDU1MobXlOb2RlLCB7XG4gICAgICB0b3A6IE1hdGguZmxvb3IocG9zaXRpb24ueSkgKyAncHgnLFxuICAgICAgbGVmdDogTWF0aC5mbG9vcihwb3NpdGlvbi54KSArICdweCcsXG4gICAgICB2aXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICB9KTtcbiAgICBzZWxmLmVsZW1lbnQgPSB3cmFwcGVyTm9kZTtcbiAgfTtcblxuICBfcHJvdG8ucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuICAgIGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlICYmIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgfTtcblxuICByZXR1cm4gSHRtbDtcbn0oR3VpZGVCYXNlKTtcblxuR3VpZGVCYXNlLkh0bWwgPSBIdG1sO1xubW9kdWxlLmV4cG9ydHMgPSBIdG1sO1xuXG4vKioqLyB9KSxcbi8qIDEyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR3VpZGVCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBMaW5lID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3VpZGVCYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKExpbmUsIF9HdWlkZUJhc2UpO1xuXG4gIGZ1bmN0aW9uIExpbmUoKSB7XG4gICAgcmV0dXJuIF9HdWlkZUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IExpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ2xpbmUnO1xuICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICB0aGlzLmVuZCA9IFtdO1xuICAgIHRoaXMuc3R5bGUgPSB7XG4gICAgICBzdHJva2U6ICcjMDAwJyxcbiAgICAgIGxpbmVXaWR0aDogMVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIHBvaW50c1swXSA9IHRoaXMucGFyc2VQb2ludChjb29yZCwgdGhpcy5zdGFydCk7XG4gICAgcG9pbnRzWzFdID0gdGhpcy5wYXJzZVBvaW50KGNvb3JkLCB0aGlzLmVuZCk7XG5cbiAgICBpZiAoIXBvaW50c1swXSB8fCAhcG9pbnRzWzFdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdMaW5lJywge1xuICAgICAgY2xhc3NOYW1lOiAnZ3VpZGUtbGluZScsXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB4MTogcG9pbnRzWzBdLngsXG4gICAgICAgIHkxOiBwb2ludHNbMF0ueSxcbiAgICAgICAgeDI6IHBvaW50c1sxXS54LFxuICAgICAgICB5MjogcG9pbnRzWzFdLnlcbiAgICAgIH0sIHRoaXMuc3R5bGUpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50ID0gc2hhcGU7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBMaW5lO1xufShHdWlkZUJhc2UpO1xuXG5HdWlkZUJhc2UuTGluZSA9IExpbmU7XG5tb2R1bGUuZXhwb3J0cyA9IExpbmU7XG5cbi8qKiovIH0pLFxuLyogMTIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHdWlkZUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFJlY3QgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKF9HdWlkZUJhc2UpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVjdCwgX0d1aWRlQmFzZSk7XG5cbiAgZnVuY3Rpb24gUmVjdCgpIHtcbiAgICByZXR1cm4gX0d1aWRlQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUmVjdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9pbml0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIF9pbml0RGVmYXVsdENmZygpIHtcbiAgICB0aGlzLnR5cGUgPSAncmVjdCc7XG4gICAgdGhpcy5zdGFydCA9IFtdO1xuICAgIHRoaXMuZW5kID0gW107XG4gICAgdGhpcy5zdHlsZSA9IHtcbiAgICAgIGZpbGw6ICcjQ0NEN0VCJyxcbiAgICAgIG9wYWNpdHk6IDAuNFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wYXJzZVBvaW50KGNvb3JkLCB0aGlzLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gdGhpcy5wYXJzZVBvaW50KGNvb3JkLCB0aGlzLmVuZCk7XG5cbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICBjbGFzc05hbWU6ICdndWlkZS1yZWN0JyxcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IE1hdGgubWluKHN0YXJ0LngsIGVuZC54KSxcbiAgICAgICAgeTogTWF0aC5taW4oc3RhcnQueSwgZW5kLnkpLFxuICAgICAgICB3aWR0aDogTWF0aC5hYnMoZW5kLnggLSBzdGFydC54KSxcbiAgICAgICAgaGVpZ2h0OiBNYXRoLmFicyhzdGFydC55IC0gZW5kLnkpXG4gICAgICB9LCB0aGlzLnN0eWxlKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudCA9IHNoYXBlO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcblxuICByZXR1cm4gUmVjdDtcbn0oR3VpZGVCYXNlKTtcblxuR3VpZGVCYXNlLlJlY3QgPSBSZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBSZWN0O1xuXG4vKioqLyB9KSxcbi8qIDEyMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgR3VpZGVCYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbnZhciBUZXh0ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3VpZGVCYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFRleHQsIF9HdWlkZUJhc2UpO1xuXG4gIGZ1bmN0aW9uIFRleHQoKSB7XG4gICAgcmV0dXJuIF9HdWlkZUJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRleHQucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ3RleHQnO1xuICAgIC8qKlxuICAgICAqIHRoZSBwb3NpdGlvbiBvZiB0ZXh0XG4gICAgICogQHR5cGUge0Z1bmN0aW9uIHwgQXJyYXl9XG4gICAgICovXG5cbiAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICAvKipcbiAgICAgKiB0aGUgZGlzcGxheSBjb250ZW50XG4gICAgICogQHR5cGUge1N0cmluZ31cbiAgICAgKi9cblxuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgLyoqXG4gICAgICogc3R5bGUgY29uZmlndXJhdGlvbiBmb3IgdGV4dFxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG5cbiAgICB0aGlzLnN0eWxlID0ge1xuICAgICAgZmlsbDogJyMwMDAnXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBvZmZzZXQgb2YgaG9yaXpvbnRhbCBkaXJlY3Rpb25cbiAgICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgICAqL1xuXG4gICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICAvKipcbiAgICAgKiBvZmZzZXQgb2YgdmVydGljYWwgZGlyZWN0aW9uXG4gICAgICogQHR5cGUge051bWJlcn1cbiAgICAgKi9cblxuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wb3NpdGlvbjtcbiAgICB2YXIgcG9pbnQgPSB0aGlzLnBhcnNlUG9pbnQoY29vcmQsIHBvc2l0aW9uKTtcblxuICAgIGlmICghcG9pbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudCxcbiAgICAgICAgc3R5bGUgPSB0aGlzLnN0eWxlLFxuICAgICAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZO1xuXG4gICAgaWYgKG9mZnNldFgpIHtcbiAgICAgIHBvaW50LnggKz0gb2Zmc2V0WDtcbiAgICB9XG5cbiAgICBpZiAob2Zmc2V0WSkge1xuICAgICAgcG9pbnQueSArPSBvZmZzZXRZO1xuICAgIH1cblxuICAgIHZhciBzaGFwZSA9IGNvbnRhaW5lci5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2d1aWRlLXRleHQnLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgdGV4dDogY29udGVudFxuICAgICAgfSwgc3R5bGUpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50ID0gc2hhcGU7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBUZXh0O1xufShHdWlkZUJhc2UpO1xuXG5HdWlkZUJhc2UuVGV4dCA9IFRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IFRleHQ7XG5cbi8qKiovIH0pLFxuLyogMTI0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHdWlkZUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFRhZyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoX0d1aWRlQmFzZSkge1xuICBfaW5oZXJpdHNMb29zZShUYWcsIF9HdWlkZUJhc2UpO1xuXG4gIGZ1bmN0aW9uIFRhZygpIHtcbiAgICByZXR1cm4gX0d1aWRlQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGFnLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX2luaXREZWZhdWx0Q2ZnID0gZnVuY3Rpb24gX2luaXREZWZhdWx0Q2ZnKCkge1xuICAgIHRoaXMudHlwZSA9ICd0YWcnO1xuICAgIHRoaXMucG9zaXRpb24gPSBudWxsO1xuICAgIHRoaXMuY29udGVudCA9IG51bGw7XG4gICAgdGhpcy5kaXJlY3QgPSAndGwnO1xuICAgIHRoaXMuYXV0b0FkanVzdCA9IHRydWU7XG4gICAgdGhpcy5vZmZzZXRYID0gMDtcbiAgICB0aGlzLm9mZnNldFkgPSAwO1xuICAgIHRoaXMuc2lkZSA9IDQ7XG4gICAgdGhpcy5iYWNrZ3JvdW5kID0ge1xuICAgICAgcGFkZGluZzogNSxcbiAgICAgIHJhZGl1czogMixcbiAgICAgIGZpbGw6ICcjMTg5MEZGJ1xuICAgIH07XG4gICAgdGhpcy50ZXh0U3R5bGUgPSB7XG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgIH07XG4gICAgdGhpcy53aXRoUG9pbnQgPSB0cnVlO1xuICAgIHRoaXMucG9pbnRTdHlsZSA9IHtcbiAgICAgIGZpbGw6ICcjMTg5MEZGJyxcbiAgICAgIHI6IDMsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzdHJva2U6ICcjZmZmJ1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLl9nZXREaXJlY3QgPSBmdW5jdGlvbiBfZ2V0RGlyZWN0KGNvbnRhaW5lciwgcG9pbnQsIHRhZ1dpZHRoLCB0YWdIZWlnaHQpIHtcbiAgICB2YXIgZGlyZWN0ID0gdGhpcy5kaXJlY3Q7XG4gICAgdmFyIHNpZGUgPSB0aGlzLnNpZGU7XG4gICAgdmFyIGNhbnZhcyA9IGNvbnRhaW5lci5nZXQoJ2NhbnZhcycpO1xuICAgIHZhciBjbGllbnRXaWR0aCA9IGNhbnZhcy5nZXQoJ3dpZHRoJyk7XG4gICAgdmFyIGNsaWVudEhlaWdodCA9IGNhbnZhcy5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciB4ID0gcG9pbnQueCxcbiAgICAgICAgeSA9IHBvaW50Lnk7XG4gICAgdmFyIHZlcnRpY2FsID0gZGlyZWN0WzBdO1xuICAgIHZhciBob3Jpem9udGFsID0gZGlyZWN0WzFdOyAvLyBhZGp1c3QgZm9yIHZlcnRpY2FsIGRpcmVjdGlvblxuXG4gICAgaWYgKHZlcnRpY2FsID09PSAndCcgJiYgeSAtIHNpZGUgLSB0YWdIZWlnaHQgPCAwKSB7XG4gICAgICB2ZXJ0aWNhbCA9ICdiJztcbiAgICB9IGVsc2UgaWYgKHZlcnRpY2FsID09PSAnYicgJiYgeSArIHNpZGUgKyB0YWdIZWlnaHQgPiBjbGllbnRIZWlnaHQpIHtcbiAgICAgIHZlcnRpY2FsID0gJ3QnO1xuICAgIH0gLy8gYWRqdXN0IGZvciBob3Jpem9udGFsIGRpcmVjdGlvblxuXG5cbiAgICB2YXIgZGlmZiA9IHZlcnRpY2FsID09PSAnYycgPyBzaWRlIDogMDtcblxuICAgIGlmIChob3Jpem9udGFsID09PSAnbCcgJiYgeCAtIGRpZmYgLSB0YWdXaWR0aCA8IDApIHtcbiAgICAgIGhvcml6b250YWwgPSAncic7XG4gICAgfSBlbHNlIGlmIChob3Jpem9udGFsID09PSAncicgJiYgeCArIGRpZmYgKyB0YWdXaWR0aCA+IGNsaWVudFdpZHRoKSB7XG4gICAgICBob3Jpem9udGFsID0gJ2wnO1xuICAgIH0gZWxzZSBpZiAoaG9yaXpvbnRhbCA9PT0gJ2MnKSB7XG4gICAgICBpZiAodGFnV2lkdGggLyAyICsgeCArIGRpZmYgPiBjbGllbnRXaWR0aCkge1xuICAgICAgICBob3Jpem9udGFsID0gJ2wnO1xuICAgICAgfSBlbHNlIGlmICh4IC0gdGFnV2lkdGggLyAyIC0gZGlmZiA8IDApIHtcbiAgICAgICAgaG9yaXpvbnRhbCA9ICdyJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkaXJlY3QgPSB2ZXJ0aWNhbCArIGhvcml6b250YWw7XG4gICAgcmV0dXJuIGRpcmVjdDtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGNvb3JkLCBjb250YWluZXIpIHtcbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnBhcnNlUG9pbnQoY29vcmQsIHRoaXMucG9zaXRpb24pO1xuXG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICBiYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kLFxuICAgICAgICB0ZXh0U3R5bGUgPSB0aGlzLnRleHRTdHlsZTtcbiAgICB2YXIgc2hhcGVzID0gW107XG4gICAgdmFyIHdyYXBwZXJDb250YWluZXIgPSBjb250YWluZXIuYWRkR3JvdXAoe1xuICAgICAgY2xhc3NOYW1lOiAnZ3VpZGUtdGFnJ1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMud2l0aFBvaW50KSB7XG4gICAgICB2YXIgcG9pbnRTaGFwZSA9IHdyYXBwZXJDb250YWluZXIuYWRkU2hhcGUoJ0NpcmNsZScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZ3VpZGUtdGFnLXBvaW50JyxcbiAgICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgICB4OiBwb3NpdGlvbi54LFxuICAgICAgICAgIHk6IHBvc2l0aW9uLnlcbiAgICAgICAgfSwgdGhpcy5wb2ludFN0eWxlKVxuICAgICAgfSk7XG4gICAgICBzaGFwZXMucHVzaChwb2ludFNoYXBlKTtcbiAgICB9XG5cbiAgICB2YXIgdGFnQ29udGFpbmVyID0gd3JhcHBlckNvbnRhaW5lci5hZGRHcm91cCgpOyAvLyBjcmVhdGUgYSB0ZXh0IHNoYXBlXG5cbiAgICB2YXIgdGFnVGV4dCA9IHRhZ0NvbnRhaW5lci5hZGRTaGFwZSgndGV4dCcsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2d1aWRlLXRhZy10ZXh0JyxcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDAsXG4gICAgICAgIHRleHQ6IGNvbnRlbnRcbiAgICAgIH0sIHRleHRTdHlsZSlcbiAgICB9KTtcbiAgICBzaGFwZXMucHVzaCh0YWdUZXh0KTsgLy8gY3JlYXRlIGJhY2tncm91bmQgYm94XG5cbiAgICB2YXIgdGV4dEJCb3ggPSB0YWdUZXh0LmdldEJCb3goKTtcbiAgICB2YXIgcGFkZGluZyA9IFV0aWwucGFyc2VQYWRkaW5nKGJhY2tncm91bmQucGFkZGluZyk7XG4gICAgdmFyIHRhZ1dpZHRoID0gdGV4dEJCb3gud2lkdGggKyBwYWRkaW5nWzFdICsgcGFkZGluZ1szXTtcbiAgICB2YXIgdGFnSGVpZ2h0ID0gdGV4dEJCb3guaGVpZ2h0ICsgcGFkZGluZ1swXSArIHBhZGRpbmdbMl07XG4gICAgdmFyIHlNaW4gPSB0ZXh0QkJveC5taW5ZIC0gcGFkZGluZ1swXTtcbiAgICB2YXIgeE1pbiA9IHRleHRCQm94Lm1pblggLSBwYWRkaW5nWzNdO1xuICAgIHZhciB0YWdCZyA9IHRhZ0NvbnRhaW5lci5hZGRTaGFwZSgncmVjdCcsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2d1aWRlLXRhZy1iZycsXG4gICAgICB6SW5kZXg6IC0xLFxuICAgICAgYXR0cnM6IFV0aWwubWl4KHtcbiAgICAgICAgeDogeE1pbixcbiAgICAgICAgeTogeU1pbixcbiAgICAgICAgd2lkdGg6IHRhZ1dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRhZ0hlaWdodFxuICAgICAgfSwgYmFja2dyb3VuZClcbiAgICB9KTtcbiAgICBzaGFwZXMucHVzaCh0YWdCZyk7XG4gICAgdmFyIGRpcmVjdCA9IHRoaXMuYXV0b0FkanVzdCA/IHRoaXMuX2dldERpcmVjdChjb250YWluZXIsIHBvc2l0aW9uLCB0YWdXaWR0aCwgdGFnSGVpZ2h0KSA6IHRoaXMuZGlyZWN0O1xuICAgIHZhciBzaWRlID0gdGhpcy5zaWRlO1xuICAgIHZhciB4ID0gcG9zaXRpb24ueCArIHRoaXMub2Zmc2V0WDtcbiAgICB2YXIgeSA9IHBvc2l0aW9uLnkgKyB0aGlzLm9mZnNldFk7XG4gICAgdmFyIGFycm93UG9pbnRzO1xuICAgIHZhciByYWRpdXMgPSBVdGlsLnBhcnNlUGFkZGluZyhiYWNrZ3JvdW5kLnJhZGl1cyk7XG5cbiAgICBpZiAoZGlyZWN0ID09PSAndGwnKSB7XG4gICAgICBhcnJvd1BvaW50cyA9IFt7XG4gICAgICAgIHg6IHRhZ1dpZHRoICsgeE1pbiAtIHNpZGUgLSAxLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyB5TWluIC0gMVxuICAgICAgfSwgLy8g6L+Z5LiqIDEg5piv5Li65LqG6Ziy5q2i5Ye6546w55m96L65XG4gICAgICB7XG4gICAgICAgIHg6IHRhZ1dpZHRoICsgeE1pbixcbiAgICAgICAgeTogdGFnSGVpZ2h0ICsgeU1pbiAtIDFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogdGFnV2lkdGggKyB4TWluLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyBzaWRlICsgeU1pblxuICAgICAgfV07XG4gICAgICByYWRpdXNbMl0gPSAwO1xuICAgICAgeCA9IHggLSB0YWdXaWR0aDtcbiAgICAgIHkgPSB5IC0gc2lkZSAtIHRhZ0hlaWdodDtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdCA9PT0gJ2NsJykge1xuICAgICAgYXJyb3dQb2ludHMgPSBbe1xuICAgICAgICB4OiB0YWdXaWR0aCArIHhNaW4gLSAxLFxuICAgICAgICB5OiAodGFnSGVpZ2h0IC0gc2lkZSkgLyAyICsgeU1pbiAtIDFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogdGFnV2lkdGggKyB4TWluIC0gMSxcbiAgICAgICAgeTogKHRhZ0hlaWdodCArIHNpZGUpIC8gMiArIHlNaW4gKyAxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHRhZ1dpZHRoICsgc2lkZSArIHhNaW4sXG4gICAgICAgIHk6IHRhZ0hlaWdodCAvIDIgKyB5TWluXG4gICAgICB9XTtcbiAgICAgIHggPSB4IC0gdGFnV2lkdGggLSBzaWRlO1xuICAgICAgeSA9IHkgLSB0YWdIZWlnaHQgLyAyO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0ID09PSAnYmwnKSB7XG4gICAgICBhcnJvd1BvaW50cyA9IFt7XG4gICAgICAgIHg6IHRhZ1dpZHRoICsgeE1pbixcbiAgICAgICAgeTogLXNpZGUgKyB5TWluXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHRhZ1dpZHRoICsgeE1pbiAtIHNpZGUgLSAxLFxuICAgICAgICB5OiB5TWluICsgMVxuICAgICAgfSwge1xuICAgICAgICB4OiB0YWdXaWR0aCArIHhNaW4sXG4gICAgICAgIHk6IHlNaW4gKyAxXG4gICAgICB9XTtcbiAgICAgIHJhZGl1c1sxXSA9IDA7XG4gICAgICB4ID0geCAtIHRhZ1dpZHRoO1xuICAgICAgeSA9IHkgKyBzaWRlO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0ID09PSAnYmMnKSB7XG4gICAgICBhcnJvd1BvaW50cyA9IFt7XG4gICAgICAgIHg6IHRhZ1dpZHRoIC8gMiArIHhNaW4sXG4gICAgICAgIHk6IC1zaWRlICsgeU1pblxuICAgICAgfSwge1xuICAgICAgICB4OiAodGFnV2lkdGggLSBzaWRlKSAvIDIgKyB4TWluIC0gMSxcbiAgICAgICAgeTogeU1pbiArIDFcbiAgICAgIH0sIHtcbiAgICAgICAgeDogKHRhZ1dpZHRoICsgc2lkZSkgLyAyICsgeE1pbiArIDEsXG4gICAgICAgIHk6IHlNaW4gKyAxXG4gICAgICB9XTtcbiAgICAgIHggPSB4IC0gdGFnV2lkdGggLyAyO1xuICAgICAgeSA9IHkgKyBzaWRlO1xuICAgIH0gZWxzZSBpZiAoZGlyZWN0ID09PSAnYnInKSB7XG4gICAgICBhcnJvd1BvaW50cyA9IFt7XG4gICAgICAgIHg6IHhNaW4sXG4gICAgICAgIHk6IHlNaW4gLSBzaWRlXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHhNaW4sXG4gICAgICAgIHk6IHlNaW4gKyAxXG4gICAgICB9LCB7XG4gICAgICAgIHg6IHhNaW4gKyBzaWRlICsgMSxcbiAgICAgICAgeTogeU1pbiArIDFcbiAgICAgIH1dO1xuICAgICAgcmFkaXVzWzBdID0gMDtcbiAgICAgIHkgPSB5ICsgc2lkZTtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdCA9PT0gJ2NyJykge1xuICAgICAgYXJyb3dQb2ludHMgPSBbe1xuICAgICAgICB4OiB4TWluIC0gc2lkZSxcbiAgICAgICAgeTogdGFnSGVpZ2h0IC8gMiArIHlNaW5cbiAgICAgIH0sIHtcbiAgICAgICAgeDogeE1pbiArIDEsXG4gICAgICAgIHk6ICh0YWdIZWlnaHQgLSBzaWRlKSAvIDIgKyB5TWluIC0gMVxuICAgICAgfSwge1xuICAgICAgICB4OiB4TWluICsgMSxcbiAgICAgICAgeTogKHRhZ0hlaWdodCArIHNpZGUpIC8gMiArIHlNaW4gKyAxXG4gICAgICB9XTtcbiAgICAgIHggPSB4ICsgc2lkZTtcbiAgICAgIHkgPSB5IC0gdGFnSGVpZ2h0IC8gMjtcbiAgICB9IGVsc2UgaWYgKGRpcmVjdCA9PT0gJ3RyJykge1xuICAgICAgYXJyb3dQb2ludHMgPSBbe1xuICAgICAgICB4OiB4TWluLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyBzaWRlICsgeU1pblxuICAgICAgfSwge1xuICAgICAgICB4OiB4TWluLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyB5TWluIC0gMVxuICAgICAgfSwge1xuICAgICAgICB4OiBzaWRlICsgeE1pbiArIDEsXG4gICAgICAgIHk6IHRhZ0hlaWdodCArIHlNaW4gLSAxXG4gICAgICB9XTtcbiAgICAgIHJhZGl1c1szXSA9IDA7XG4gICAgICB5ID0geSAtIHRhZ0hlaWdodCAtIHNpZGU7XG4gICAgfSBlbHNlIGlmIChkaXJlY3QgPT09ICd0YycpIHtcbiAgICAgIGFycm93UG9pbnRzID0gW3tcbiAgICAgICAgeDogKHRhZ1dpZHRoIC0gc2lkZSkgLyAyICsgeE1pbiAtIDEsXG4gICAgICAgIHk6IHRhZ0hlaWdodCArIHlNaW4gLSAxXG4gICAgICB9LCB7XG4gICAgICAgIHg6ICh0YWdXaWR0aCArIHNpZGUpIC8gMiArIHhNaW4gKyAxLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyB5TWluIC0gMVxuICAgICAgfSwge1xuICAgICAgICB4OiB0YWdXaWR0aCAvIDIgKyB4TWluLFxuICAgICAgICB5OiB0YWdIZWlnaHQgKyBzaWRlICsgeU1pblxuICAgICAgfV07XG4gICAgICB4ID0geCAtIHRhZ1dpZHRoIC8gMjtcbiAgICAgIHkgPSB5IC0gdGFnSGVpZ2h0IC0gc2lkZTtcbiAgICB9XG5cbiAgICB2YXIgc2lkZVNoYXBlID0gdGFnQ29udGFpbmVyLmFkZFNoYXBlKCdQb2x5Z29uJywge1xuICAgICAgY2xhc3NOYW1lOiAnZ3VpZGUtdGFnLXNpZGUnLFxuICAgICAgekluZGV4OiAwLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgcG9pbnRzOiBhcnJvd1BvaW50cyxcbiAgICAgICAgZmlsbDogYmFja2dyb3VuZC5maWxsXG4gICAgICB9XG4gICAgfSk7XG4gICAgc2hhcGVzLnB1c2goc2lkZVNoYXBlKTtcbiAgICB0YWdCZy5hdHRyKCdyYWRpdXMnLCByYWRpdXMpO1xuICAgIHRhZ0NvbnRhaW5lci5tb3ZlVG8oeCAtIHhNaW4sIHkgLSB5TWluKTtcbiAgICB0YWdDb250YWluZXIuc29ydCgpO1xuICAgIHRoaXMuZWxlbWVudCA9IHdyYXBwZXJDb250YWluZXI7XG4gICAgcmV0dXJuIHNoYXBlcztcbiAgfTtcblxuICByZXR1cm4gVGFnO1xufShHdWlkZUJhc2UpO1xuXG5HdWlkZUJhc2UuVGFnID0gVGFnO1xubW9kdWxlLmV4cG9ydHMgPSBUYWc7XG5cbi8qKiovIH0pLFxuLyogMTI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbmZ1bmN0aW9uIF9pbmhlcml0c0xvb3NlKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcy5wcm90b3R5cGUpOyBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzczsgc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHdWlkZUJhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxudmFyIFBvaW50ID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uIChfR3VpZGVCYXNlKSB7XG4gIF9pbmhlcml0c0xvb3NlKFBvaW50LCBfR3VpZGVCYXNlKTtcblxuICBmdW5jdGlvbiBQb2ludCgpIHtcbiAgICByZXR1cm4gX0d1aWRlQmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gIH1cblxuICB2YXIgX3Byb3RvID0gUG9pbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by5faW5pdERlZmF1bHRDZmcgPSBmdW5jdGlvbiBfaW5pdERlZmF1bHRDZmcoKSB7XG4gICAgdGhpcy50eXBlID0gJ3BvaW50JztcbiAgICB0aGlzLnBvc2l0aW9uID0gbnVsbDtcbiAgICB0aGlzLm9mZnNldFggPSAwO1xuICAgIHRoaXMub2Zmc2V0WSA9IDA7XG4gICAgdGhpcy5zdHlsZSA9IHtcbiAgICAgIGZpbGw6ICcjMTg5MEZGJyxcbiAgICAgIHI6IDMsXG4gICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICBzdHJva2U6ICcjZmZmJ1xuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihjb29yZCwgY29udGFpbmVyKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5wYXJzZVBvaW50KGNvb3JkLCB0aGlzLnBvc2l0aW9uKTtcbiAgICBpZiAoIXBvc2l0aW9uKSByZXR1cm4gbnVsbDtcbiAgICB2YXIgc2hhcGUgPSBjb250YWluZXIuYWRkU2hhcGUoJ0NpcmNsZScsIHtcbiAgICAgIGNsYXNzTmFtZTogJ2d1aWRlLXBvaW50JyxcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggKyB0aGlzLm9mZnNldFgsXG4gICAgICAgIHk6IHBvc2l0aW9uLnkgKyB0aGlzLm9mZnNldFlcbiAgICAgIH0sIHRoaXMuc3R5bGUpXG4gICAgfSk7XG4gICAgdGhpcy5lbGVtZW50ID0gc2hhcGU7XG4gICAgcmV0dXJuIHNoYXBlO1xuICB9O1xuXG4gIHJldHVybiBQb2ludDtcbn0oR3VpZGVCYXNlKTtcblxuR3VpZGVCYXNlLlBvaW50ID0gUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cyA9IFBvaW50O1xuXG4vKioqLyB9KSxcbi8qIDEyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHbG9iYWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG52YXIgVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI3KTtcblxudmFyIEhlbHBlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpOyAvLyBSZWdpc3RlciB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uIGZvciBUb29sdGlwXG5cblxuR2xvYmFsLnRvb2x0aXAgPSBVdGlsLmRlZXBNaXgoe1xuICB0cmlnZ2VyT246IFsndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnXSxcbiAgLy8gdHJpZ2dlck9mZjogJ3RvdWNoZW5kJyxcbiAgYWx3YXlzU2hvdzogZmFsc2UsXG4gIHNob3dUaXRsZTogZmFsc2UsXG4gIHNob3dDcm9zc2hhaXJzOiBmYWxzZSxcbiAgY3Jvc3NoYWlyc1N0eWxlOiB7XG4gICAgc3Ryb2tlOiAncmdiYSgwLCAwLCAwLCAwLjI1KScsXG4gICAgbGluZVdpZHRoOiAxXG4gIH0sXG4gIHNob3dUb29sdGlwTWFya2VyOiB0cnVlLFxuICBiYWNrZ3JvdW5kOiB7XG4gICAgcmFkaXVzOiAxLFxuICAgIGZpbGw6ICdyZ2JhKDAsIDAsIDAsIDAuNjUpJyxcbiAgICBwYWRkaW5nOiBbMywgNV1cbiAgfSxcbiAgdGl0bGVTdHlsZToge1xuICAgIGZvbnRTaXplOiAxMixcbiAgICBmaWxsOiAnI2ZmZicsXG4gICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgIHRleHRCYXNlbGluZTogJ3RvcCdcbiAgfSxcbiAgbmFtZVN0eWxlOiB7XG4gICAgZm9udFNpemU6IDEyLFxuICAgIGZpbGw6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNjUpJyxcbiAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICB9LFxuICB2YWx1ZVN0eWxlOiB7XG4gICAgZm9udFNpemU6IDEyLFxuICAgIGZpbGw6ICcjZmZmJyxcbiAgICB0ZXh0QWxpZ246ICdzdGFydCcsXG4gICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICB9LFxuICBzaG93SXRlbU1hcmtlcjogdHJ1ZSxcbiAgaXRlbU1hcmtlclN0eWxlOiB7XG4gICAgcmFkaXVzOiAzLFxuICAgIHN5bWJvbDogJ2NpcmNsZScsXG4gICAgbGluZVdpZHRoOiAxLFxuICAgIHN0cm9rZTogJyNmZmYnXG4gIH0sXG4gIGxheW91dDogJ2hvcml6b250YWwnLFxuICBzbmFwOiBmYWxzZVxufSwgR2xvYmFsLnRvb2x0aXAgfHwge30pO1xuXG5mdW5jdGlvbiBfZ2V0VG9vbHRpcFZhbHVlU2NhbGUoZ2VvbSkge1xuICB2YXIgY29sb3JBdHRyID0gZ2VvbS5nZXRBdHRyKCdjb2xvcicpO1xuXG4gIGlmIChjb2xvckF0dHIpIHtcbiAgICB2YXIgY29sb3JTY2FsZSA9IGNvbG9yQXR0ci5nZXRTY2FsZShjb2xvckF0dHIudHlwZSk7XG5cbiAgICBpZiAoY29sb3JTY2FsZS5pc0xpbmVhcikge1xuICAgICAgcmV0dXJuIGNvbG9yU2NhbGU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHhTY2FsZSA9IGdlb20uZ2V0WFNjYWxlKCk7XG4gIHZhciB5U2NhbGUgPSBnZW9tLmdldFlTY2FsZSgpO1xuXG4gIGlmICh5U2NhbGUpIHtcbiAgICByZXR1cm4geVNjYWxlO1xuICB9XG5cbiAgcmV0dXJuIHhTY2FsZTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9vbHRpcE5hbWUoZ2VvbSwgb3JpZ2luKSB7XG4gIHZhciBuYW1lO1xuICB2YXIgbmFtZVNjYWxlO1xuXG4gIHZhciBncm91cFNjYWxlcyA9IGdlb20uX2dldEdyb3VwU2NhbGVzKCk7XG5cbiAgaWYgKGdyb3VwU2NhbGVzLmxlbmd0aCkge1xuICAgIFV0aWwuZWFjaChncm91cFNjYWxlcywgZnVuY3Rpb24gKHNjYWxlKSB7XG4gICAgICBuYW1lU2NhbGUgPSBzY2FsZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KTtcbiAgfVxuXG4gIGlmIChuYW1lU2NhbGUpIHtcbiAgICB2YXIgZmllbGQgPSBuYW1lU2NhbGUuZmllbGQ7XG4gICAgbmFtZSA9IG5hbWVTY2FsZS5nZXRUZXh0KG9yaWdpbltmaWVsZF0pO1xuICB9IGVsc2Uge1xuICAgIHZhciB2YWx1ZVNjYWxlID0gX2dldFRvb2x0aXBWYWx1ZVNjYWxlKGdlb20pO1xuXG4gICAgbmFtZSA9IHZhbHVlU2NhbGUuYWxpYXMgfHwgdmFsdWVTY2FsZS5maWVsZDtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuXG5mdW5jdGlvbiBnZXRUb29sdGlwVmFsdWUoZ2VvbSwgb3JpZ2luKSB7XG4gIHZhciBzY2FsZSA9IF9nZXRUb29sdGlwVmFsdWVTY2FsZShnZW9tKTtcblxuICByZXR1cm4gc2NhbGUuZ2V0VGV4dChvcmlnaW5bc2NhbGUuZmllbGRdKTtcbn1cblxuZnVuY3Rpb24gZ2V0VG9vbHRpcFRpdGxlKGdlb20sIG9yaWdpbikge1xuICB2YXIgcG9zaXRpb24gPSBnZW9tLmdldEF0dHIoJ3Bvc2l0aW9uJyk7XG4gIHZhciBmaWVsZCA9IHBvc2l0aW9uLmdldEZpZWxkcygpWzBdO1xuICB2YXIgc2NhbGUgPSBnZW9tLmdldCgnc2NhbGVzJylbZmllbGRdO1xuICByZXR1cm4gc2NhbGUuZ2V0VGV4dChvcmlnaW5bc2NhbGUuZmllbGRdKTtcbn1cblxuZnVuY3Rpb24gX2luZGV4T2ZBcnJheShpdGVtcywgaXRlbSkge1xuICB2YXIgcnN0ID0gLTE7XG4gIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKHN1YiwgaW5kZXgpIHtcbiAgICBpZiAoc3ViLnRpdGxlID09PSBpdGVtLnRpdGxlICYmIHN1Yi5uYW1lID09PSBpdGVtLm5hbWUgJiYgc3ViLnZhbHVlID09PSBpdGVtLnZhbHVlICYmIHN1Yi5jb2xvciA9PT0gaXRlbS5jb2xvcikge1xuICAgICAgcnN0ID0gaW5kZXg7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJzdDtcbn1cblxuZnVuY3Rpb24gX3VuaXFJdGVtcyhpdGVtcykge1xuICB2YXIgdG1wID0gW107XG4gIFV0aWwuZWFjaChpdGVtcywgZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICB2YXIgaW5kZXggPSBfaW5kZXhPZkFycmF5KHRtcCwgaXRlbSk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICB0bXAucHVzaChpdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wW2luZGV4XSA9IGl0ZW07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHRtcDtcbn1cblxuZnVuY3Rpb24gaXNFcXVhbChhcnIxLCBhcnIyKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShhcnIxKSA9PT0gSlNPTi5zdHJpbmdpZnkoYXJyMik7XG59XG5cbnZhciBUb29sdGlwQ29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRvb2x0aXBDb250cm9sbGVyKGNmZykge1xuICAgIHRoaXMuZW5hYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmNmZyA9IHt9O1xuICAgIHRoaXMudG9vbHRpcCA9IG51bGw7XG4gICAgdGhpcy5jaGFydCA9IG51bGw7XG4gICAgdGhpcy50aW1lU3RhbXAgPSAwO1xuICAgIFV0aWwubWl4KHRoaXMsIGNmZyk7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLmNhbnZhc0RvbSA9IGNoYXJ0LmdldCgnY2FudmFzJykuZ2V0KCdlbCcpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFRvb2x0aXBDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uX3NldENyb3NzaGFpcnNDZmcgPSBmdW5jdGlvbiBfc2V0Q3Jvc3NoYWlyc0NmZygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNoYXJ0ID0gc2VsZi5jaGFydDtcbiAgICB2YXIgZGVmYXVsdENmZyA9IFV0aWwubWl4KHt9LCBHbG9iYWwudG9vbHRpcCk7XG4gICAgdmFyIGdlb21zID0gY2hhcnQuZ2V0KCdnZW9tcycpO1xuICAgIHZhciBzaGFwZXMgPSBbXTtcbiAgICBVdGlsLmVhY2goZ2VvbXMsIGZ1bmN0aW9uIChnZW9tKSB7XG4gICAgICB2YXIgdHlwZSA9IGdlb20uZ2V0KCd0eXBlJyk7XG5cbiAgICAgIGlmIChzaGFwZXMuaW5kZXhPZih0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgc2hhcGVzLnB1c2godHlwZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIGNvb3JkVHlwZSA9IGNoYXJ0LmdldCgnY29vcmQnKS50eXBlO1xuXG4gICAgaWYgKGdlb21zLmxlbmd0aCAmJiAoY29vcmRUeXBlID09PSAnY2FydGVzaWFuJyB8fCBjb29yZFR5cGUgPT09ICdyZWN0JykpIHtcbiAgICAgIGlmIChzaGFwZXMubGVuZ3RoID09PSAxICYmIFsnbGluZScsICdhcmVhJywgJ3BhdGgnLCAncG9pbnQnXS5pbmRleE9mKHNoYXBlc1swXSkgIT09IC0xKSB7XG4gICAgICAgIFV0aWwubWl4KGRlZmF1bHRDZmcsIHtcbiAgICAgICAgICBzaG93Q3Jvc3NoYWlyczogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdENmZztcbiAgfTtcblxuICBfcHJvdG8uX2dldE1heExlbmd0aCA9IGZ1bmN0aW9uIF9nZXRNYXhMZW5ndGgoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgX2NmZyA9IGNmZyxcbiAgICAgICAgbGF5b3V0ID0gX2NmZy5sYXlvdXQsXG4gICAgICAgIHBsb3RSYW5nZSA9IF9jZmcucGxvdFJhbmdlO1xuICAgIHJldHVybiBsYXlvdXQgPT09ICdob3Jpem9udGFsJyA/IHBsb3RSYW5nZS5ici54IC0gcGxvdFJhbmdlLmJsLnggOiBwbG90UmFuZ2UuYmwueSAtIHBsb3RSYW5nZS50ci55O1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKHNlbGYudG9vbHRpcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldCgnY2FudmFzJyk7XG4gICAgdmFyIGZyb250UGxvdCA9IGNoYXJ0LmdldCgnZnJvbnRQbG90JykuYWRkR3JvdXAoe1xuICAgICAgY2xhc3NOYW1lOiAndG9vbHRpcENvbnRhaW5lcicsXG4gICAgICB6SW5kZXg6IDEwXG4gICAgfSk7XG4gICAgdmFyIGJhY2tQbG90ID0gY2hhcnQuZ2V0KCdiYWNrUGxvdCcpLmFkZEdyb3VwKHtcbiAgICAgIGNsYXNzTmFtZTogJ3Rvb2x0aXBDb250YWluZXInXG4gICAgfSk7XG4gICAgdmFyIHBsb3RSYW5nZSA9IGNoYXJ0LmdldCgncGxvdFJhbmdlJyk7XG4gICAgdmFyIGNvb3JkID0gY2hhcnQuZ2V0KCdjb29yZCcpO1xuXG4gICAgdmFyIGRlZmF1bHRDZmcgPSBzZWxmLl9zZXRDcm9zc2hhaXJzQ2ZnKCk7XG5cbiAgICB2YXIgY2ZnID0gc2VsZi5jZmc7IC8vIOmAmui/hyBjaGFydC50b29sdGlwKCkg5o6l5Y+j5Lyg5YWl55qEIHRvb2x0aXAg6YWN572u6aG5XG5cbiAgICB2YXIgdG9vbHRpcENmZyA9IFV0aWwuZGVlcE1peCh7XG4gICAgICBwbG90UmFuZ2U6IHBsb3RSYW5nZSxcbiAgICAgIGZyb250UGxvdDogZnJvbnRQbG90LFxuICAgICAgYmFja1Bsb3Q6IGJhY2tQbG90LFxuICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICBmaXhlZDogY29vcmQudHJhbnNwb3NlZCB8fCBjb29yZC5pc1BvbGFyXG4gICAgfSwgZGVmYXVsdENmZywgY2ZnKTsgLy8g5Yib5bu6IHRvb2x0aXAg5a6e5L6L6ZyA6KaB55qE6YWN572u77yM5LiN5bqU6K+l5L+u5pS5IHRoaXMuY2Zn77yM5Y2z55So5oi35Lyg5YWl55qE6YWN572uXG5cbiAgICB0b29sdGlwQ2ZnLm1heExlbmd0aCA9IHNlbGYuX2dldE1heExlbmd0aCh0b29sdGlwQ2ZnKTtcbiAgICB0aGlzLl90b29sdGlwQ2ZnID0gdG9vbHRpcENmZztcbiAgICB2YXIgdG9vbHRpcCA9IG5ldyBUb29sdGlwKHRvb2x0aXBDZmcpO1xuICAgIHNlbGYudG9vbHRpcCA9IHRvb2x0aXA7XG4gICAgc2VsZi5iaW5kRXZlbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdmFyIHRvb2x0aXAgPSB0aGlzLnRvb2x0aXA7XG4gICAgdG9vbHRpcCAmJiB0b29sdGlwLmRlc3Ryb3koKTtcbiAgICB0aGlzLnRvb2x0aXAgPSBudWxsO1xuICAgIHRoaXMucHJlUG9pbnQgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RBY3RpdmUgPSBudWxsO1xuICAgIHRoaXMudW5CaW5kRXZlbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRUb29sdGlwTWFya2VyU3R5bGUgPSBmdW5jdGlvbiBfZ2V0VG9vbHRpcE1hcmtlclN0eWxlKGNmZykge1xuICAgIGlmIChjZmcgPT09IHZvaWQgMCkge1xuICAgICAgY2ZnID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9jZmcyID0gY2ZnLFxuICAgICAgICB0eXBlID0gX2NmZzIudHlwZSxcbiAgICAgICAgaXRlbXMgPSBfY2ZnMi5pdGVtcztcbiAgICB2YXIgdG9vbHRpcENmZyA9IHRoaXMuX3Rvb2x0aXBDZmc7XG5cbiAgICBpZiAodHlwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICB2YXIgeDtcbiAgICAgIHZhciB5O1xuICAgICAgdmFyIHdpZHRoO1xuICAgICAgdmFyIGhlaWdodDtcbiAgICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG5cbiAgICAgIHZhciBfY2hhcnQkZ2V0ID0gY2hhcnQuZ2V0KCdwbG90UmFuZ2UnKSxcbiAgICAgICAgICB0bCA9IF9jaGFydCRnZXQudGwsXG4gICAgICAgICAgYnIgPSBfY2hhcnQkZ2V0LmJyO1xuXG4gICAgICB2YXIgY29vcmQgPSBjaGFydC5nZXQoJ2Nvb3JkJyk7XG4gICAgICB2YXIgZmlyc3RJdGVtID0gaXRlbXNbMF07XG4gICAgICB2YXIgbGFzdEl0ZW0gPSBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBpbnRlcnZhbFdpZHRoID0gZmlyc3RJdGVtLndpZHRoO1xuXG4gICAgICBpZiAoY29vcmQudHJhbnNwb3NlZCkge1xuICAgICAgICB4ID0gdGwueDtcbiAgICAgICAgeSA9IGxhc3RJdGVtLnkgLSBpbnRlcnZhbFdpZHRoICogMC43NTtcbiAgICAgICAgd2lkdGggPSBici54IC0gdGwueDtcbiAgICAgICAgaGVpZ2h0ID0gZmlyc3RJdGVtLnkgLSBsYXN0SXRlbS55ICsgMS41ICogaW50ZXJ2YWxXaWR0aDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSBmaXJzdEl0ZW0ueCAtIGludGVydmFsV2lkdGggKiAwLjc1O1xuICAgICAgICB5ID0gdGwueTtcbiAgICAgICAgd2lkdGggPSBsYXN0SXRlbS54IC0gZmlyc3RJdGVtLnggKyAxLjUgKiBpbnRlcnZhbFdpZHRoO1xuICAgICAgICBoZWlnaHQgPSBici55IC0gdGwueTtcbiAgICAgIH1cblxuICAgICAgY2ZnLnN0eWxlID0gVXRpbC5taXgoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICBmaWxsOiAnI0NDRDZFQycsXG4gICAgICAgIG9wYWNpdHk6IDAuM1xuICAgICAgfSwgdG9vbHRpcENmZy50b29sdGlwTWFya2VyU3R5bGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZmcuc3R5bGUgPSBVdGlsLm1peCh7XG4gICAgICAgIHJhZGl1czogNCxcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICBsaW5lV2lkdGg6IDJcbiAgICAgIH0sIHRvb2x0aXBDZmcudG9vbHRpcE1hcmtlclN0eWxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY2ZnO1xuICB9O1xuXG4gIF9wcm90by5fc2V0VG9vbHRpcCA9IGZ1bmN0aW9uIF9zZXRUb29sdGlwKHBvaW50LCBpdGVtcywgdG9vbHRpcE1hcmtlckNmZykge1xuICAgIGlmICh0b29sdGlwTWFya2VyQ2ZnID09PSB2b2lkIDApIHtcbiAgICAgIHRvb2x0aXBNYXJrZXJDZmcgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdEFjdGl2ZSA9IHRoaXMuX2xhc3RBY3RpdmU7XG4gICAgdmFyIHRvb2x0aXAgPSB0aGlzLnRvb2x0aXA7XG4gICAgdmFyIGNmZyA9IHRoaXMuX3Rvb2x0aXBDZmc7XG4gICAgaXRlbXMgPSBfdW5pcUl0ZW1zKGl0ZW1zKTtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIHZhciBjb29yZCA9IGNoYXJ0LmdldCgnY29vcmQnKTtcbiAgICB2YXIgeVNjYWxlID0gY2hhcnQuZ2V0WVNjYWxlcygpWzBdO1xuICAgIHZhciBzbmFwID0gY2ZnLnNuYXA7XG5cbiAgICBpZiAoc25hcCA9PT0gZmFsc2UgJiYgeVNjYWxlLmlzTGluZWFyKSB7XG4gICAgICB2YXIgaW52ZXJ0UG9pbnQgPSBjb29yZC5pbnZlcnRQb2ludChwb2ludCk7XG4gICAgICB2YXIgcGxvdCA9IGNoYXJ0LmdldCgncGxvdFJhbmdlJyk7XG4gICAgICB2YXIgdGlwO1xuICAgICAgdmFyIHBvcztcblxuICAgICAgaWYgKEhlbHBlci5pc1BvaW50SW5QbG90KHBvaW50LCBwbG90KSkge1xuICAgICAgICBpZiAoY29vcmQudHJhbnNwb3NlZCkge1xuICAgICAgICAgIHRpcCA9IHlTY2FsZS5pbnZlcnQoaW52ZXJ0UG9pbnQueCk7XG4gICAgICAgICAgcG9zID0gcG9pbnQueDtcbiAgICAgICAgICB0b29sdGlwLnNldFhUaXBDb250ZW50KHRpcCk7XG4gICAgICAgICAgdG9vbHRpcC5zZXRYVGlwUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICB0b29sdGlwLnNldFlDcm9zc2hhaXJQb3NpdGlvbihwb3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRpcCA9IHlTY2FsZS5pbnZlcnQoaW52ZXJ0UG9pbnQueSk7XG4gICAgICAgICAgcG9zID0gcG9pbnQueTtcbiAgICAgICAgICB0b29sdGlwLnNldFlUaXBDb250ZW50KHRpcCk7XG4gICAgICAgICAgdG9vbHRpcC5zZXRZVGlwUG9zaXRpb24ocG9zKTtcbiAgICAgICAgICB0b29sdGlwLnNldFhDcm9zc2hhaXJQb3NpdGlvbihwb3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNmZy5vblNob3cpIHtcbiAgICAgIGNmZy5vblNob3coe1xuICAgICAgICB4OiBwb2ludC54LFxuICAgICAgICB5OiBwb2ludC55LFxuICAgICAgICB0b29sdGlwOiB0b29sdGlwLFxuICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgIHRvb2x0aXBNYXJrZXJDZmc6IHRvb2x0aXBNYXJrZXJDZmdcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChpc0VxdWFsKGxhc3RBY3RpdmUsIGl0ZW1zKSkge1xuICAgICAgaWYgKHNuYXAgPT09IGZhbHNlICYmIChVdGlsLmRpcmVjdGlvbkVuYWJsZWQoY2ZnLmNyb3NzaGFpcnNUeXBlLCAneScpIHx8IGNmZy5zaG93WVRpcCkpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RBY3RpdmUgPSBpdGVtcztcbiAgICB2YXIgb25DaGFuZ2UgPSBjZmcub25DaGFuZ2U7XG5cbiAgICBpZiAob25DaGFuZ2UpIHtcbiAgICAgIG9uQ2hhbmdlKHtcbiAgICAgICAgeDogcG9pbnQueCxcbiAgICAgICAgeTogcG9pbnQueSxcbiAgICAgICAgdG9vbHRpcDogdG9vbHRpcCxcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICB0b29sdGlwTWFya2VyQ2ZnOiB0b29sdGlwTWFya2VyQ2ZnXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB2YXIgZmlyc3QgPSBpdGVtc1swXTtcbiAgICB2YXIgdGl0bGUgPSBmaXJzdC50aXRsZSB8fCBmaXJzdC5uYW1lO1xuICAgIHZhciB4VGlwUG9zWCA9IGZpcnN0Lng7XG5cbiAgICBpZiAoaXRlbXMubGVuZ3RoID4gMSkge1xuICAgICAgeFRpcFBvc1ggPSAoaXRlbXNbMF0ueCArIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLngpIC8gMjtcbiAgICB9XG5cbiAgICB0b29sdGlwLnNldENvbnRlbnQodGl0bGUsIGl0ZW1zLCBjb29yZC50cmFuc3Bvc2VkKTtcbiAgICB0b29sdGlwLnNldFBvc2l0aW9uKGl0ZW1zLCBwb2ludCk7XG5cbiAgICBpZiAoY29vcmQudHJhbnNwb3NlZCkge1xuICAgICAgdmFyIHlUaXBQb3NZID0gZmlyc3QueTtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgeVRpcFBvc1kgPSAoaXRlbXNbMF0ueSArIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnkpIC8gMjtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcC5zZXRZVGlwQ29udGVudCh0aXRsZSk7XG4gICAgICB0b29sdGlwLnNldFlUaXBQb3NpdGlvbih5VGlwUG9zWSk7XG4gICAgICB0b29sdGlwLnNldFhDcm9zc2hhaXJQb3NpdGlvbih5VGlwUG9zWSk7XG5cbiAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgIHRvb2x0aXAuc2V0WFRpcENvbnRlbnQoZmlyc3QudmFsdWUpO1xuICAgICAgICB0b29sdGlwLnNldFhUaXBQb3NpdGlvbih4VGlwUG9zWCk7XG4gICAgICAgIHRvb2x0aXAuc2V0WUNyb3NzaGFpclBvc2l0aW9uKHhUaXBQb3NYKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdG9vbHRpcC5zZXRYVGlwQ29udGVudCh0aXRsZSk7XG4gICAgICB0b29sdGlwLnNldFhUaXBQb3NpdGlvbih4VGlwUG9zWCk7XG4gICAgICB0b29sdGlwLnNldFlDcm9zc2hhaXJQb3NpdGlvbih4VGlwUG9zWCk7XG5cbiAgICAgIGlmIChzbmFwKSB7XG4gICAgICAgIHRvb2x0aXAuc2V0WVRpcENvbnRlbnQoZmlyc3QudmFsdWUpO1xuICAgICAgICB0b29sdGlwLnNldFlUaXBQb3NpdGlvbihmaXJzdC55KTtcbiAgICAgICAgdG9vbHRpcC5zZXRYQ3Jvc3NoYWlyUG9zaXRpb24oZmlyc3QueSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1hcmtlckl0ZW1zID0gdG9vbHRpcE1hcmtlckNmZy5pdGVtcztcblxuICAgIGlmIChjZmcuc2hvd1Rvb2x0aXBNYXJrZXIgJiYgbWFya2VySXRlbXMubGVuZ3RoKSB7XG4gICAgICB0b29sdGlwTWFya2VyQ2ZnID0gdGhpcy5fZ2V0VG9vbHRpcE1hcmtlclN0eWxlKHRvb2x0aXBNYXJrZXJDZmcpO1xuICAgICAgdG9vbHRpcC5zZXRNYXJrZXJzKHRvb2x0aXBNYXJrZXJDZmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b29sdGlwLmNsZWFyTWFya2VycygpO1xuICAgIH1cblxuICAgIHRvb2x0aXAuc2hvdygpO1xuICB9O1xuXG4gIF9wcm90by5zaG93VG9vbHRpcCA9IGZ1bmN0aW9uIHNob3dUb29sdGlwKHBvaW50KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIHRvb2x0aXBNYXJrZXJUeXBlO1xuICAgIHZhciB0b29sdGlwTWFya2VySXRlbXMgPSBbXTtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICB2YXIgY2ZnID0gc2VsZi5fdG9vbHRpcENmZztcbiAgICB2YXIgbWFya2VyO1xuXG4gICAgaWYgKGNmZy5zaG93SXRlbU1hcmtlcikge1xuICAgICAgbWFya2VyID0gY2ZnLml0ZW1NYXJrZXJTdHlsZTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbXMgPSBjaGFydC5nZXQoJ2dlb21zJyk7XG4gICAgdmFyIGNvb3JkID0gY2hhcnQuZ2V0KCdjb29yZCcpO1xuICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgIGlmIChnZW9tLmdldCgndmlzaWJsZScpKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2VvbS5nZXQoJ3R5cGUnKTtcbiAgICAgICAgdmFyIHJlY29yZHMgPSBnZW9tLmdldFNuYXBSZWNvcmRzKHBvaW50KTtcbiAgICAgICAgVXRpbC5lYWNoKHJlY29yZHMsIGZ1bmN0aW9uIChyZWNvcmQpIHtcbiAgICAgICAgICBpZiAocmVjb3JkLnggJiYgcmVjb3JkLnkpIHtcbiAgICAgICAgICAgIHZhciB4ID0gcmVjb3JkLngsXG4gICAgICAgICAgICAgICAgeSA9IHJlY29yZC55LFxuICAgICAgICAgICAgICAgIF9vcmlnaW4gPSByZWNvcmQuX29yaWdpbixcbiAgICAgICAgICAgICAgICBjb2xvciA9IHJlY29yZC5jb2xvcjtcbiAgICAgICAgICAgIHZhciB0b29sdGlwSXRlbSA9IHtcbiAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgeTogVXRpbC5pc0FycmF5KHkpID8geVsxXSA6IHksXG4gICAgICAgICAgICAgIGNvbG9yOiBjb2xvciB8fCBHbG9iYWwuZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgICBvcmlnaW46IF9vcmlnaW4sXG4gICAgICAgICAgICAgIG5hbWU6IGdldFRvb2x0aXBOYW1lKGdlb20sIF9vcmlnaW4pLFxuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VG9vbHRpcFZhbHVlKGdlb20sIF9vcmlnaW4pLFxuICAgICAgICAgICAgICB0aXRsZTogZ2V0VG9vbHRpcFRpdGxlKGdlb20sIF9vcmlnaW4pXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAobWFya2VyKSB7XG4gICAgICAgICAgICAgIHRvb2x0aXBJdGVtLm1hcmtlciA9IFV0aWwubWl4KHtcbiAgICAgICAgICAgICAgICBmaWxsOiBjb2xvciB8fCBHbG9iYWwuZGVmYXVsdENvbG9yXG4gICAgICAgICAgICAgIH0sIG1hcmtlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGl0ZW1zLnB1c2godG9vbHRpcEl0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoWydsaW5lJywgJ2FyZWEnLCAncGF0aCddLmluZGV4T2YodHlwZSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIHRvb2x0aXBNYXJrZXJUeXBlID0gJ2NpcmNsZSc7XG4gICAgICAgICAgICAgIHRvb2x0aXBNYXJrZXJJdGVtcy5wdXNoKHRvb2x0aXBJdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2ludGVydmFsJyAmJiAoY29vcmQudHlwZSA9PT0gJ2NhcnRlc2lhbicgfHwgY29vcmQudHlwZSA9PT0gJ3JlY3QnKSkge1xuICAgICAgICAgICAgICB0b29sdGlwTWFya2VyVHlwZSA9ICdyZWN0JztcbiAgICAgICAgICAgICAgdG9vbHRpcEl0ZW0ud2lkdGggPSBnZW9tLmdldFNpemUocmVjb3JkLl9vcmlnaW4pO1xuICAgICAgICAgICAgICB0b29sdGlwTWFya2VySXRlbXMucHVzaCh0b29sdGlwSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgIHZhciB0b29sdGlwTWFya2VyQ2ZnID0ge1xuICAgICAgICBpdGVtczogdG9vbHRpcE1hcmtlckl0ZW1zLFxuICAgICAgICB0eXBlOiB0b29sdGlwTWFya2VyVHlwZVxuICAgICAgfTtcblxuICAgICAgc2VsZi5fc2V0VG9vbHRpcChwb2ludCwgaXRlbXMsIHRvb2x0aXBNYXJrZXJDZmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZWxmLmhpZGVUb29sdGlwKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5oaWRlVG9vbHRpcCA9IGZ1bmN0aW9uIGhpZGVUb29sdGlwKCkge1xuICAgIHZhciBjZmcgPSB0aGlzLl90b29sdGlwQ2ZnO1xuICAgIHRoaXMuX2xhc3RBY3RpdmUgPSBudWxsO1xuICAgIHZhciB0b29sdGlwID0gdGhpcy50b29sdGlwO1xuXG4gICAgaWYgKHRvb2x0aXApIHtcbiAgICAgIHRvb2x0aXAuaGlkZSgpO1xuXG4gICAgICBpZiAoY2ZnLm9uSGlkZSkge1xuICAgICAgICBjZmcub25IaWRlKHtcbiAgICAgICAgICB0b29sdGlwOiB0b29sdGlwXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jaGFydC5nZXQoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLmRyYXcoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZVNob3dFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZVNob3dFdmVudChldikge1xuICAgIHZhciBjaGFydCA9IHRoaXMuY2hhcnQ7XG4gICAgaWYgKCF0aGlzLmVuYWJsZSB8fCBjaGFydC5nZXQoJ19jbG9zZVRvb2x0aXAnKSkgcmV0dXJuO1xuICAgIHZhciBwbG90ID0gY2hhcnQuZ2V0KCdwbG90UmFuZ2UnKTtcbiAgICB2YXIgcG9pbnQgPSBVdGlsLmNyZWF0ZUV2ZW50KGV2LCBjaGFydCk7XG5cbiAgICBpZiAoIUhlbHBlci5pc1BvaW50SW5QbG90KHBvaW50LCBwbG90KSAmJiAhdGhpcy5fdG9vbHRpcENmZy5hbHdheXNTaG93KSB7XG4gICAgICAvLyBub3QgaW4gY2hhcnQgcGxvdFxuICAgICAgdGhpcy5oaWRlVG9vbHRpcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBsYXN0VGltZVN0YW1wID0gdGhpcy50aW1lU3RhbXA7XG4gICAgdmFyIHRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuXG4gICAgaWYgKHRpbWVTdGFtcCAtIGxhc3RUaW1lU3RhbXAgPiAxNikge1xuICAgICAgdGhpcy5zaG93VG9vbHRpcChwb2ludCk7XG4gICAgICB0aGlzLnRpbWVTdGFtcCA9IHRpbWVTdGFtcDtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZUhpZGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUhpZGVFdmVudCgpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGlmICghdGhpcy5lbmFibGUgfHwgY2hhcnQuZ2V0KCdfY2xvc2VUb29sdGlwJykpIHJldHVybjtcbiAgICB0aGlzLmhpZGVUb29sdGlwKCk7XG4gIH07XG5cbiAgX3Byb3RvLmhhbmRsZURvY0V2ZW50ID0gZnVuY3Rpb24gaGFuZGxlRG9jRXZlbnQoZXYpIHtcbiAgICB2YXIgY2hhcnQgPSB0aGlzLmNoYXJ0O1xuICAgIGlmICghdGhpcy5lbmFibGUgfHwgY2hhcnQuZ2V0KCdfY2xvc2VUb29sdGlwJykpIHJldHVybjtcbiAgICB2YXIgY2FudmFzRG9tID0gdGhpcy5jYW52YXNEb207XG5cbiAgICBpZiAoZXYudGFyZ2V0ICE9PSBjYW52YXNEb20pIHtcbiAgICAgIHRoaXMuaGlkZVRvb2x0aXAoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLl9oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIF9oYW5kbGVFdmVudChtZXRob2ROYW1lLCBtZXRob2QsIGFjdGlvbikge1xuICAgIHZhciBjYW52YXNEb20gPSB0aGlzLmNhbnZhc0RvbTtcbiAgICBVdGlsLmVhY2goW10uY29uY2F0KG1ldGhvZE5hbWUpLCBmdW5jdGlvbiAoYU1ldGhvZCkge1xuICAgICAgaWYgKGFjdGlvbiA9PT0gJ2JpbmQnKSB7XG4gICAgICAgIFV0aWwuYWRkRXZlbnRMaXN0ZW5lcihjYW52YXNEb20sIGFNZXRob2QsIG1ldGhvZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVdGlsLnJlbW92ZUV2ZW50TGlzdGVuZXIoY2FudmFzRG9tLCBhTWV0aG9kLCBtZXRob2QpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIF9wcm90by5iaW5kRXZlbnRzID0gZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICB2YXIgY2ZnID0gdGhpcy5fdG9vbHRpcENmZztcbiAgICB2YXIgdHJpZ2dlck9uID0gY2ZnLnRyaWdnZXJPbixcbiAgICAgICAgdHJpZ2dlck9mZiA9IGNmZy50cmlnZ2VyT2ZmLFxuICAgICAgICBhbHdheXNTaG93ID0gY2ZnLmFsd2F5c1Nob3c7XG4gICAgdmFyIHNob3dNZXRob2QgPSBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnaGFuZGxlU2hvd0V2ZW50Jyk7XG4gICAgdmFyIGhpZGVNZXRob2QgPSBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnaGFuZGxlSGlkZUV2ZW50Jyk7XG4gICAgdHJpZ2dlck9uICYmIHRoaXMuX2hhbmRsZUV2ZW50KHRyaWdnZXJPbiwgc2hvd01ldGhvZCwgJ2JpbmQnKTtcbiAgICB0cmlnZ2VyT2ZmICYmIHRoaXMuX2hhbmRsZUV2ZW50KHRyaWdnZXJPZmYsIGhpZGVNZXRob2QsICdiaW5kJyk7IC8vIFRPRE86IOW9k+eUqOaIt+eCueWHuyBjYW52YXMg5aSW55qE5LqL5Lu25pe2IHRvb2x0aXAg5raI5aSxXG5cbiAgICBpZiAoIWFsd2F5c1Nob3cpIHtcbiAgICAgIHZhciBkb2NNZXRob2QgPSBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnaGFuZGxlRG9jRXZlbnQnKTtcbiAgICAgIFV0aWwuaXNCcm93c2VyICYmIFV0aWwuYWRkRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBkb2NNZXRob2QpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8udW5CaW5kRXZlbnRzID0gZnVuY3Rpb24gdW5CaW5kRXZlbnRzKCkge1xuICAgIHZhciBjZmcgPSB0aGlzLl90b29sdGlwQ2ZnO1xuICAgIHZhciB0cmlnZ2VyT24gPSBjZmcudHJpZ2dlck9uLFxuICAgICAgICB0cmlnZ2VyT2ZmID0gY2ZnLnRyaWdnZXJPZmYsXG4gICAgICAgIGFsd2F5c1Nob3cgPSBjZmcuYWx3YXlzU2hvdztcbiAgICB2YXIgc2hvd01ldGhvZCA9IFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdoYW5kbGVTaG93RXZlbnQnKTtcbiAgICB2YXIgaGlkZU1ldGhvZCA9IFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdoYW5kbGVIaWRlRXZlbnQnKTtcbiAgICB0cmlnZ2VyT24gJiYgdGhpcy5faGFuZGxlRXZlbnQodHJpZ2dlck9uLCBzaG93TWV0aG9kLCAndW5CaW5kJyk7XG4gICAgdHJpZ2dlck9mZiAmJiB0aGlzLl9oYW5kbGVFdmVudCh0cmlnZ2VyT2ZmLCBoaWRlTWV0aG9kLCAndW5CaW5kJyk7XG5cbiAgICBpZiAoIWFsd2F5c1Nob3cpIHtcbiAgICAgIHZhciBkb2NNZXRob2QgPSBVdGlsLmdldFdyYXBCZWhhdmlvcih0aGlzLCAnaGFuZGxlRG9jRXZlbnQnKTtcbiAgICAgIFV0aWwuaXNCcm93c2VyICYmIFV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihkb2N1bWVudCwgJ3RvdWNoc3RhcnQnLCBkb2NNZXRob2QpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcENvbnRyb2xsZXI7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpbml0OiBmdW5jdGlvbiBpbml0KGNoYXJ0KSB7XG4gICAgdmFyIHRvb2x0aXBDb250cm9sbGVyID0gbmV3IFRvb2x0aXBDb250cm9sbGVyKHtcbiAgICAgIGNoYXJ0OiBjaGFydFxuICAgIH0pO1xuICAgIGNoYXJ0LnNldCgndG9vbHRpcENvbnRyb2xsZXInLCB0b29sdGlwQ29udHJvbGxlcik7XG5cbiAgICBjaGFydC50b29sdGlwID0gZnVuY3Rpb24gKGVuYWJsZSwgY2ZnKSB7XG4gICAgICBpZiAoVXRpbC5pc09iamVjdChlbmFibGUpKSB7XG4gICAgICAgIGNmZyA9IGVuYWJsZTtcbiAgICAgICAgZW5hYmxlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdG9vbHRpcENvbnRyb2xsZXIuZW5hYmxlID0gZW5hYmxlO1xuXG4gICAgICBpZiAoY2ZnKSB7XG4gICAgICAgIHRvb2x0aXBDb250cm9sbGVyLmNmZyA9IGNmZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSxcbiAgYWZ0ZXJHZW9tRHJhdzogZnVuY3Rpb24gYWZ0ZXJHZW9tRHJhdyhjaGFydCkge1xuICAgIHZhciB0b29sdGlwQ29udHJvbGxlciA9IGNoYXJ0LmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcbiAgICB0b29sdGlwQ29udHJvbGxlci5yZW5kZXIoKTtcblxuICAgIGNoYXJ0LnNob3dUb29sdGlwID0gZnVuY3Rpb24gKHBvaW50KSB7XG4gICAgICB0b29sdGlwQ29udHJvbGxlci5zaG93VG9vbHRpcChwb2ludCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgY2hhcnQuaGlkZVRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB0b29sdGlwQ29udHJvbGxlci5oaWRlVG9vbHRpcCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSxcbiAgY2xlYXJJbm5lcjogZnVuY3Rpb24gY2xlYXJJbm5lcihjaGFydCkge1xuICAgIHZhciB0b29sdGlwQ29udHJvbGxlciA9IGNoYXJ0LmdldCgndG9vbHRpcENvbnRyb2xsZXInKTtcbiAgICB0b29sdGlwQ29udHJvbGxlci5jbGVhcigpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBNYXJrZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMCk7XG5cbnZhciBDb250YWluZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwMSk7XG5cbnZhciBUZXh0Qm94ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjgpO1xuXG52YXIgR0FQID0gNDtcbi8qKlxuICogVE9ET0xpc3TvvJpcbiAqIDEuIOenu+mZpCBmaXhlZCDlj4LmlbBcbiAqL1xuXG52YXIgVG9vbHRpcCA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIHZhciBfcHJvdG8gPSBUb29sdGlwLnByb3RvdHlwZTtcblxuICBfcHJvdG8uZ2V0RGVmYXVsdENmZyA9IGZ1bmN0aW9uIGdldERlZmF1bHRDZmcoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8qKlxuICAgICAgICogd2V0aGVyIHNob3cgdGhlIGNyb3NzaGFpcnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIHNob3dDcm9zc2hhaXJzOiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgc3R5bGUgZm9yIGNyb3NzaGFpcnNcbiAgICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICAgKi9cbiAgICAgIGNyb3NzaGFpcnNTdHlsZToge1xuICAgICAgICBzdHJva2U6ICdyZ2JhKDAsIDAsIDAsIDAuMjUpJyxcbiAgICAgICAgbGluZVdpZHRoOiAxXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHRoZSB0eXBlIG9mIGNyb3NzaGFpcnMsIG9wdGlvbmFsIHZhbHVlIGlzICd4JywgJ3knIG9yICd4eScsIGRlZmF1bHQgaXMgJ3knXG4gICAgICAgKi9cbiAgICAgIGNyb3NzaGFpcnNUeXBlOiAneScsXG5cbiAgICAgIC8qKlxuICAgICAgICogc2hvdyBvciBoaWRlIHRoZSB4IGF4aXMgdGlwXG4gICAgICAgKi9cbiAgICAgIHNob3dYVGlwOiBmYWxzZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBzaG93IG9yIGhpZGUgdGhlIHkgYXhpcyB0aXBcbiAgICAgICAqL1xuICAgICAgc2hvd1lUaXA6IGZhbHNlLFxuICAgICAgeFRpcDogbnVsbCxcbiAgICAgIHhUaXBCYWNrZ3JvdW5kOiB7XG4gICAgICAgIHJhZGl1czogMSxcbiAgICAgICAgZmlsbDogJ3JnYmEoMCwgMCwgMCwgMC42NSknLFxuICAgICAgICBwYWRkaW5nOiBbMywgNV1cbiAgICAgIH0sXG4gICAgICB5VGlwOiBudWxsLFxuICAgICAgeVRpcEJhY2tncm91bmQ6IHtcbiAgICAgICAgcmFkaXVzOiAxLFxuICAgICAgICBmaWxsOiAncmdiYSgwLCAwLCAwLCAwLjY1KScsXG4gICAgICAgIHBhZGRpbmc6IFszLCA1XVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiB0aGUgc3R5bGUgZm9yIHRvb2x0aXAgY29udGFpbmVyJ3MgYmFja2dyb3VuZFxuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgYmFja2dyb3VuZDogbnVsbCxcblxuICAgICAgLyoqXG4gICAgICAgKiBsYXlvdXQsIGNhbiBiZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsXG4gICAgICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgICAgICovXG4gICAgICBsYXlvdXQ6ICdob3Jpem9udGFsJyxcbiAgICAgIG9mZnNldFg6IDAsXG4gICAgICBvZmZzZXRZOiAwXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBUb29sdGlwKGNmZykge1xuICAgIFV0aWwuZGVlcE1peCh0aGlzLCB0aGlzLmdldERlZmF1bHRDZmcoKSwgY2ZnKTtcbiAgICB2YXIgZnJvbnRQbG90ID0gdGhpcy5mcm9udFBsb3QsXG4gICAgICAgIGN1c3RvbSA9IHRoaXMuY3VzdG9tO1xuXG4gICAgaWYgKCFjdXN0b20pIHtcbiAgICAgIC8vIGN1c3RvbSBtZWFucyB1c2VyIGRvIGN1c3RvbWl6ZVxuICAgICAgdmFyIGNvbnRhaW5lciA9IG5ldyBDb250YWluZXIoVXRpbC5taXgoe1xuICAgICAgICBwYXJlbnQ6IGZyb250UGxvdCxcbiAgICAgICAgekluZGV4OiAzXG4gICAgICB9LCBjZmcpKTtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgdmFyIGZpeGVkID0gdGhpcy5maXhlZCxcbiAgICAgICAgICBiYWNrZ3JvdW5kID0gdGhpcy5iYWNrZ3JvdW5kO1xuXG4gICAgICBpZiAoIWZpeGVkKSB7XG4gICAgICAgIHRoaXMudG9vbHRpcEFycm93ID0gZnJvbnRQbG90LmFkZFNoYXBlKCdQb2x5Z29uJywge1xuICAgICAgICAgIGNsYXNzTmFtZTogJ3Rvb2x0aXAtYXJyb3cnLFxuICAgICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICAgIHpJbmRleDogMixcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgICAgIH0sIGJhY2tncm91bmQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3dYVGlwKSB7XG4gICAgICB2YXIgeFRpcEJhY2tncm91bmQgPSB0aGlzLnhUaXBCYWNrZ3JvdW5kO1xuICAgICAgdmFyIHhUaXBCb3ggPSBuZXcgVGV4dEJveCh7XG4gICAgICAgIGNsYXNzTmFtZTogJ3hUaXAnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB4VGlwQmFja2dyb3VuZCxcbiAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZnJvbnRQbG90LmFkZCh4VGlwQm94LmNvbnRhaW5lcik7XG4gICAgICB0aGlzLnhUaXBCb3ggPSB4VGlwQm94O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3dZVGlwKSB7XG4gICAgICB2YXIgeVRpcEJhY2tncm91bmQgPSB0aGlzLnlUaXBCYWNrZ3JvdW5kO1xuICAgICAgdmFyIHlUaXBCb3ggPSBuZXcgVGV4dEJveCh7XG4gICAgICAgIGNsYXNzTmFtZTogJ3lUaXAnLFxuICAgICAgICBiYWNrZ3JvdW5kOiB5VGlwQmFja2dyb3VuZCxcbiAgICAgICAgdmlzaWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgICAgZnJvbnRQbG90LmFkZCh5VGlwQm94LmNvbnRhaW5lcik7XG4gICAgICB0aGlzLnlUaXBCb3ggPSB5VGlwQm94O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnNob3dDcm9zc2hhaXJzKSB7XG4gICAgICB0aGlzLl9yZW5kZXJDcm9zc2hhaXJzKCk7XG4gICAgfVxuXG4gICAgZnJvbnRQbG90LnNvcnQoKTtcbiAgfVxuXG4gIF9wcm90by5zZXRDb250ZW50ID0gZnVuY3Rpb24gc2V0Q29udGVudCh0aXRsZSwgaXRlbXMpIHtcbiAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuXG4gICAgaWYgKCF0aGlzLmN1c3RvbSkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnNldFRpdGxlKHRpdGxlKTtcbiAgICAgIGNvbnRhaW5lci5zZXRJdGVtcyhpdGVtcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zZXRZVGlwQ29udGVudCA9IGZ1bmN0aW9uIHNldFlUaXBDb250ZW50KHZhbCkge1xuICAgIHZhciB5VGlwID0gdGhpcy55VGlwO1xuXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbih5VGlwKSkge1xuICAgICAgdmFsID0geVRpcCh2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWwgPSBVdGlsLm1peCh7XG4gICAgICAgIHRleHQ6IHZhbFxuICAgICAgfSwgeVRpcCk7XG4gICAgfVxuXG4gICAgdGhpcy55VGlwQm94ICYmIHRoaXMueVRpcEJveC51cGRhdGVDb250ZW50KHZhbCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldFlUaXBQb3NpdGlvbiA9IGZ1bmN0aW9uIHNldFlUaXBQb3NpdGlvbihwb3MpIHtcbiAgICB2YXIgcGxvdFJhbmdlID0gdGhpcy5wbG90UmFuZ2U7XG4gICAgdmFyIGNyb3NzaGFpcnNTaGFwZVggPSB0aGlzLmNyb3NzaGFpcnNTaGFwZVg7XG5cbiAgICBpZiAodGhpcy5zaG93WVRpcCkge1xuICAgICAgdmFyIHlUaXBCb3ggPSB0aGlzLnlUaXBCb3g7XG4gICAgICB2YXIgeVRpcEhlaWdodCA9IHlUaXBCb3guZ2V0SGVpZ2h0KCk7XG4gICAgICB2YXIgeVRpcFdpZHRoID0geVRpcEJveC5nZXRXaWR0aCgpO1xuICAgICAgdmFyIHBvc1ggPSBwbG90UmFuZ2UudGwueCAtIHlUaXBXaWR0aDtcbiAgICAgIHZhciBwb3NZID0gcG9zIC0geVRpcEhlaWdodCAvIDI7XG5cbiAgICAgIGlmIChwb3NZIDw9IHBsb3RSYW5nZS50bC55KSB7XG4gICAgICAgIHBvc1kgPSBwbG90UmFuZ2UudGwueTtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc1kgKyB5VGlwSGVpZ2h0ID49IHBsb3RSYW5nZS5ici55KSB7XG4gICAgICAgIHBvc1kgPSBwbG90UmFuZ2UuYnIueSAtIHlUaXBIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NYIDwgMCkge1xuICAgICAgICBwb3NYID0gcGxvdFJhbmdlLnRsLng7XG4gICAgICAgIGNyb3NzaGFpcnNTaGFwZVggJiYgY3Jvc3NoYWlyc1NoYXBlWC5hdHRyKCd4MScsIHBsb3RSYW5nZS50bC54ICsgeVRpcFdpZHRoKTtcbiAgICAgIH1cblxuICAgICAgeVRpcEJveC51cGRhdGVQb3NpdGlvbihwb3NYLCBwb3NZKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLnNldFhUaXBDb250ZW50ID0gZnVuY3Rpb24gc2V0WFRpcENvbnRlbnQodmFsKSB7XG4gICAgdmFyIHhUaXAgPSB0aGlzLnhUaXA7XG5cbiAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHhUaXApKSB7XG4gICAgICB2YWwgPSB4VGlwKHZhbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbCA9IFV0aWwubWl4KHtcbiAgICAgICAgdGV4dDogdmFsXG4gICAgICB9LCB4VGlwKTtcbiAgICB9XG5cbiAgICB0aGlzLnhUaXBCb3ggJiYgdGhpcy54VGlwQm94LnVwZGF0ZUNvbnRlbnQodmFsKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0WFRpcFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0WFRpcFBvc2l0aW9uKHBvcykge1xuICAgIHZhciBzaG93WFRpcCA9IHRoaXMuc2hvd1hUaXAsXG4gICAgICAgIGNhbnZhcyA9IHRoaXMuY2FudmFzLFxuICAgICAgICBwbG90UmFuZ2UgPSB0aGlzLnBsb3RSYW5nZSxcbiAgICAgICAgeFRpcEJveCA9IHRoaXMueFRpcEJveCxcbiAgICAgICAgY3Jvc3NoYWlyc1NoYXBlWSA9IHRoaXMuY3Jvc3NoYWlyc1NoYXBlWTtcblxuICAgIGlmIChzaG93WFRpcCkge1xuICAgICAgLy8gY29uc3QgZWwgPSBjYW52YXMuZ2V0KCdlbCcpO1xuICAgICAgLy8gY29uc3QgY2FudmFzSGVpZ2h0ID0gVXRpbC5nZXRIZWlnaHQoZWwpO1xuICAgICAgdmFyIGNhbnZhc0hlaWdodCA9IGNhbnZhcy5nZXQoJ2hlaWdodCcpO1xuICAgICAgdmFyIHhUaXBXaWR0aCA9IHhUaXBCb3guZ2V0V2lkdGgoKTtcbiAgICAgIHZhciB4VGlwSGVpZ2h0ID0geFRpcEJveC5nZXRIZWlnaHQoKTtcbiAgICAgIHZhciBwb3NYID0gcG9zIC0geFRpcFdpZHRoIC8gMjtcbiAgICAgIHZhciBwb3NZID0gcGxvdFJhbmdlLmJyLnk7XG5cbiAgICAgIGlmIChwb3NYIDw9IHBsb3RSYW5nZS50bC54KSB7XG4gICAgICAgIHBvc1ggPSBwbG90UmFuZ2UudGwueDtcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc1ggKyB4VGlwV2lkdGggPj0gcGxvdFJhbmdlLnRyLngpIHtcbiAgICAgICAgcG9zWCA9IHBsb3RSYW5nZS50ci54IC0geFRpcFdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FudmFzSGVpZ2h0IC0gcG9zWSA8IHhUaXBIZWlnaHQpIHtcbiAgICAgICAgcG9zWSAtPSB4VGlwSGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB4VGlwQm94LnVwZGF0ZVBvc2l0aW9uKHBvc1gsIHBvc1kpO1xuICAgICAgY3Jvc3NoYWlyc1NoYXBlWSAmJiBjcm9zc2hhaXJzU2hhcGVZLmF0dHIoJ3kxJywgcG9zWSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5zZXRYQ3Jvc3NoYWlyUG9zaXRpb24gPSBmdW5jdGlvbiBzZXRYQ3Jvc3NoYWlyUG9zaXRpb24ocG9zKSB7XG4gICAgdGhpcy5jcm9zc2hhaXJzU2hhcGVYICYmIHRoaXMuY3Jvc3NoYWlyc1NoYXBlWC5tb3ZlVG8oMCwgcG9zKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0WUNyb3NzaGFpclBvc2l0aW9uID0gZnVuY3Rpb24gc2V0WUNyb3NzaGFpclBvc2l0aW9uKHBvcykge1xuICAgIHRoaXMuY3Jvc3NoYWlyc1NoYXBlWSAmJiB0aGlzLmNyb3NzaGFpcnNTaGFwZVkubW92ZVRvKHBvcywgMCk7XG4gIH07XG5cbiAgX3Byb3RvLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oaXRlbXMpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXIsXG4gICAgICAgIHBsb3RSYW5nZSA9IHRoaXMucGxvdFJhbmdlLFxuICAgICAgICBvZmZzZXRYID0gdGhpcy5vZmZzZXRYLFxuICAgICAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgICAgICBmaXhlZCA9IHRoaXMuZml4ZWQsXG4gICAgICAgIHRvb2x0aXBBcnJvdyA9IHRoaXMudG9vbHRpcEFycm93O1xuXG4gICAgaWYgKCFjb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY29udGFpbmVyQkJveCA9IGNvbnRhaW5lci5jb250YWluZXIuZ2V0QkJveCgpO1xuICAgIHZhciBtaW5YID0gY29udGFpbmVyQkJveC5taW5YLFxuICAgICAgICBtaW5ZID0gY29udGFpbmVyQkJveC5taW5ZLFxuICAgICAgICB3aWR0aCA9IGNvbnRhaW5lckJCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IGNvbnRhaW5lckJCb3guaGVpZ2h0O1xuICAgIHZhciB0bCA9IHBsb3RSYW5nZS50bCxcbiAgICAgICAgdHIgPSBwbG90UmFuZ2UudHI7XG4gICAgdmFyIHBvc1ggPSAwO1xuICAgIHZhciBwb3NZID0gdGwueSAtIGhlaWdodCAtIEdBUCArIG9mZnNldFk7XG5cbiAgICBpZiAoZml4ZWQpIHtcbiAgICAgIHZhciB4ID0gKHRsLnggKyB0ci54KSAvIDI7XG4gICAgICBwb3NYID0geCAtIHdpZHRoIC8gMiArIG9mZnNldFg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfeDtcblxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgX3ggPSAoaXRlbXNbMF0ueCArIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLngpIC8gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF94ID0gaXRlbXNbMF0ueDtcbiAgICAgIH1cblxuICAgICAgcG9zWCA9IF94IC0gd2lkdGggLyAyICsgb2Zmc2V0WDtcblxuICAgICAgaWYgKHBvc1ggPCB0bC54KSB7XG4gICAgICAgIHBvc1ggPSB0bC54O1xuICAgICAgfVxuXG4gICAgICBpZiAocG9zWCArIHdpZHRoID4gdHIueCkge1xuICAgICAgICBwb3NYID0gdHIueCAtIHdpZHRoO1xuICAgICAgfVxuXG4gICAgICBpZiAodG9vbHRpcEFycm93KSB7XG4gICAgICAgIHRvb2x0aXBBcnJvdy5hdHRyKCdwb2ludHMnLCBbe1xuICAgICAgICAgIHg6IF94IC0gMyxcbiAgICAgICAgICB5OiB0bC55IC0gR0FQICsgb2Zmc2V0WVxuICAgICAgICB9LCB7XG4gICAgICAgICAgeDogX3ggKyAzLFxuICAgICAgICAgIHk6IHRsLnkgLSBHQVAgKyBvZmZzZXRZXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBfeCxcbiAgICAgICAgICB5OiB0bC55ICsgb2Zmc2V0WVxuICAgICAgICB9XSk7XG4gICAgICAgIHZhciBiYWNrU2hhcGUgPSBjb250YWluZXIuYmFja1NoYXBlO1xuICAgICAgICB2YXIgcmFkaXVzID0gVXRpbC5wYXJzZVBhZGRpbmcoYmFja1NoYXBlLmF0dHIoJ3JhZGl1cycpKTtcblxuICAgICAgICBpZiAoX3ggPT09IHRsLngpIHtcbiAgICAgICAgICByYWRpdXNbM10gPSAwO1xuICAgICAgICAgIHRvb2x0aXBBcnJvdy5hdHRyKCdwb2ludHMnLCBbe1xuICAgICAgICAgICAgeDogdGwueCxcbiAgICAgICAgICAgIHk6IHRsLnkgKyBvZmZzZXRZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogdGwueCxcbiAgICAgICAgICAgIHk6IHRsLnkgLSBHQVAgKyBvZmZzZXRZXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgeDogdGwueCArIEdBUCxcbiAgICAgICAgICAgIHk6IHRsLnkgLSBHQVAgKyBvZmZzZXRZXG4gICAgICAgICAgfV0pO1xuICAgICAgICB9IGVsc2UgaWYgKF94ID09PSB0ci54KSB7XG4gICAgICAgICAgcmFkaXVzWzJdID0gMDtcbiAgICAgICAgICB0b29sdGlwQXJyb3cuYXR0cigncG9pbnRzJywgW3tcbiAgICAgICAgICAgIHg6IHRyLngsXG4gICAgICAgICAgICB5OiB0bC55ICsgb2Zmc2V0WVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHRyLnggLSBHQVAsXG4gICAgICAgICAgICB5OiB0bC55IC0gR0FQICsgb2Zmc2V0WVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHg6IHRyLngsXG4gICAgICAgICAgICB5OiB0bC55IC0gR0FQICsgb2Zmc2V0WVxuICAgICAgICAgIH1dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJhY2tTaGFwZS5hdHRyKCdyYWRpdXMnLCByYWRpdXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnRhaW5lci5tb3ZlVG8ocG9zWCAtIG1pblgsIHBvc1kgLSBtaW5ZKTtcbiAgfTtcblxuICBfcHJvdG8uc2V0TWFya2VycyA9IGZ1bmN0aW9uIHNldE1hcmtlcnMoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIF9jZmcgPSBjZmcsXG4gICAgICAgIGl0ZW1zID0gX2NmZy5pdGVtcyxcbiAgICAgICAgc3R5bGUgPSBfY2ZnLnN0eWxlLFxuICAgICAgICB0eXBlID0gX2NmZy50eXBlO1xuXG4gICAgdmFyIG1hcmtlckdyb3VwID0gc2VsZi5fZ2V0TWFya2VyR3JvdXAodHlwZSk7XG5cbiAgICBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBpdGVtcy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgICB2YXIgbWFya2VyID0gbmV3IE1hcmtlcih7XG4gICAgICAgICAgY2xhc3NOYW1lOiAndG9vbHRpcC1jaXJjbGUtbWFya2VyJyxcbiAgICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgICAgeDogaXRlbS54LFxuICAgICAgICAgICAgeTogaXRlbS55LFxuICAgICAgICAgICAgc3Ryb2tlOiBpdGVtLmNvbG9yXG4gICAgICAgICAgfSwgc3R5bGUpXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXJHcm91cC5hZGQobWFya2VyKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFya2VyR3JvdXAuYWRkU2hhcGUoJ3JlY3QnLCB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3Rvb2x0aXAtcmVjdC1tYXJrZXInLFxuICAgICAgICBhdHRyczogc3R5bGVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uY2xlYXJNYXJrZXJzID0gZnVuY3Rpb24gY2xlYXJNYXJrZXJzKCkge1xuICAgIHZhciBtYXJrZXJHcm91cCA9IHRoaXMubWFya2VyR3JvdXA7XG4gICAgbWFya2VyR3JvdXAgJiYgbWFya2VyR3JvdXAuY2xlYXIoKTtcbiAgfTtcblxuICBfcHJvdG8uc2hvdyA9IGZ1bmN0aW9uIHNob3coKSB7XG4gICAgdmFyIGNyb3NzaGFpcnNTaGFwZVggPSB0aGlzLmNyb3NzaGFpcnNTaGFwZVg7XG4gICAgdmFyIGNyb3NzaGFpcnNTaGFwZVkgPSB0aGlzLmNyb3NzaGFpcnNTaGFwZVk7XG4gICAgdmFyIG1hcmtlckdyb3VwID0gdGhpcy5tYXJrZXJHcm91cDtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgdmFyIHRvb2x0aXBBcnJvdyA9IHRoaXMudG9vbHRpcEFycm93O1xuICAgIHZhciB4VGlwQm94ID0gdGhpcy54VGlwQm94O1xuICAgIHZhciB5VGlwQm94ID0gdGhpcy55VGlwQm94O1xuICAgIHZhciBjYW52YXMgPSB0aGlzLmNhbnZhcztcbiAgICBjcm9zc2hhaXJzU2hhcGVYICYmIGNyb3NzaGFpcnNTaGFwZVguc2hvdygpO1xuICAgIGNyb3NzaGFpcnNTaGFwZVkgJiYgY3Jvc3NoYWlyc1NoYXBlWS5zaG93KCk7XG4gICAgbWFya2VyR3JvdXAgJiYgbWFya2VyR3JvdXAuc2hvdygpO1xuICAgIGNvbnRhaW5lciAmJiBjb250YWluZXIuc2hvdygpO1xuICAgIHRvb2x0aXBBcnJvdyAmJiB0b29sdGlwQXJyb3cuc2hvdygpO1xuICAgIHhUaXBCb3ggJiYgeFRpcEJveC5zaG93KCk7XG4gICAgeVRpcEJveCAmJiB5VGlwQm94LnNob3coKTtcbiAgICBjYW52YXMuZHJhdygpO1xuICB9O1xuXG4gIF9wcm90by5oaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICB2YXIgY3Jvc3NoYWlyc1NoYXBlWCA9IHRoaXMuY3Jvc3NoYWlyc1NoYXBlWDtcbiAgICB2YXIgY3Jvc3NoYWlyc1NoYXBlWSA9IHRoaXMuY3Jvc3NoYWlyc1NoYXBlWTtcbiAgICB2YXIgbWFya2VyR3JvdXAgPSB0aGlzLm1hcmtlckdyb3VwO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICB2YXIgdG9vbHRpcEFycm93ID0gdGhpcy50b29sdGlwQXJyb3c7XG4gICAgdmFyIHhUaXBCb3ggPSB0aGlzLnhUaXBCb3g7XG4gICAgdmFyIHlUaXBCb3ggPSB0aGlzLnlUaXBCb3g7XG4gICAgY3Jvc3NoYWlyc1NoYXBlWCAmJiBjcm9zc2hhaXJzU2hhcGVYLmhpZGUoKTtcbiAgICBjcm9zc2hhaXJzU2hhcGVZICYmIGNyb3NzaGFpcnNTaGFwZVkuaGlkZSgpO1xuICAgIG1hcmtlckdyb3VwICYmIG1hcmtlckdyb3VwLmhpZGUoKTtcbiAgICBjb250YWluZXIgJiYgY29udGFpbmVyLmhpZGUoKTtcbiAgICB0b29sdGlwQXJyb3cgJiYgdG9vbHRpcEFycm93LmhpZGUoKTtcbiAgICB4VGlwQm94ICYmIHhUaXBCb3guaGlkZSgpO1xuICAgIHlUaXBCb3ggJiYgeVRpcEJveC5oaWRlKCk7XG4gIH07XG5cbiAgX3Byb3RvLmRlc3Ryb3kgPSBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBjcm9zc2hhaXJzU2hhcGVYID0gdGhpcy5jcm9zc2hhaXJzU2hhcGVYO1xuICAgIHZhciBjcm9zc2hhaXJzU2hhcGVZID0gdGhpcy5jcm9zc2hhaXJzU2hhcGVZO1xuICAgIHZhciBtYXJrZXJHcm91cCA9IHRoaXMubWFya2VyR3JvdXA7XG4gICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgIHZhciB0b29sdGlwQXJyb3cgPSB0aGlzLnRvb2x0aXBBcnJvdztcbiAgICB2YXIgeFRpcEJveCA9IHRoaXMueFRpcEJveDtcbiAgICB2YXIgeVRpcEJveCA9IHRoaXMueVRpcEJveDtcbiAgICBjcm9zc2hhaXJzU2hhcGVYICYmIGNyb3NzaGFpcnNTaGFwZVgucmVtb3ZlKHRydWUpO1xuICAgIGNyb3NzaGFpcnNTaGFwZVkgJiYgY3Jvc3NoYWlyc1NoYXBlWS5yZW1vdmUodHJ1ZSk7XG4gICAgbWFya2VyR3JvdXAgJiYgbWFya2VyR3JvdXAucmVtb3ZlKHRydWUpO1xuICAgIHRvb2x0aXBBcnJvdyAmJiB0b29sdGlwQXJyb3cucmVtb3ZlKHRydWUpO1xuICAgIGNvbnRhaW5lciAmJiBjb250YWluZXIuY2xlYXIoKTtcbiAgICB4VGlwQm94ICYmIHhUaXBCb3guY2xlYXIoKTtcbiAgICB5VGlwQm94ICYmIHlUaXBCb3guY2xlYXIoKTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRNYXJrZXJHcm91cCA9IGZ1bmN0aW9uIF9nZXRNYXJrZXJHcm91cCh0eXBlKSB7XG4gICAgdmFyIG1hcmtlckdyb3VwID0gdGhpcy5tYXJrZXJHcm91cDtcblxuICAgIGlmICghbWFya2VyR3JvdXApIHtcbiAgICAgIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuICAgICAgICBtYXJrZXJHcm91cCA9IHRoaXMuZnJvbnRQbG90LmFkZEdyb3VwKHtcbiAgICAgICAgICB6SW5kZXg6IDFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZnJvbnRQbG90LnNvcnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtlckdyb3VwID0gdGhpcy5iYWNrUGxvdC5hZGRHcm91cCgpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1hcmtlckdyb3VwID0gbWFya2VyR3JvdXA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcmtlckdyb3VwLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtlckdyb3VwO1xuICB9O1xuXG4gIF9wcm90by5fcmVuZGVyQ3Jvc3NoYWlycyA9IGZ1bmN0aW9uIF9yZW5kZXJDcm9zc2hhaXJzKCkge1xuICAgIHZhciBjcm9zc2hhaXJzVHlwZSA9IHRoaXMuY3Jvc3NoYWlyc1R5cGUsXG4gICAgICAgIGNyb3NzaGFpcnNTdHlsZSA9IHRoaXMuY3Jvc3NoYWlyc1N0eWxlLFxuICAgICAgICBmcm9udFBsb3QgPSB0aGlzLmZyb250UGxvdCxcbiAgICAgICAgcGxvdFJhbmdlID0gdGhpcy5wbG90UmFuZ2U7XG4gICAgdmFyIHRsID0gcGxvdFJhbmdlLnRsLFxuICAgICAgICBiciA9IHBsb3RSYW5nZS5icjtcblxuICAgIGlmIChVdGlsLmRpcmVjdGlvbkVuYWJsZWQoY3Jvc3NoYWlyc1R5cGUsICd4JykpIHtcbiAgICAgIHRoaXMuY3Jvc3NoYWlyc1NoYXBlWCA9IGZyb250UGxvdC5hZGRTaGFwZSgnTGluZScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndG9vbHRpcC1jcm9zc2hhaXJzLXgnLFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHgxOiB0bC54LFxuICAgICAgICAgIHkxOiAwLFxuICAgICAgICAgIHgyOiBici54LFxuICAgICAgICAgIHkyOiAwXG4gICAgICAgIH0sIGNyb3NzaGFpcnNTdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChVdGlsLmRpcmVjdGlvbkVuYWJsZWQoY3Jvc3NoYWlyc1R5cGUsICd5JykpIHtcbiAgICAgIHRoaXMuY3Jvc3NoYWlyc1NoYXBlWSA9IGZyb250UGxvdC5hZGRTaGFwZSgnTGluZScsIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndG9vbHRpcC1jcm9zc2hhaXJzLXknLFxuICAgICAgICB6SW5kZXg6IDAsXG4gICAgICAgIHZpc2libGU6IGZhbHNlLFxuICAgICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICAgIHgxOiAwLFxuICAgICAgICAgIHkxOiBici55LFxuICAgICAgICAgIHgyOiAwLFxuICAgICAgICAgIHkyOiB0bC55XG4gICAgICAgIH0sIGNyb3NzaGFpcnNTdHlsZSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVG9vbHRpcDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUb29sdGlwO1xuXG4vKioqLyB9KSxcbi8qIDEyOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gICAgR3JvdXAgPSBfcmVxdWlyZS5Hcm91cDtcblxudmFyIFRleHRCb3ggPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICB2YXIgX3Byb3RvID0gVGV4dEJveC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLmdldERlZmF1bHRDZmcgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q2ZnKCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgdGV4dFN0eWxlOiB7XG4gICAgICAgIGZvbnRTaXplOiAxMixcbiAgICAgICAgZmlsbDogJyNmZmYnLFxuICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgICB0ZXh0QmFzZWxpbmU6ICdtaWRkbGUnXG4gICAgICB9LFxuICAgICAgYmFja2dyb3VuZDoge1xuICAgICAgICByYWRpdXM6IDEsXG4gICAgICAgIGZpbGw6ICdyZ2JhKDAsIDAsIDAsIDAuNjUpJyxcbiAgICAgICAgcGFkZGluZzogWzMsIDVdXG4gICAgICB9LFxuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDAsXG4gICAgICBjbGFzc05hbWU6ICcnXG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBUZXh0Qm94KGNmZykge1xuICAgIFV0aWwuZGVlcE1peCh0aGlzLCB0aGlzLmdldERlZmF1bHRDZmcoKSwgY2ZnKTtcblxuICAgIHRoaXMuX2luaXQoKTtcblxuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICB4ID0gdGhpcy54LFxuICAgICAgICB5ID0gdGhpcy55O1xuXG4gICAgaWYgKCFVdGlsLmlzTmlsKGNvbnRlbnQpKSB7XG4gICAgICB0aGlzLnVwZGF0ZUNvbnRlbnQoY29udGVudCk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVQb3NpdGlvbih4LCB5KTtcbiAgfVxuXG4gIF9wcm90by5faW5pdCA9IGZ1bmN0aW9uIF9pbml0KCkge1xuICAgIHZhciBjb250ZW50ID0gdGhpcy5jb250ZW50LFxuICAgICAgICB0ZXh0U3R5bGUgPSB0aGlzLnRleHRTdHlsZSxcbiAgICAgICAgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZCxcbiAgICAgICAgY2xhc3NOYW1lID0gdGhpcy5jbGFzc05hbWUsXG4gICAgICAgIHZpc2libGUgPSB0aGlzLnZpc2libGU7XG4gICAgdmFyIGNvbnRhaW5lciA9IG5ldyBHcm91cCh7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICAgIHpJbmRleDogMCxcbiAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICB9KTtcbiAgICB2YXIgdGV4dCA9IGNvbnRhaW5lci5hZGRTaGFwZSgnVGV4dCcsIHtcbiAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lICsgJy10ZXh0JyxcbiAgICAgIHpJbmRleDogMSxcbiAgICAgIGF0dHJzOiBVdGlsLm1peCh7XG4gICAgICAgIHRleHQ6IGNvbnRlbnQsXG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH0sIHRleHRTdHlsZSlcbiAgICB9KTtcbiAgICB2YXIgYmFja2dyb3VuZFNoYXBlID0gY29udGFpbmVyLmFkZFNoYXBlKCdSZWN0Jywge1xuICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWUgKyAnLWJnJyxcbiAgICAgIHpJbmRleDogLTEsXG4gICAgICBhdHRyczogVXRpbC5taXgoe1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgICB9LCBiYWNrZ3JvdW5kKVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5zb3J0KCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgdGhpcy50ZXh0U2hhcGUgPSB0ZXh0O1xuICAgIHRoaXMuYmFja2dyb3VuZFNoYXBlID0gYmFja2dyb3VuZFNoYXBlO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0QkJveCA9IGZ1bmN0aW9uIF9nZXRCQm94KCkge1xuICAgIHZhciB0ZXh0U2hhcGUgPSB0aGlzLnRleHRTaGFwZTtcbiAgICB2YXIgYmFja2dyb3VuZCA9IHRoaXMuYmFja2dyb3VuZDtcbiAgICB2YXIgdGV4dEJCb3ggPSB0ZXh0U2hhcGUuZ2V0QkJveCgpO1xuICAgIHZhciBwYWRkaW5nID0gVXRpbC5wYXJzZVBhZGRpbmcoYmFja2dyb3VuZC5wYWRkaW5nKTtcbiAgICB2YXIgd2lkdGggPSB0ZXh0QkJveC53aWR0aCArIHBhZGRpbmdbMV0gKyBwYWRkaW5nWzNdO1xuICAgIHZhciBoZWlnaHQgPSB0ZXh0QkJveC5oZWlnaHQgKyBwYWRkaW5nWzBdICsgcGFkZGluZ1syXTtcbiAgICB2YXIgeCA9IHRleHRCQm94Lm1pblggLSBwYWRkaW5nWzNdO1xuICAgIHZhciB5ID0gdGV4dEJCb3gubWluWSAtIHBhZGRpbmdbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVDb250ZW50ID0gZnVuY3Rpb24gdXBkYXRlQ29udGVudCh0ZXh0KSB7XG4gICAgdmFyIHRleHRTaGFwZSA9IHRoaXMudGV4dFNoYXBlLFxuICAgICAgICBiYWNrZ3JvdW5kU2hhcGUgPSB0aGlzLmJhY2tncm91bmRTaGFwZTtcblxuICAgIGlmICghVXRpbC5pc05pbCh0ZXh0KSkge1xuICAgICAgaWYgKCFVdGlsLmlzT2JqZWN0KHRleHQpKSB7XG4gICAgICAgIHRleHQgPSB7XG4gICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICB0ZXh0U2hhcGUuYXR0cih0ZXh0KTsgLy8gdXBkYXRlIGJveCBzaGFwZVxuXG4gICAgICB2YXIgX3RoaXMkX2dldEJCb3ggPSB0aGlzLl9nZXRCQm94KCksXG4gICAgICAgICAgeCA9IF90aGlzJF9nZXRCQm94LngsXG4gICAgICAgICAgeSA9IF90aGlzJF9nZXRCQm94LnksXG4gICAgICAgICAgdGlwV2lkdGggPSBfdGhpcyRfZ2V0QkJveC53aWR0aCxcbiAgICAgICAgICB0aXBIZWlnaHQgPSBfdGhpcyRfZ2V0QkJveC5oZWlnaHQ7XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGggfHwgdGlwV2lkdGg7XG4gICAgICB2YXIgaGVpZ2h0ID0gdGhpcy5oZWlnaHQgfHwgdGlwSGVpZ2h0O1xuICAgICAgYmFja2dyb3VuZFNoYXBlLmF0dHIoe1xuICAgICAgICB4OiB4LFxuICAgICAgICB5OiB5LFxuICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3dpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmNvbnRlbnQgPSB0ZXh0LnRleHQ7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHgsIHkpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG5cbiAgICB2YXIgX3RoaXMkX2dldEJCb3gyID0gdGhpcy5fZ2V0QkJveCgpLFxuICAgICAgICB4TWluID0gX3RoaXMkX2dldEJCb3gyLngsXG4gICAgICAgIHlNaW4gPSBfdGhpcyRfZ2V0QkJveDIueTtcblxuICAgIGNvbnRhaW5lci5tb3ZlVG8oeCAtIHhNaW4sIHkgLSB5TWluKTtcbiAgICB0aGlzLnggPSB4IC0geE1pbjtcbiAgICB0aGlzLnkgPSB5IC0geU1pbjtcbiAgfTtcblxuICBfcHJvdG8uZ2V0V2lkdGggPSBmdW5jdGlvbiBnZXRXaWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd2lkdGg7XG4gIH07XG5cbiAgX3Byb3RvLmdldEhlaWdodCA9IGZ1bmN0aW9uIGdldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5faGVpZ2h0O1xuICB9O1xuXG4gIF9wcm90by5zaG93ID0gZnVuY3Rpb24gc2hvdygpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5zaG93KCk7XG4gIH07XG5cbiAgX3Byb3RvLmhpZGUgPSBmdW5jdGlvbiBoaWRlKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmhpZGUoKTtcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgY29udGFpbmVyLmNsZWFyKCk7XG4gICAgY29udGFpbmVyLnJlbW92ZSh0cnVlKTtcbiAgICB0aGlzLmNvbnRhaW5lciA9IG51bGw7XG4gICAgdGhpcy50ZXh0U2hhcGUgPSBudWxsO1xuICAgIHRoaXMuYmFja2dyb3VuZFNoYXBlID0gbnVsbDtcbiAgfTtcblxuICByZXR1cm4gVGV4dEJveDtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUZXh0Qm94O1xuXG4vKioqLyB9KSxcbi8qIDEyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgVXRpbCA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbnZhciBHdWlkZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG52YXIgR2xvYmFsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTsgLy8gcmVnaXN0ZXIgdGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBmb3IgR3VpZGVcblxuXG5HbG9iYWwuZ3VpZGUgPSBVdGlsLmRlZXBNaXgoe1xuICBsaW5lOiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIHN0cm9rZTogJyNhM2EzYTMnLFxuICAgICAgbGluZVdpZHRoOiAxXG4gICAgfSxcbiAgICB0b3A6IHRydWVcbiAgfSxcbiAgdGV4dDoge1xuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiAnIzc4Nzg3OCcsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgIH0sXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHRvcDogdHJ1ZVxuICB9LFxuICByZWN0OiB7XG4gICAgc3R5bGU6IHtcbiAgICAgIGZpbGw6ICcjZmFmYWZhJ1xuICAgIH0sXG4gICAgdG9wOiBmYWxzZVxuICB9LFxuICBhcmM6IHtcbiAgICBzdHlsZToge1xuICAgICAgc3Ryb2tlOiAnI2EzYTNhMydcbiAgICB9LFxuICAgIHRvcDogdHJ1ZVxuICB9LFxuICBodG1sOiB7XG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIGFsaWduWDogJ2NlbnRlcicsXG4gICAgYWxpZ25ZOiAnbWlkZGxlJ1xuICB9LFxuICB0YWc6IHtcbiAgICB0b3A6IHRydWUsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHNpZGU6IDQsXG4gICAgYmFja2dyb3VuZDoge1xuICAgICAgcGFkZGluZzogNSxcbiAgICAgIHJhZGl1czogMixcbiAgICAgIGZpbGw6ICcjMTg5MEZGJ1xuICAgIH0sXG4gICAgdGV4dFN0eWxlOiB7XG4gICAgICBmb250U2l6ZTogMTIsXG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxuICAgICAgdGV4dEJhc2VsaW5lOiAnbWlkZGxlJ1xuICAgIH1cbiAgfSxcbiAgcG9pbnQ6IHtcbiAgICB0b3A6IHRydWUsXG4gICAgb2Zmc2V0WDogMCxcbiAgICBvZmZzZXRZOiAwLFxuICAgIHN0eWxlOiB7XG4gICAgICBmaWxsOiAnI2ZmZicsXG4gICAgICByOiAzLFxuICAgICAgbGluZVdpZHRoOiAyLFxuICAgICAgc3Ryb2tlOiAnIzE4OTBmZidcbiAgICB9XG4gIH1cbn0sIEdsb2JhbC5ndWlkZSB8fCB7fSk7XG5cbnZhciBHdWlkZUNvbnRyb2xsZXIgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBHdWlkZUNvbnRyb2xsZXIoY2ZnKSB7XG4gICAgdGhpcy5ndWlkZXMgPSBbXTtcbiAgICB0aGlzLnhTY2FsZSA9IG51bGw7XG4gICAgdGhpcy55U2NhbGVzID0gbnVsbDtcbiAgICB0aGlzLmd1aWRlU2hhcGVzID0gW107XG4gICAgVXRpbC5taXgodGhpcywgY2ZnKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBHdWlkZUNvbnRyb2xsZXIucHJvdG90eXBlO1xuXG4gIF9wcm90by5fdG9TdHJpbmcgPSBmdW5jdGlvbiBfdG9TdHJpbmcocG9zaXRpb24pIHtcbiAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHBvc2l0aW9uKSkge1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbih0aGlzLnhTY2FsZSwgdGhpcy55U2NhbGVzKTtcbiAgICB9XG5cbiAgICBwb3NpdGlvbiA9IHBvc2l0aW9uLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9O1xuXG4gIF9wcm90by5fZ2V0SWQgPSBmdW5jdGlvbiBfZ2V0SWQoc2hhcGUsIGd1aWRlKSB7XG4gICAgdmFyIGlkID0gZ3VpZGUuaWQ7XG5cbiAgICBpZiAoIWlkKSB7XG4gICAgICB2YXIgdHlwZSA9IGd1aWRlLnR5cGU7XG5cbiAgICAgIGlmICh0eXBlID09PSAnYXJjJyB8fCB0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ3JlY3QnKSB7XG4gICAgICAgIGlkID0gdGhpcy5fdG9TdHJpbmcoZ3VpZGUuc3RhcnQpICsgJy0nICsgdGhpcy5fdG9TdHJpbmcoZ3VpZGUuZW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkID0gdGhpcy5fdG9TdHJpbmcoZ3VpZGUucG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpZDtcbiAgfTtcblxuICBfcHJvdG8ucGFpbnQgPSBmdW5jdGlvbiBwYWludChjb29yZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgY2hhcnQgPSBzZWxmLmNoYXJ0LFxuICAgICAgICBndWlkZXMgPSBzZWxmLmd1aWRlcyxcbiAgICAgICAgeFNjYWxlID0gc2VsZi54U2NhbGUsXG4gICAgICAgIHlTY2FsZXMgPSBzZWxmLnlTY2FsZXM7XG4gICAgdmFyIGd1aWRlU2hhcGVzID0gW107XG4gICAgVXRpbC5lYWNoKGd1aWRlcywgZnVuY3Rpb24gKGd1aWRlLCBpZHgpIHtcbiAgICAgIGd1aWRlLnhTY2FsZSA9IHhTY2FsZTtcbiAgICAgIGd1aWRlLnlTY2FsZXMgPSB5U2NhbGVzO1xuICAgICAgdmFyIGNvbnRhaW5lcjtcblxuICAgICAgaWYgKGd1aWRlLnR5cGUgPT09ICdyZWdpb25GaWx0ZXInKSB7XG4gICAgICAgIC8vIFRPRE86IFJlZ2lvbkZpbHRlciBzdXBwb3J0IGFuaW1hdGlvblxuICAgICAgICBndWlkZS5jaGFydCA9IGNoYXJ0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyID0gZ3VpZGUudG9wID8gc2VsZi5mcm9udFBsb3QgOiBzZWxmLmJhY2tQbG90O1xuICAgICAgfVxuXG4gICAgICBndWlkZS5jb29yZCA9IGNvb3JkO1xuICAgICAgZ3VpZGUuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgZ3VpZGUuY2FudmFzID0gY2hhcnQuZ2V0KCdjYW52YXMnKTtcbiAgICAgIHZhciBzaGFwZSA9IGd1aWRlLnJlbmRlcihjb29yZCwgY29udGFpbmVyKTtcblxuICAgICAgaWYgKHNoYXBlKSB7XG4gICAgICAgIHZhciBpZCA9IHNlbGYuX2dldElkKHNoYXBlLCBndWlkZSk7XG5cbiAgICAgICAgW10uY29uY2F0KHNoYXBlKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgcy5faWQgPSBzLmdldCgnY2xhc3NOYW1lJykgKyAnLScgKyBpZDtcbiAgICAgICAgICBzLnNldCgnaW5kZXgnLCBpZHgpO1xuICAgICAgICAgIGd1aWRlU2hhcGVzLnB1c2gocyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNlbGYuZ3VpZGVTaGFwZXMgPSBndWlkZVNoYXBlcztcbiAgfTtcblxuICBfcHJvdG8uY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gICAgdGhpcy5ndWlkZXMgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ucmVzZXQgPSBmdW5jdGlvbiByZXNldCgpIHtcbiAgICB2YXIgZ3VpZGVzID0gdGhpcy5ndWlkZXM7XG4gICAgVXRpbC5lYWNoKGd1aWRlcywgZnVuY3Rpb24gKGd1aWRlKSB7XG4gICAgICBndWlkZS5yZW1vdmUoKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8uX2NyZWF0ZUd1aWRlID0gZnVuY3Rpb24gX2NyZWF0ZUd1aWRlKHR5cGUsIGNmZykge1xuICAgIHZhciBDbGFzc05hbWUgPSBVdGlsLnVwcGVyRmlyc3QodHlwZSk7XG4gICAgdmFyIGd1aWRlID0gbmV3IEd1aWRlW0NsYXNzTmFtZV0oVXRpbC5kZWVwTWl4KHt9LCBHbG9iYWwuZ3VpZGVbdHlwZV0sIGNmZykpO1xuICAgIHRoaXMuZ3VpZGVzLnB1c2goZ3VpZGUpO1xuICAgIHJldHVybiBndWlkZTtcbiAgfTtcblxuICBfcHJvdG8ubGluZSA9IGZ1bmN0aW9uIGxpbmUoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlR3VpZGUoJ2xpbmUnLCBjZmcpO1xuICB9O1xuXG4gIF9wcm90by50ZXh0ID0gZnVuY3Rpb24gdGV4dChjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVHdWlkZSgndGV4dCcsIGNmZyk7XG4gIH07XG5cbiAgX3Byb3RvLmFyYyA9IGZ1bmN0aW9uIGFyYyhjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVHdWlkZSgnYXJjJywgY2ZnKTtcbiAgfTtcblxuICBfcHJvdG8uaHRtbCA9IGZ1bmN0aW9uIGh0bWwoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlR3VpZGUoJ2h0bWwnLCBjZmcpO1xuICB9O1xuXG4gIF9wcm90by5yZWN0ID0gZnVuY3Rpb24gcmVjdChjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVHdWlkZSgncmVjdCcsIGNmZyk7XG4gIH07XG5cbiAgX3Byb3RvLnRhZyA9IGZ1bmN0aW9uIHRhZyhjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVHdWlkZSgndGFnJywgY2ZnKTtcbiAgfTtcblxuICBfcHJvdG8ucG9pbnQgPSBmdW5jdGlvbiBwb2ludChjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9jcmVhdGVHdWlkZSgncG9pbnQnLCBjZmcpO1xuICB9O1xuXG4gIF9wcm90by5yZWdpb25GaWx0ZXIgPSBmdW5jdGlvbiByZWdpb25GaWx0ZXIoY2ZnKSB7XG4gICAgaWYgKGNmZyA9PT0gdm9pZCAwKSB7XG4gICAgICBjZmcgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fY3JlYXRlR3VpZGUoJ3JlZ2lvbkZpbHRlcicsIGNmZyk7XG4gIH07XG5cbiAgcmV0dXJuIEd1aWRlQ29udHJvbGxlcjtcbn0oKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQoY2hhcnQpIHtcbiAgICB2YXIgZ3VpZGVDb250cm9sbGVyID0gbmV3IEd1aWRlQ29udHJvbGxlcih7XG4gICAgICBmcm9udFBsb3Q6IGNoYXJ0LmdldCgnZnJvbnRQbG90JykuYWRkR3JvdXAoe1xuICAgICAgICB6SW5kZXg6IDIwLFxuICAgICAgICBjbGFzc05hbWU6ICdndWlkZUNvbnRhaW5lcidcbiAgICAgIH0pLFxuICAgICAgYmFja1Bsb3Q6IGNoYXJ0LmdldCgnYmFja1Bsb3QnKS5hZGRHcm91cCh7XG4gICAgICAgIGNsYXNzTmFtZTogJ2d1aWRlQ29udGFpbmVyJ1xuICAgICAgfSlcbiAgICB9KTtcbiAgICBjaGFydC5zZXQoJ2d1aWRlQ29udHJvbGxlcicsIGd1aWRlQ29udHJvbGxlcik7XG4gICAgLyoqXG4gICAgICog5Li65Zu+6KGo5re75YqgIGd1aWRlXG4gICAgICogQHJldHVybiB7R3VpZGVDb250cm9sbGVyfSDov5Tlm54gZ3VpZGUg5o6n5Yi25ZmoXG4gICAgICovXG5cbiAgICBjaGFydC5ndWlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBndWlkZUNvbnRyb2xsZXI7XG4gICAgfTtcbiAgfSxcbiAgYWZ0ZXJHZW9tRHJhdzogZnVuY3Rpb24gYWZ0ZXJHZW9tRHJhdyhjaGFydCkge1xuICAgIHZhciBndWlkZUNvbnRyb2xsZXIgPSBjaGFydC5nZXQoJ2d1aWRlQ29udHJvbGxlcicpO1xuXG4gICAgaWYgKCFndWlkZUNvbnRyb2xsZXIuZ3VpZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB4U2NhbGUgPSBjaGFydC5nZXRYU2NhbGUoKTtcbiAgICB2YXIgeVNjYWxlcyA9IGNoYXJ0LmdldFlTY2FsZXMoKTtcbiAgICB2YXIgY29vcmQgPSBjaGFydC5nZXQoJ2Nvb3JkJyk7XG4gICAgZ3VpZGVDb250cm9sbGVyLnhTY2FsZSA9IHhTY2FsZTtcbiAgICBndWlkZUNvbnRyb2xsZXIueVNjYWxlcyA9IHlTY2FsZXM7XG4gICAgZ3VpZGVDb250cm9sbGVyLmNoYXJ0ID0gY2hhcnQ7IC8vIGZvciByZWdpb25GaWx0ZXJcblxuICAgIGd1aWRlQ29udHJvbGxlci5wYWludChjb29yZCk7XG4gIH0sXG4gIGNsZWFyOiBmdW5jdGlvbiBjbGVhcihjaGFydCkge1xuICAgIGNoYXJ0LmdldCgnZ3VpZGVDb250cm9sbGVyJykuY2xlYXIoKTtcbiAgfSxcbiAgcmVwYWludDogZnVuY3Rpb24gcmVwYWludChjaGFydCkge1xuICAgIGNoYXJ0LmdldCgnZ3VpZGVDb250cm9sbGVyJykucmVzZXQoKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgTGlzdCA9IF9fd2VicGFja19yZXF1aXJlX18oMTAxKTtcblxudmFyIEdsb2JhbCA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbnZhciBMRUdFTkRfR0FQID0gMTI7XG52YXIgTUFSS0VSX1NJWkUgPSAzO1xudmFyIERFRkFVTFRfQ0ZHID0ge1xuICBpdGVtTWFyZ2luQm90dG9tOiAxMixcbiAgaXRlbUdhcDogMTAsXG4gIHNob3dUaXRsZTogZmFsc2UsXG4gIHRpdGxlU3R5bGU6IHtcbiAgICBmb250U2l6ZTogMTIsXG4gICAgZmlsbDogJyM4MDgwODAnLFxuICAgIHRleHRBbGlnbjogJ3N0YXJ0JyxcbiAgICB0ZXh0QmFzZWxpbmU6ICd0b3AnXG4gIH0sXG4gIG5hbWVTdHlsZToge1xuICAgIGZpbGw6ICcjODA4MDgwJyxcbiAgICBmb250U2l6ZTogMTIsXG4gICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgfSxcbiAgdmFsdWVTdHlsZToge1xuICAgIGZpbGw6ICcjMDAwMDAwJyxcbiAgICBmb250U2l6ZTogMTIsXG4gICAgdGV4dEFsaWduOiAnc3RhcnQnLFxuICAgIHRleHRCYXNlbGluZTogJ21pZGRsZSdcbiAgfSxcbiAgdW5DaGVja1N0eWxlOiB7XG4gICAgZmlsbDogJyNiZmJmYmYnXG4gIH0sXG4gIGl0ZW1XaWR0aDogJ2F1dG8nLFxuICB3b3JkU3BhY2U6IDYsXG4gIHNlbGVjdGVkTW9kZTogJ211bHRpcGxlJyAvLyAnbXVsdGlwbGUnIG9yICdzaW5nbGUnXG5cbn07IC8vIFJlZ2lzdGVyIHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gZm9yIExlZ2VuZFxuXG5HbG9iYWwubGVnZW5kID0gVXRpbC5kZWVwTWl4KHtcbiAgY29tbW9uOiBERUZBVUxUX0NGRyxcbiAgLy8gY29tbW9uIGxlZ2VuZCBjb25maWd1cmF0aW9uXG4gIHJpZ2h0OiBVdGlsLm1peCh7XG4gICAgcG9zaXRpb246ICdyaWdodCcsXG4gICAgbGF5b3V0OiAndmVydGljYWwnXG4gIH0sIERFRkFVTFRfQ0ZHKSxcbiAgbGVmdDogVXRpbC5taXgoe1xuICAgIHBvc2l0aW9uOiAnbGVmdCcsXG4gICAgbGF5b3V0OiAndmVydGljYWwnXG4gIH0sIERFRkFVTFRfQ0ZHKSxcbiAgdG9wOiBVdGlsLm1peCh7XG4gICAgcG9zaXRpb246ICd0b3AnLFxuICAgIGxheW91dDogJ2hvcml6b250YWwnXG4gIH0sIERFRkFVTFRfQ0ZHKSxcbiAgYm90dG9tOiBVdGlsLm1peCh7XG4gICAgcG9zaXRpb246ICdib3R0b20nLFxuICAgIGxheW91dDogJ2hvcml6b250YWwnXG4gIH0sIERFRkFVTFRfQ0ZHKVxufSwgR2xvYmFsLmxlZ2VuZCB8fCB7fSk7XG5cbmZ1bmN0aW9uIGdldFBhZGRpbmdCeVBvcyhwb3MsIGFwcGVuZFBhZGRpbmcpIHtcbiAgdmFyIHBhZGRpbmcgPSAwO1xuICBhcHBlbmRQYWRkaW5nID0gVXRpbC5wYXJzZVBhZGRpbmcoYXBwZW5kUGFkZGluZyk7XG5cbiAgc3dpdGNoIChwb3MpIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgcGFkZGluZyA9IGFwcGVuZFBhZGRpbmdbMF07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHBhZGRpbmcgPSBhcHBlbmRQYWRkaW5nWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgcGFkZGluZyA9IGFwcGVuZFBhZGRpbmdbMl07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgcGFkZGluZyA9IGFwcGVuZFBhZGRpbmdbM107XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBwYWRkaW5nO1xufVxuXG52YXIgTGVnZW5kQ29udHJvbGxlciA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExlZ2VuZENvbnRyb2xsZXIoY2ZnKSB7XG4gICAgdGhpcy5sZWdlbmRDZmcgPSB7fTtcbiAgICB0aGlzLmVuYWJsZSA9IHRydWU7XG4gICAgdGhpcy5wb3NpdGlvbiA9ICd0b3AnO1xuICAgIFV0aWwubWl4KHRoaXMsIGNmZyk7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB0aGlzLmNhbnZhc0RvbSA9IGNoYXJ0LmdldCgnY2FudmFzJykuZ2V0KCdlbCcpO1xuICAgIHRoaXMuY2xlYXIoKTtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBMZWdlbmRDb250cm9sbGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uYWRkTGVnZW5kID0gZnVuY3Rpb24gYWRkTGVnZW5kKHNjYWxlLCBpdGVtcywgZmlsdGVyVmFscykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGVnZW5kQ2ZnID0gc2VsZi5sZWdlbmRDZmc7XG4gICAgdmFyIGZpZWxkID0gc2NhbGUuZmllbGQ7XG4gICAgdmFyIGZpZWxkQ2ZnID0gbGVnZW5kQ2ZnW2ZpZWxkXTtcblxuICAgIGlmIChmaWVsZENmZyA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaWVsZENmZyAmJiBmaWVsZENmZy5jdXN0b20pIHtcbiAgICAgIHNlbGYuYWRkQ3VzdG9tTGVnZW5kKGZpZWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBvc2l0aW9uID0gbGVnZW5kQ2ZnLnBvc2l0aW9uIHx8IHNlbGYucG9zaXRpb247XG5cbiAgICAgIGlmIChmaWVsZENmZyAmJiBmaWVsZENmZy5wb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IGZpZWxkQ2ZnLnBvc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2NhbGUuaXNDYXRlZ29yeSkge1xuICAgICAgICBzZWxmLl9hZGRDYXRlZ29yeUxlZ2VuZChzY2FsZSwgaXRlbXMsIHBvc2l0aW9uLCBmaWx0ZXJWYWxzKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmFkZEN1c3RvbUxlZ2VuZCA9IGZ1bmN0aW9uIGFkZEN1c3RvbUxlZ2VuZChmaWVsZCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgbGVnZW5kQ2ZnID0gc2VsZi5sZWdlbmRDZmc7XG5cbiAgICBpZiAoZmllbGQgJiYgbGVnZW5kQ2ZnW2ZpZWxkXSkge1xuICAgICAgbGVnZW5kQ2ZnID0gbGVnZW5kQ2ZnW2ZpZWxkXTtcbiAgICB9XG5cbiAgICB2YXIgcG9zaXRpb24gPSBsZWdlbmRDZmcucG9zaXRpb24gfHwgc2VsZi5wb3NpdGlvbjtcbiAgICB2YXIgbGVnZW5kcyA9IHNlbGYubGVnZW5kcztcbiAgICBsZWdlbmRzW3Bvc2l0aW9uXSA9IGxlZ2VuZHNbcG9zaXRpb25dIHx8IFtdO1xuICAgIHZhciBpdGVtcyA9IGxlZ2VuZENmZy5pdGVtcztcblxuICAgIGlmICghaXRlbXMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBjb250YWluZXIgPSBzZWxmLmNvbnRhaW5lcjtcbiAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoIVV0aWwuaXNQbGFpbk9iamVjdChpdGVtLm1hcmtlcikpIHtcbiAgICAgICAgaXRlbS5tYXJrZXIgPSB7XG4gICAgICAgICAgc3ltYm9sOiBpdGVtLm1hcmtlciB8fCAnY2lyY2xlJyxcbiAgICAgICAgICBmaWxsOiBpdGVtLmZpbGwsXG4gICAgICAgICAgcmFkaXVzOiBNQVJLRVJfU0laRVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbS5tYXJrZXIucmFkaXVzID0gaXRlbS5tYXJrZXIucmFkaXVzIHx8IE1BUktFUl9TSVpFO1xuICAgICAgfVxuXG4gICAgICBpdGVtLmNoZWNrZWQgPSBVdGlsLmlzTmlsKGl0ZW0uY2hlY2tlZCkgPyB0cnVlIDogaXRlbS5jaGVja2VkO1xuICAgICAgaXRlbS5uYW1lID0gaXRlbS5uYW1lIHx8IGl0ZW0udmFsdWU7XG4gICAgfSk7XG4gICAgdmFyIGxlZ2VuZCA9IG5ldyBMaXN0KFV0aWwuZGVlcE1peCh7fSwgR2xvYmFsLmxlZ2VuZFtwb3NpdGlvbl0sIGxlZ2VuZENmZywge1xuICAgICAgbWF4TGVuZ3RoOiBzZWxmLl9nZXRNYXhMZW5ndGgocG9zaXRpb24pLFxuICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgcGFyZW50OiBjb250YWluZXJcbiAgICB9KSk7XG4gICAgbGVnZW5kc1twb3NpdGlvbl0ucHVzaChsZWdlbmQpO1xuICB9O1xuXG4gIF9wcm90by5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIHZhciBsZWdlbmRzID0gdGhpcy5sZWdlbmRzO1xuICAgIFV0aWwuZWFjaChsZWdlbmRzLCBmdW5jdGlvbiAobGVnZW5kSXRlbXMpIHtcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRJdGVtcywgZnVuY3Rpb24gKGxlZ2VuZCkge1xuICAgICAgICBsZWdlbmQuY2xlYXIoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMubGVnZW5kcyA9IHt9O1xuICAgIHRoaXMudW5CaW5kRXZlbnRzKCk7XG4gIH07XG5cbiAgX3Byb3RvLl9pc0ZpbHRlcmVkID0gZnVuY3Rpb24gX2lzRmlsdGVyZWQoc2NhbGUsIHZhbHVlcywgdmFsdWUpIHtcbiAgICB2YXIgcnN0ID0gZmFsc2U7XG4gICAgVXRpbC5lYWNoKHZhbHVlcywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcnN0ID0gcnN0IHx8IHNjYWxlLmdldFRleHQodmFsKSA9PT0gc2NhbGUuZ2V0VGV4dCh2YWx1ZSk7XG5cbiAgICAgIGlmIChyc3QpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByc3Q7XG4gIH07XG5cbiAgX3Byb3RvLl9nZXRNYXhMZW5ndGggPSBmdW5jdGlvbiBfZ2V0TWF4TGVuZ3RoKHBvc2l0aW9uKSB7XG4gICAgdmFyIGNoYXJ0ID0gdGhpcy5jaGFydDtcbiAgICB2YXIgYXBwZW5kUGFkZGluZyA9IFV0aWwucGFyc2VQYWRkaW5nKGNoYXJ0LmdldCgnYXBwZW5kUGFkZGluZycpKTtcbiAgICByZXR1cm4gcG9zaXRpb24gPT09ICdyaWdodCcgfHwgcG9zaXRpb24gPT09ICdsZWZ0JyA/IGNoYXJ0LmdldCgnaGVpZ2h0JykgLSAoYXBwZW5kUGFkZGluZ1swXSArIGFwcGVuZFBhZGRpbmdbMl0pIDogY2hhcnQuZ2V0KCd3aWR0aCcpIC0gKGFwcGVuZFBhZGRpbmdbMV0gKyBhcHBlbmRQYWRkaW5nWzNdKTtcbiAgfTtcblxuICBfcHJvdG8uX2FkZENhdGVnb3J5TGVnZW5kID0gZnVuY3Rpb24gX2FkZENhdGVnb3J5TGVnZW5kKHNjYWxlLCBpdGVtcywgcG9zaXRpb24sIGZpbHRlclZhbHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlZ2VuZENmZyA9IHNlbGYubGVnZW5kQ2ZnLFxuICAgICAgICBsZWdlbmRzID0gc2VsZi5sZWdlbmRzLFxuICAgICAgICBjb250YWluZXIgPSBzZWxmLmNvbnRhaW5lcixcbiAgICAgICAgY2hhcnQgPSBzZWxmLmNoYXJ0O1xuICAgIHZhciBmaWVsZCA9IHNjYWxlLmZpZWxkO1xuICAgIGxlZ2VuZHNbcG9zaXRpb25dID0gbGVnZW5kc1twb3NpdGlvbl0gfHwgW107XG4gICAgdmFyIHN5bWJvbCA9ICdjaXJjbGUnO1xuXG4gICAgaWYgKGxlZ2VuZENmZ1tmaWVsZF0gJiYgbGVnZW5kQ2ZnW2ZpZWxkXS5tYXJrZXIpIHtcbiAgICAgIHN5bWJvbCA9IGxlZ2VuZENmZ1tmaWVsZF0ubWFya2VyO1xuICAgIH0gZWxzZSBpZiAobGVnZW5kQ2ZnLm1hcmtlcikge1xuICAgICAgc3ltYm9sID0gbGVnZW5kQ2ZnLm1hcmtlcjtcbiAgICB9XG5cbiAgICBVdGlsLmVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICBpZiAoVXRpbC5pc1BsYWluT2JqZWN0KHN5bWJvbCkpIHtcbiAgICAgICAgVXRpbC5taXgoaXRlbS5tYXJrZXIsIHN5bWJvbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtLm1hcmtlci5zeW1ib2wgPSBzeW1ib2w7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWx0ZXJWYWxzKSB7XG4gICAgICAgIGl0ZW0uY2hlY2tlZCA9IHNlbGYuX2lzRmlsdGVyZWQoc2NhbGUsIGZpbHRlclZhbHMsIGl0ZW0uZGF0YVZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbGVnZW5kSXRlbXMgPSBjaGFydC5nZXQoJ2xlZ2VuZEl0ZW1zJyk7XG4gICAgbGVnZW5kSXRlbXNbZmllbGRdID0gaXRlbXM7XG4gICAgdmFyIGxhc3RDZmcgPSBVdGlsLmRlZXBNaXgoe30sIEdsb2JhbC5sZWdlbmRbcG9zaXRpb25dLCBsZWdlbmRDZmdbZmllbGRdIHx8IGxlZ2VuZENmZywge1xuICAgICAgbWF4TGVuZ3RoOiBzZWxmLl9nZXRNYXhMZW5ndGgocG9zaXRpb24pLFxuICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgZmlsdGVyVmFsczogZmlsdGVyVmFscyxcbiAgICAgIHBhcmVudDogY29udGFpbmVyXG4gICAgfSk7XG5cbiAgICBpZiAobGFzdENmZy5zaG93VGl0bGUpIHtcbiAgICAgIFV0aWwuZGVlcE1peChsYXN0Q2ZnLCB7XG4gICAgICAgIHRpdGxlOiBzY2FsZS5hbGlhcyB8fCBzY2FsZS5maWVsZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIGxlZ2VuZCA9IG5ldyBMaXN0KGxhc3RDZmcpO1xuICAgIGxlZ2VuZHNbcG9zaXRpb25dLnB1c2gobGVnZW5kKTtcbiAgICByZXR1cm4gbGVnZW5kO1xuICB9O1xuXG4gIF9wcm90by5fYWxpZ25MZWdlbmQgPSBmdW5jdGlvbiBfYWxpZ25MZWdlbmQobGVnZW5kLCBwcmUsIHBvc2l0aW9uKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBfc2VsZiRwbG90UmFuZ2UgPSBzZWxmLnBsb3RSYW5nZSxcbiAgICAgICAgdGwgPSBfc2VsZiRwbG90UmFuZ2UudGwsXG4gICAgICAgIGJsID0gX3NlbGYkcGxvdFJhbmdlLmJsO1xuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG4gICAgdmFyIG9mZnNldFggPSBsZWdlbmQub2Zmc2V0WCB8fCAwO1xuICAgIHZhciBvZmZzZXRZID0gbGVnZW5kLm9mZnNldFkgfHwgMDtcbiAgICB2YXIgY2hhcnRXaWR0aCA9IGNoYXJ0LmdldCgnd2lkdGgnKTtcbiAgICB2YXIgY2hhcnRIZWlnaHQgPSBjaGFydC5nZXQoJ2hlaWdodCcpO1xuICAgIHZhciBhcHBlbmRQYWRkaW5nID0gVXRpbC5wYXJzZVBhZGRpbmcoY2hhcnQuZ2V0KCdhcHBlbmRQYWRkaW5nJykpO1xuICAgIHZhciBsZWdlbmRIZWlnaHQgPSBsZWdlbmQuZ2V0SGVpZ2h0KCk7XG4gICAgdmFyIGxlZ2VuZFdpZHRoID0gbGVnZW5kLmdldFdpZHRoKCk7XG4gICAgdmFyIHggPSAwO1xuICAgIHZhciB5ID0gMDtcblxuICAgIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnIHx8IHBvc2l0aW9uID09PSAncmlnaHQnKSB7XG4gICAgICB2YXIgdmVydGljYWxBbGlnbiA9IGxlZ2VuZC52ZXJ0aWNhbEFsaWduIHx8ICdtaWRkbGUnO1xuICAgICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKHRsLnkgLSBibC55KTtcbiAgICAgIHggPSBwb3NpdGlvbiA9PT0gJ2xlZnQnID8gYXBwZW5kUGFkZGluZ1szXSA6IGNoYXJ0V2lkdGggLSBsZWdlbmRXaWR0aCAtIGFwcGVuZFBhZGRpbmdbMV07XG4gICAgICB5ID0gKGhlaWdodCAtIGxlZ2VuZEhlaWdodCkgLyAyICsgdGwueTtcblxuICAgICAgaWYgKHZlcnRpY2FsQWxpZ24gPT09ICd0b3AnKSB7XG4gICAgICAgIHkgPSB0bC55O1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbEFsaWduID09PSAnYm90dG9tJykge1xuICAgICAgICB5ID0gYmwueSAtIGxlZ2VuZEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZSkge1xuICAgICAgICB5ID0gcHJlLmdldCgneScpIC0gbGVnZW5kSGVpZ2h0IC0gTEVHRU5EX0dBUDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFsaWduID0gbGVnZW5kLmFsaWduIHx8ICdsZWZ0JztcbiAgICAgIHggPSBhcHBlbmRQYWRkaW5nWzNdO1xuXG4gICAgICBpZiAoYWxpZ24gPT09ICdjZW50ZXInKSB7XG4gICAgICAgIHggPSBjaGFydFdpZHRoIC8gMiAtIGxlZ2VuZFdpZHRoIC8gMjtcbiAgICAgIH0gZWxzZSBpZiAoYWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgeCA9IGNoYXJ0V2lkdGggLSAobGVnZW5kV2lkdGggKyBhcHBlbmRQYWRkaW5nWzFdKTtcbiAgICAgIH1cblxuICAgICAgeSA9IHBvc2l0aW9uID09PSAndG9wJyA/IGFwcGVuZFBhZGRpbmdbMF0gKyBNYXRoLmFicyhsZWdlbmQuY29udGFpbmVyLmdldEJCb3goKS5taW5ZKSA6IGNoYXJ0SGVpZ2h0IC0gbGVnZW5kSGVpZ2h0O1xuXG4gICAgICBpZiAocHJlKSB7XG4gICAgICAgIHZhciBwcmVXaWR0aCA9IHByZS5nZXRXaWR0aCgpO1xuICAgICAgICB4ID0gcHJlLnggKyBwcmVXaWR0aCArIExFR0VORF9HQVA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID09PSAnYm90dG9tJyAmJiBvZmZzZXRZID4gMCkge1xuICAgICAgb2Zmc2V0WSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmIG9mZnNldFggPiAwKSB7XG4gICAgICBvZmZzZXRYID0gMDtcbiAgICB9XG5cbiAgICBsZWdlbmQubW92ZVRvKHggKyBvZmZzZXRYLCB5ICsgb2Zmc2V0WSk7XG4gIH07XG5cbiAgX3Byb3RvLmFsaWduTGVnZW5kcyA9IGZ1bmN0aW9uIGFsaWduTGVnZW5kcygpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxlZ2VuZHMgPSBzZWxmLmxlZ2VuZHM7XG4gICAgVXRpbC5lYWNoKGxlZ2VuZHMsIGZ1bmN0aW9uIChsZWdlbmRJdGVtcywgcG9zaXRpb24pIHtcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRJdGVtcywgZnVuY3Rpb24gKGxlZ2VuZCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIHByZSA9IGxlZ2VuZEl0ZW1zW2luZGV4IC0gMV07XG5cbiAgICAgICAgc2VsZi5fYWxpZ25MZWdlbmQobGVnZW5kLCBwcmUsIHBvc2l0aW9uKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIF9wcm90by5oYW5kbGVFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUV2ZW50KGV2KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gZmluZEl0ZW0oeCwgeSkge1xuICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICB2YXIgbGVnZW5kcyA9IHNlbGYubGVnZW5kcztcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRzLCBmdW5jdGlvbiAobGVnZW5kSXRlbXMpIHtcbiAgICAgICAgVXRpbC5lYWNoKGxlZ2VuZEl0ZW1zLCBmdW5jdGlvbiAobGVnZW5kKSB7XG4gICAgICAgICAgdmFyIGl0ZW1zR3JvdXAgPSBsZWdlbmQuaXRlbXNHcm91cCxcbiAgICAgICAgICAgICAgbGVnZW5kSGl0Qm94ZXMgPSBsZWdlbmQubGVnZW5kSGl0Qm94ZXM7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuID0gaXRlbXNHcm91cC5nZXQoJ2NoaWxkcmVuJyk7XG5cbiAgICAgICAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbGVnZW5kUG9zWCA9IGxlZ2VuZC54O1xuICAgICAgICAgICAgdmFyIGxlZ2VuZFBvc1kgPSBsZWdlbmQueTtcbiAgICAgICAgICAgIFV0aWwuZWFjaChsZWdlbmRIaXRCb3hlcywgZnVuY3Rpb24gKGJveCwgaW5kZXgpIHtcbiAgICAgICAgICAgICAgaWYgKHggPj0gYm94LnggKyBsZWdlbmRQb3NYICYmIHggPD0gYm94LnggKyBib3gud2lkdGggKyBsZWdlbmRQb3NYICYmIHkgPj0gYm94LnkgKyBsZWdlbmRQb3NZICYmIHkgPD0gYm94LmhlaWdodCArIGJveC55ICsgbGVnZW5kUG9zWSkge1xuICAgICAgICAgICAgICAgIC8vIGluYm94XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgY2xpY2tlZEl0ZW06IGNoaWxkcmVuW2luZGV4XSxcbiAgICAgICAgICAgICAgICAgIGNsaWNrZWRMZWdlbmQ6IGxlZ2VuZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBjaGFydCA9IHNlbGYuY2hhcnQ7XG5cbiAgICB2YXIgX1V0aWwkY3JlYXRlRXZlbnQgPSBVdGlsLmNyZWF0ZUV2ZW50KGV2LCBjaGFydCksXG4gICAgICAgIHggPSBfVXRpbCRjcmVhdGVFdmVudC54LFxuICAgICAgICB5ID0gX1V0aWwkY3JlYXRlRXZlbnQueTtcblxuICAgIHZhciBjbGlja2VkID0gZmluZEl0ZW0oeCwgeSk7XG5cbiAgICBpZiAoY2xpY2tlZCAmJiBjbGlja2VkLmNsaWNrZWRMZWdlbmQuY2xpY2thYmxlICE9PSBmYWxzZSkge1xuICAgICAgdmFyIGNsaWNrZWRJdGVtID0gY2xpY2tlZC5jbGlja2VkSXRlbSxcbiAgICAgICAgICBjbGlja2VkTGVnZW5kID0gY2xpY2tlZC5jbGlja2VkTGVnZW5kO1xuXG4gICAgICBpZiAoY2xpY2tlZExlZ2VuZC5vbkNsaWNrKSB7XG4gICAgICAgIGV2LmNsaWNrZWRJdGVtID0gY2xpY2tlZEl0ZW07XG4gICAgICAgIGNsaWNrZWRMZWdlbmQub25DbGljayhldik7XG4gICAgICB9IGVsc2UgaWYgKCFjbGlja2VkTGVnZW5kLmN1c3RvbSkge1xuICAgICAgICB2YXIgY2hlY2tlZCA9IGNsaWNrZWRJdGVtLmdldCgnY2hlY2tlZCcpO1xuICAgICAgICB2YXIgdmFsdWUgPSBjbGlja2VkSXRlbS5nZXQoJ2RhdGFWYWx1ZScpO1xuICAgICAgICB2YXIgZmlsdGVyVmFscyA9IGNsaWNrZWRMZWdlbmQuZmlsdGVyVmFscyxcbiAgICAgICAgICAgIGZpZWxkID0gY2xpY2tlZExlZ2VuZC5maWVsZCxcbiAgICAgICAgICAgIHNlbGVjdGVkTW9kZSA9IGNsaWNrZWRMZWdlbmQuc2VsZWN0ZWRNb2RlO1xuICAgICAgICB2YXIgaXNTaW5nZVNlbGVjdGVkID0gc2VsZWN0ZWRNb2RlID09PSAnc2luZ2xlJztcblxuICAgICAgICBpZiAoaXNTaW5nZVNlbGVjdGVkKSB7XG4gICAgICAgICAgY2hhcnQuZmlsdGVyKGZpZWxkLCBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsID09PSB2YWx1ZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWNoZWNrZWQpIHtcbiAgICAgICAgICAgIGZpbHRlclZhbHMucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFV0aWwuQXJyYXkucmVtb3ZlKGZpbHRlclZhbHMsIHZhbHVlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjaGFydC5maWx0ZXIoZmllbGQsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJWYWxzLmluZGV4T2YodmFsKSAhPT0gLTE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGFydC5yZXBhaW50KCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5iaW5kRXZlbnRzID0gZnVuY3Rpb24gYmluZEV2ZW50cygpIHtcbiAgICB2YXIgbGVnZW5kQ2ZnID0gdGhpcy5sZWdlbmRDZmc7XG4gICAgdmFyIHRyaWdnZXJPbiA9IGxlZ2VuZENmZy50cmlnZ2VyT24gfHwgJ3RvdWNoc3RhcnQnO1xuICAgIHZhciBtZXRob2QgPSBVdGlsLndyYXBCZWhhdmlvcih0aGlzLCAnaGFuZGxlRXZlbnQnKTtcbiAgICBVdGlsLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXNEb20sIHRyaWdnZXJPbiwgbWV0aG9kKTtcbiAgfTtcblxuICBfcHJvdG8udW5CaW5kRXZlbnRzID0gZnVuY3Rpb24gdW5CaW5kRXZlbnRzKCkge1xuICAgIHZhciBsZWdlbmRDZmcgPSB0aGlzLmxlZ2VuZENmZztcbiAgICB2YXIgdHJpZ2dlck9uID0gbGVnZW5kQ2ZnLnRyaWdnZXJPbiB8fCAndG91Y2hzdGFydCc7XG4gICAgdmFyIG1ldGhvZCA9IFV0aWwuZ2V0V3JhcEJlaGF2aW9yKHRoaXMsICdoYW5kbGVFdmVudCcpO1xuICAgIFV0aWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhc0RvbSwgdHJpZ2dlck9uLCBtZXRob2QpO1xuICB9O1xuXG4gIHJldHVybiBMZWdlbmRDb250cm9sbGVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5pdDogZnVuY3Rpb24gaW5pdChjaGFydCkge1xuICAgIHZhciBsZWdlbmRDb250cm9sbGVyID0gbmV3IExlZ2VuZENvbnRyb2xsZXIoe1xuICAgICAgY29udGFpbmVyOiBjaGFydC5nZXQoJ2JhY2tQbG90JyksXG4gICAgICBwbG90UmFuZ2U6IGNoYXJ0LmdldCgncGxvdFJhbmdlJyksXG4gICAgICBjaGFydDogY2hhcnRcbiAgICB9KTtcbiAgICBjaGFydC5zZXQoJ2xlZ2VuZENvbnRyb2xsZXInLCBsZWdlbmRDb250cm9sbGVyKTtcblxuICAgIGNoYXJ0LmxlZ2VuZCA9IGZ1bmN0aW9uIChmaWVsZCwgY2ZnKSB7XG4gICAgICB2YXIgbGVnZW5kQ2ZnID0gbGVnZW5kQ29udHJvbGxlci5sZWdlbmRDZmc7XG4gICAgICBsZWdlbmRDb250cm9sbGVyLmVuYWJsZSA9IHRydWU7XG5cbiAgICAgIGlmIChVdGlsLmlzQm9vbGVhbihmaWVsZCkpIHtcbiAgICAgICAgbGVnZW5kQ29udHJvbGxlci5lbmFibGUgPSBmaWVsZDtcbiAgICAgICAgbGVnZW5kQ2ZnID0gY2ZnIHx8IHt9O1xuICAgICAgfSBlbHNlIGlmIChVdGlsLmlzT2JqZWN0KGZpZWxkKSkge1xuICAgICAgICBsZWdlbmRDZmcgPSBmaWVsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxlZ2VuZENmZ1tmaWVsZF0gPSBjZmc7XG4gICAgICB9XG5cbiAgICAgIGxlZ2VuZENvbnRyb2xsZXIubGVnZW5kQ2ZnID0gbGVnZW5kQ2ZnO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfSxcbiAgYmVmb3JlR2VvbURyYXc6IGZ1bmN0aW9uIGJlZm9yZUdlb21EcmF3KGNoYXJ0KSB7XG4gICAgdmFyIGxlZ2VuZENvbnRyb2xsZXIgPSBjaGFydC5nZXQoJ2xlZ2VuZENvbnRyb2xsZXInKTtcbiAgICBpZiAoIWxlZ2VuZENvbnRyb2xsZXIuZW5hYmxlKSByZXR1cm4gbnVsbDsgLy8gbGVnZW5kIGlzIG5vdCBkaXNwbGF5ZWRcblxuICAgIHZhciBsZWdlbmRDZmcgPSBsZWdlbmRDb250cm9sbGVyLmxlZ2VuZENmZztcblxuICAgIGlmIChsZWdlbmRDZmcgJiYgbGVnZW5kQ2ZnLmN1c3RvbSkge1xuICAgICAgbGVnZW5kQ29udHJvbGxlci5hZGRDdXN0b21MZWdlbmQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGxlZ2VuZEl0ZW1zID0gY2hhcnQuZ2V0TGVnZW5kSXRlbXMoKTtcbiAgICAgIHZhciBzY2FsZXMgPSBjaGFydC5nZXQoJ3NjYWxlcycpO1xuICAgICAgdmFyIGZpbHRlcnMgPSBjaGFydC5nZXQoJ2ZpbHRlcnMnKTtcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRJdGVtcywgZnVuY3Rpb24gKGl0ZW1zLCBmaWVsZCkge1xuICAgICAgICB2YXIgc2NhbGUgPSBzY2FsZXNbZmllbGRdO1xuICAgICAgICB2YXIgdmFsdWVzID0gc2NhbGUudmFsdWVzO1xuICAgICAgICB2YXIgZmlsdGVyVmFscztcblxuICAgICAgICBpZiAoZmlsdGVycyAmJiBmaWx0ZXJzW2ZpZWxkXSkge1xuICAgICAgICAgIGZpbHRlclZhbHMgPSB2YWx1ZXMuZmlsdGVyKGZpbHRlcnNbZmllbGRdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmaWx0ZXJWYWxzID0gdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGVnZW5kQ29udHJvbGxlci5hZGRMZWdlbmQoc2NhbGUsIGl0ZW1zLCBmaWx0ZXJWYWxzKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChsZWdlbmRDZmcgJiYgbGVnZW5kQ2ZnLmNsaWNrYWJsZSAhPT0gZmFsc2UpIHtcbiAgICAgIGxlZ2VuZENvbnRyb2xsZXIuYmluZEV2ZW50cygpO1xuICAgIH1cblxuICAgIHZhciBsZWdlbmRzID0gbGVnZW5kQ29udHJvbGxlci5sZWdlbmRzO1xuICAgIHZhciBsZWdlbmRSYW5nZSA9IHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gICAgVXRpbC5lYWNoKGxlZ2VuZHMsIGZ1bmN0aW9uIChsZWdlbmRJdGVtcywgcG9zaXRpb24pIHtcbiAgICAgIHZhciBwYWRkaW5nID0gMDtcbiAgICAgIFV0aWwuZWFjaChsZWdlbmRJdGVtcywgZnVuY3Rpb24gKGxlZ2VuZCkge1xuICAgICAgICB2YXIgd2lkdGggPSBsZWdlbmQuZ2V0V2lkdGgoKTtcbiAgICAgICAgdmFyIGhlaWdodCA9IGxlZ2VuZC5nZXRIZWlnaHQoKTtcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09ICd0b3AnIHx8IHBvc2l0aW9uID09PSAnYm90dG9tJykge1xuICAgICAgICAgIHBhZGRpbmcgPSBNYXRoLm1heChwYWRkaW5nLCBoZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKGxlZ2VuZC5vZmZzZXRZID4gMCkge1xuICAgICAgICAgICAgcGFkZGluZyArPSBsZWdlbmQub2Zmc2V0WTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGFkZGluZyA9IE1hdGgubWF4KHBhZGRpbmcsIHdpZHRoKTtcblxuICAgICAgICAgIGlmIChsZWdlbmQub2Zmc2V0WCA+IDApIHtcbiAgICAgICAgICAgIHBhZGRpbmcgKz0gbGVnZW5kLm9mZnNldFg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGxlZ2VuZFJhbmdlW3Bvc2l0aW9uXSA9IHBhZGRpbmcgKyBnZXRQYWRkaW5nQnlQb3MocG9zaXRpb24sIGNoYXJ0LmdldCgnYXBwZW5kUGFkZGluZycpKTtcbiAgICB9KTtcbiAgICBjaGFydC5zZXQoJ2xlZ2VuZFJhbmdlJywgbGVnZW5kUmFuZ2UpO1xuICB9LFxuICBhZnRlckdlb21EcmF3OiBmdW5jdGlvbiBhZnRlckdlb21EcmF3KGNoYXJ0KSB7XG4gICAgdmFyIGxlZ2VuZENvbnRyb2xsZXIgPSBjaGFydC5nZXQoJ2xlZ2VuZENvbnRyb2xsZXInKTtcbiAgICBsZWdlbmRDb250cm9sbGVyLmFsaWduTGVnZW5kcygpO1xuICB9LFxuICBjbGVhcklubmVyOiBmdW5jdGlvbiBjbGVhcklubmVyKGNoYXJ0KSB7XG4gICAgdmFyIGxlZ2VuZENvbnRyb2xsZXIgPSBjaGFydC5nZXQoJ2xlZ2VuZENvbnRyb2xsZXInKTtcbiAgICBsZWdlbmRDb250cm9sbGVyLmNsZWFyKCk7XG4gICAgY2hhcnQuc2V0KCdsZWdlbmRSYW5nZScsIG51bGwpO1xuICB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIEhhbmRsZSB0aGUgZGV0YWlsIGFuaW1hdGlvbnNcbiAqIEBhdXRob3Igc2ltYS56aGFuZzE5OTBAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxudmFyIEVsZW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxudmFyIFRpbWVsaW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzIpO1xuXG52YXIgQW5pbWF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzMyk7XG5cbnZhciBBbmltYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpO1xuXG52YXIgU2hhcGVBY3Rpb24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzNSk7XG5cbnZhciBHcm91cEFjdGlvbiA9IF9fd2VicGFja19yZXF1aXJlX18oMTM2KTtcblxudmFyIENoYXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbnZhciB0aW1lbGluZTtcblxuRWxlbWVudC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF0dHJzID0gVXRpbC5taXgoe30sIHRoaXMuZ2V0KCdhdHRycycpKTtcbiAgcmV0dXJuIG5ldyBBbmltYXRvcih0aGlzLCBhdHRycywgdGltZWxpbmUpO1xufTtcblxuQ2hhcnQucHJvdG90eXBlLmFuaW1hdGUgPSBmdW5jdGlvbiAoY2ZnKSB7XG4gIHRoaXMuc2V0KCdhbmltYXRlJywgY2ZnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5BbmltYXRlLkFjdGlvbiA9IFNoYXBlQWN0aW9uO1xuQW5pbWF0ZS5kZWZhdWx0Q2ZnID0ge1xuICBpbnRlcnZhbDoge1xuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcihjb29yZCkge1xuICAgICAgaWYgKGNvb3JkLmlzUG9sYXIgJiYgY29vcmQudHJhbnNwb3NlZCkge1xuICAgICAgICAvLyBmb3IgcGllIGNoYXJ0XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICBzaGFwZS5zZXQoJ3pJbmRleCcsIC0xKTtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gc2hhcGUuZ2V0KCdwYXJlbnQnKTtcbiAgICAgICAgICBjb250YWluZXIuc29ydCgpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gU2hhcGVBY3Rpb24uZmFkZUluO1xuICAgIH1cbiAgfSxcbiAgYXJlYToge1xuICAgIGVudGVyOiBmdW5jdGlvbiBlbnRlcihjb29yZCkge1xuICAgICAgaWYgKGNvb3JkLmlzUG9sYXIpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIFNoYXBlQWN0aW9uLmZhZGVJbjtcbiAgICB9XG4gIH0sXG4gIGxpbmU6IHtcbiAgICBlbnRlcjogZnVuY3Rpb24gZW50ZXIoY29vcmQpIHtcbiAgICAgIGlmIChjb29yZC5pc1BvbGFyKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiBTaGFwZUFjdGlvbi5mYWRlSW47XG4gICAgfVxuICB9LFxuICBwYXRoOiB7XG4gICAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKGNvb3JkKSB7XG4gICAgICBpZiAoY29vcmQuaXNQb2xhcikgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gU2hhcGVBY3Rpb24uZmFkZUluO1xuICAgIH1cbiAgfVxufTtcbnZhciBHUk9VUF9BTklNQVRJT04gPSB7XG4gIGxpbmU6IGZ1bmN0aW9uIGxpbmUoY29vcmQpIHtcbiAgICBpZiAoY29vcmQuaXNQb2xhcikge1xuICAgICAgcmV0dXJuIEdyb3VwQWN0aW9uLmdyb3VwU2NhbGVJblhZO1xuICAgIH1cblxuICAgIHJldHVybiBHcm91cEFjdGlvbi5ncm91cFdhdmVJbjtcbiAgfSxcbiAgYXJlYTogZnVuY3Rpb24gYXJlYShjb29yZCkge1xuICAgIGlmIChjb29yZC5pc1BvbGFyKSB7XG4gICAgICByZXR1cm4gR3JvdXBBY3Rpb24uZ3JvdXBTY2FsZUluWFk7XG4gICAgfVxuXG4gICAgcmV0dXJuIEdyb3VwQWN0aW9uLmdyb3VwV2F2ZUluO1xuICB9LFxuICBwYXRoOiBmdW5jdGlvbiBwYXRoKGNvb3JkKSB7XG4gICAgaWYgKGNvb3JkLmlzUG9sYXIpIHtcbiAgICAgIHJldHVybiBHcm91cEFjdGlvbi5ncm91cFNjYWxlSW5YWTtcbiAgICB9XG5cbiAgICByZXR1cm4gR3JvdXBBY3Rpb24uZ3JvdXBXYXZlSW47XG4gIH0sXG4gIHBvaW50OiBmdW5jdGlvbiBwb2ludCgpIHtcbiAgICByZXR1cm4gR3JvdXBBY3Rpb24uc2hhcGVzU2NhbGVJblhZO1xuICB9LFxuICBpbnRlcnZhbDogZnVuY3Rpb24gaW50ZXJ2YWwoY29vcmQpIHtcbiAgICB2YXIgcmVzdWx0O1xuXG4gICAgaWYgKGNvb3JkLmlzUG9sYXIpIHtcbiAgICAgIC8vIHBvbGFyIGNvb2RpbmF0ZVxuICAgICAgcmVzdWx0ID0gR3JvdXBBY3Rpb24uZ3JvdXBTY2FsZUluWFk7XG5cbiAgICAgIGlmIChjb29yZC50cmFuc3Bvc2VkKSB7XG4gICAgICAgIC8vIHBpZSBjaGFydFxuICAgICAgICByZXN1bHQgPSBHcm91cEFjdGlvbi5ncm91cFdhdmVJbjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0ID0gY29vcmQudHJhbnNwb3NlZCA/IEdyb3VwQWN0aW9uLmdyb3VwU2NhbGVJblggOiBHcm91cEFjdGlvbi5ncm91cFNjYWxlSW5ZO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG4gIHNjaGVtYTogZnVuY3Rpb24gc2NoZW1hKCkge1xuICAgIHJldHVybiBHcm91cEFjdGlvbi5ncm91cFdhdmVJbjtcbiAgfVxufTtcblxuZnVuY3Rpb24gZGlmZihmcm9tQXR0cnMsIHRvQXR0cnMpIHtcbiAgdmFyIGVuZFN0YXRlID0ge307XG5cbiAgZm9yICh2YXIgayBpbiB0b0F0dHJzKSB7XG4gICAgaWYgKFV0aWwuaXNOdW1iZXIoZnJvbUF0dHJzW2tdKSAmJiBmcm9tQXR0cnNba10gIT09IHRvQXR0cnNba10pIHtcbiAgICAgIGVuZFN0YXRlW2tdID0gdG9BdHRyc1trXTtcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNBcnJheShmcm9tQXR0cnNba10pICYmIEpTT04uc3RyaW5naWZ5KGZyb21BdHRyc1trXSkgIT09IEpTT04uc3RyaW5naWZ5KHRvQXR0cnNba10pKSB7XG4gICAgICBlbmRTdGF0ZVtrXSA9IHRvQXR0cnNba107XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVuZFN0YXRlO1xufSAvLyBBZGQgYSB1bmlxdWUgaWQgaWRlbnRpZmllciB0byBlYWNoIHNoYXBlXG5cblxuZnVuY3Rpb24gX2dldFNoYXBlSWQoZ2VvbSwgZGF0YU9iaiwgZ2VvbUlkeCkge1xuICB2YXIgdHlwZSA9IGdlb20uZ2V0KCd0eXBlJyk7XG4gIHZhciBpZCA9ICdnZW9tJyArIGdlb21JZHggKyAnLScgKyB0eXBlO1xuICB2YXIgeFNjYWxlID0gZ2VvbS5nZXRYU2NhbGUoKTtcbiAgdmFyIHlTY2FsZSA9IGdlb20uZ2V0WVNjYWxlKCk7XG4gIHZhciB4RmllbGQgPSB4U2NhbGUuZmllbGQgfHwgJ3gnO1xuICB2YXIgeUZpZWxkID0geVNjYWxlLmZpZWxkIHx8ICd5JztcbiAgdmFyIHlWYWwgPSBkYXRhT2JqW3lGaWVsZF07XG4gIHZhciB4VmFsO1xuXG4gIGlmICh4U2NhbGUuaXNJZGVudGl0eSkge1xuICAgIHhWYWwgPSB4U2NhbGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgeFZhbCA9IGRhdGFPYmpbeEZpZWxkXTtcbiAgfVxuXG4gIGlmICh0eXBlID09PSAnaW50ZXJ2YWwnIHx8IHR5cGUgPT09ICdzY2hlbWEnKSB7XG4gICAgaWQgKz0gJy0nICsgeFZhbDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbGluZScgfHwgdHlwZSA9PT0gJ2FyZWEnIHx8IHR5cGUgPT09ICdwYXRoJykge1xuICAgIGlkICs9ICctJyArIHR5cGU7XG4gIH0gZWxzZSB7XG4gICAgaWQgKz0geFNjYWxlLmlzQ2F0ZWdvcnkgPyAnLScgKyB4VmFsIDogJy0nICsgeFZhbCArICctJyArIHlWYWw7XG4gIH1cblxuICB2YXIgZ3JvdXBTY2FsZXMgPSBnZW9tLl9nZXRHcm91cFNjYWxlcygpO1xuXG4gIFV0aWwuZWFjaChncm91cFNjYWxlcywgZnVuY3Rpb24gKGdyb3VwU2NhbGUpIHtcbiAgICB2YXIgZmllbGQgPSBncm91cFNjYWxlLmZpZWxkO1xuXG4gICAgaWYgKGdyb3VwU2NhbGUudHlwZSAhPT0gJ2lkZW50aXR5Jykge1xuICAgICAgaWQgKz0gJy0nICsgZGF0YU9ialtmaWVsZF07XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlkO1xufSAvLyBnZXQgZ2VvbWV0cnkncyBzaGFwZXNcblxuXG5mdW5jdGlvbiBnZXRTaGFwZXMoZ2VvbXMsIGNoYXJ0LCBjb29yZCkge1xuICB2YXIgc2hhcGVzID0gW107XG4gIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20sIGdlb21JZHgpIHtcbiAgICB2YXIgZ2VvbUNvbnRhaW5lciA9IGdlb20uZ2V0KCdjb250YWluZXInKTtcbiAgICB2YXIgZ2VvbVNoYXBlcyA9IGdlb21Db250YWluZXIuZ2V0KCdjaGlsZHJlbicpO1xuICAgIHZhciB0eXBlID0gZ2VvbS5nZXQoJ3R5cGUnKTtcbiAgICB2YXIgYW5pbWF0ZUNmZyA9IFV0aWwuaXNOaWwoZ2VvbS5nZXQoJ2FuaW1hdGVDZmcnKSkgPyBfZ2V0QW5pbWF0ZUNmZ0J5U2hhcGVUeXBlKHR5cGUsIGNoYXJ0KSA6IGdlb20uZ2V0KCdhbmltYXRlQ2ZnJyk7XG5cbiAgICBpZiAoYW5pbWF0ZUNmZyAhPT0gZmFsc2UpIHtcbiAgICAgIFV0aWwuZWFjaChnZW9tU2hhcGVzLCBmdW5jdGlvbiAoc2hhcGUsIGluZGV4KSB7XG4gICAgICAgIGlmIChzaGFwZS5nZXQoJ2NsYXNzTmFtZScpID09PSB0eXBlKSB7XG4gICAgICAgICAgc2hhcGUuX2lkID0gX2dldFNoYXBlSWQoZ2VvbSwgc2hhcGUuZ2V0KCdvcmlnaW4nKS5fb3JpZ2luLCBnZW9tSWR4KTtcbiAgICAgICAgICBzaGFwZS5zZXQoJ2Nvb3JkJywgY29vcmQpO1xuICAgICAgICAgIHNoYXBlLnNldCgnYW5pbWF0ZUNmZycsIGFuaW1hdGVDZmcpO1xuICAgICAgICAgIHNoYXBlLnNldCgnaW5kZXgnLCBpbmRleCk7XG4gICAgICAgICAgc2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBnZW9tLnNldCgnc2hhcGVzJywgZ2VvbVNoYXBlcyk7XG4gIH0pO1xuICByZXR1cm4gc2hhcGVzO1xufVxuXG5mdW5jdGlvbiBjYWNoZShzaGFwZXMpIHtcbiAgdmFyIHJzdCA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzaGFwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgc2hhcGUgPSBzaGFwZXNbaV07XG4gICAgaWYgKCFzaGFwZS5faWQgfHwgc2hhcGUuaXNDbGlwKSBjb250aW51ZTtcbiAgICB2YXIgaWQgPSBzaGFwZS5faWQ7XG4gICAgcnN0W2lkXSA9IHtcbiAgICAgIF9pZDogaWQsXG4gICAgICB0eXBlOiBzaGFwZS5nZXQoJ3R5cGUnKSxcbiAgICAgIC8vIHRoZSB0eXBlIG9mIHNoYXBlXG4gICAgICBhdHRyczogVXRpbC5taXgoe30sIHNoYXBlLl9hdHRycy5hdHRycyksXG4gICAgICAvLyB0aGUgZ3JhcGhpY3MgYXR0cmlidXRlcyBvZiBzaGFwZVxuICAgICAgY2xhc3NOYW1lOiBzaGFwZS5nZXQoJ2NsYXNzTmFtZScpLFxuICAgICAgZ2VvbVR5cGU6IHNoYXBlLmdldCgnY2xhc3NOYW1lJyksXG4gICAgICBpbmRleDogc2hhcGUuZ2V0KCdpbmRleCcpLFxuICAgICAgY29vcmQ6IHNoYXBlLmdldCgnY29vcmQnKSxcbiAgICAgIGFuaW1hdGVDZmc6IHNoYXBlLmdldCgnYW5pbWF0ZUNmZycpXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiByc3Q7XG59XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGUoZ2VvbVR5cGUsIGNvb3JkLCBhbmltYXRpb25UeXBlLCBhbmltYXRpb25OYW1lKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgaWYgKFV0aWwuaXNGdW5jdGlvbihhbmltYXRpb25OYW1lKSkge1xuICAgIHJlc3VsdCA9IGFuaW1hdGlvbk5hbWU7XG4gIH0gZWxzZSBpZiAoVXRpbC5pc1N0cmluZyhhbmltYXRpb25OYW1lKSkge1xuICAgIHJlc3VsdCA9IEFuaW1hdGUuQWN0aW9uW2FuaW1hdGlvbk5hbWVdO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9IEFuaW1hdGUuZ2V0QW5pbWF0aW9uKGdlb21UeXBlLCBjb29yZCwgYW5pbWF0aW9uVHlwZSk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBnZXRBbmltYXRlQ2ZnKGdlb21UeXBlLCBhbmltYXRpb25UeXBlLCBhbmltYXRlQ2ZnKSB7XG4gIGlmIChhbmltYXRlQ2ZnID09PSBmYWxzZSB8fCBVdGlsLmlzT2JqZWN0KGFuaW1hdGVDZmcpICYmIGFuaW1hdGVDZmdbYW5pbWF0aW9uVHlwZV0gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGRlZmF1bHRDZmcgPSBBbmltYXRlLmdldEFuaW1hdGVDZmcoZ2VvbVR5cGUsIGFuaW1hdGlvblR5cGUpO1xuXG4gIGlmIChhbmltYXRlQ2ZnICYmIGFuaW1hdGVDZmdbYW5pbWF0aW9uVHlwZV0pIHtcbiAgICByZXR1cm4gVXRpbC5kZWVwTWl4KHt9LCBkZWZhdWx0Q2ZnLCBhbmltYXRlQ2ZnW2FuaW1hdGlvblR5cGVdKTtcbiAgfVxuXG4gIHJldHVybiBkZWZhdWx0Q2ZnO1xufVxuXG5mdW5jdGlvbiBhZGRBbmltYXRlKGNhY2hlLCBzaGFwZXMsIGNhbnZhcykge1xuICB2YXIgYW5pbWF0ZTtcbiAgdmFyIGFuaW1hdGVDZmc7IC8vIHRoZSBvcmRlciBvZiBhbmltYXRpb246IGxlYXZlIC0+IHVwZGF0ZSAtPiBlbnRlclxuXG4gIHZhciB1cGRhdGVTaGFwZXMgPSBbXTtcbiAgdmFyIG5ld1NoYXBlcyA9IFtdO1xuICBVdGlsLmVhY2goc2hhcGVzLCBmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gY2FjaGVbc2hhcGUuX2lkXTtcblxuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICBuZXdTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlLnNldCgnY2FjaGVTaGFwZScsIHJlc3VsdCk7XG4gICAgICB1cGRhdGVTaGFwZXMucHVzaChzaGFwZSk7XG4gICAgICBkZWxldGUgY2FjaGVbc2hhcGUuX2lkXTtcbiAgICB9XG4gIH0pOyAvLyBmaXJzdCBkbyB0aGUgbGVhdmUgYW5pbWF0aW9uXG5cbiAgVXRpbC5lYWNoKGNhY2hlLCBmdW5jdGlvbiAoZGVsZXRlZFNoYXBlKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9IGRlbGV0ZWRTaGFwZS5jbGFzc05hbWUsXG4gICAgICAgIGNvb3JkID0gZGVsZXRlZFNoYXBlLmNvb3JkLFxuICAgICAgICBfaWQgPSBkZWxldGVkU2hhcGUuX2lkLFxuICAgICAgICBhdHRycyA9IGRlbGV0ZWRTaGFwZS5hdHRycyxcbiAgICAgICAgaW5kZXggPSBkZWxldGVkU2hhcGUuaW5kZXgsXG4gICAgICAgIHR5cGUgPSBkZWxldGVkU2hhcGUudHlwZTtcbiAgICBhbmltYXRlQ2ZnID0gZ2V0QW5pbWF0ZUNmZyhjbGFzc05hbWUsICdsZWF2ZScsIGRlbGV0ZWRTaGFwZS5hbmltYXRlQ2ZnKTtcbiAgICBpZiAoYW5pbWF0ZUNmZyA9PT0gZmFsc2UpIHJldHVybiB0cnVlO1xuICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKGNsYXNzTmFtZSwgY29vcmQsICdsZWF2ZScsIGFuaW1hdGVDZmcuYW5pbWF0aW9uKTtcblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZSkpIHtcbiAgICAgIHZhciB0ZW1wU2hhcGUgPSBjYW52YXMuYWRkU2hhcGUodHlwZSwge1xuICAgICAgICBhdHRyczogYXR0cnMsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY2FudmFzOiBjYW52YXMsXG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3NOYW1lXG4gICAgICB9KTtcbiAgICAgIHRlbXBTaGFwZS5faWQgPSBfaWQ7XG4gICAgICBhbmltYXRlKHRlbXBTaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpO1xuICAgIH1cbiAgfSk7IC8vIHRoZW4gZG8gdGhlIHVwZGF0ZSBhbmltYXRpb25cblxuICBVdGlsLmVhY2godXBkYXRlU2hhcGVzLCBmdW5jdGlvbiAodXBkYXRlU2hhcGUpIHtcbiAgICB2YXIgY2xhc3NOYW1lID0gdXBkYXRlU2hhcGUuZ2V0KCdjbGFzc05hbWUnKTtcbiAgICBhbmltYXRlQ2ZnID0gZ2V0QW5pbWF0ZUNmZyhjbGFzc05hbWUsICd1cGRhdGUnLCB1cGRhdGVTaGFwZS5nZXQoJ2FuaW1hdGVDZmcnKSk7XG4gICAgaWYgKGFuaW1hdGVDZmcgPT09IGZhbHNlKSByZXR1cm4gdHJ1ZTtcbiAgICB2YXIgY29vcmQgPSB1cGRhdGVTaGFwZS5nZXQoJ2Nvb3JkJyk7XG4gICAgdmFyIGNhY2hlQXR0cnMgPSB1cGRhdGVTaGFwZS5nZXQoJ2NhY2hlU2hhcGUnKS5hdHRycztcbiAgICB2YXIgZW5kU3RhdGUgPSBkaWZmKGNhY2hlQXR0cnMsIHVwZGF0ZVNoYXBlLl9hdHRycy5hdHRycyk7IC8vIOWIpOaWreWmguaenOWxnuaAp+ebuOWQjOeahOivneWwseS4jei/m+ihjOWPmOaNolxuXG4gICAgaWYgKE9iamVjdC5rZXlzKGVuZFN0YXRlKS5sZW5ndGgpIHtcbiAgICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKGNsYXNzTmFtZSwgY29vcmQsICd1cGRhdGUnLCBhbmltYXRlQ2ZnLmFuaW1hdGlvbik7XG5cbiAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZSkpIHtcbiAgICAgICAgYW5pbWF0ZSh1cGRhdGVTaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXBkYXRlU2hhcGUuYXR0cihjYWNoZUF0dHJzKTtcbiAgICAgICAgdXBkYXRlU2hhcGUuYW5pbWF0ZSgpLnRvKHtcbiAgICAgICAgICBhdHRyczogZW5kU3RhdGUsXG4gICAgICAgICAgZHVyYXRpb246IGFuaW1hdGVDZmcuZHVyYXRpb24sXG4gICAgICAgICAgZWFzaW5nOiBhbmltYXRlQ2ZnLmVhc2luZyxcbiAgICAgICAgICBkZWxheTogYW5pbWF0ZUNmZy5kZWxheVxuICAgICAgICB9KS5vbkVuZChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdXBkYXRlU2hhcGUuc2V0KCdjYWNoZVNoYXBlJywgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7IC8vIGxhc3QsIGVudGVyIGFuaW1hdGlvblxuXG4gIFV0aWwuZWFjaChuZXdTaGFwZXMsIGZ1bmN0aW9uIChuZXdTaGFwZSkge1xuICAgIC8vIOaWsOWbvuW9ouWFg+e0oOeahOi/m+WcuuWFg+e0oFxuICAgIHZhciBjbGFzc05hbWUgPSBuZXdTaGFwZS5nZXQoJ2NsYXNzTmFtZScpO1xuICAgIHZhciBjb29yZCA9IG5ld1NoYXBlLmdldCgnY29vcmQnKTtcbiAgICBhbmltYXRlQ2ZnID0gZ2V0QW5pbWF0ZUNmZyhjbGFzc05hbWUsICdlbnRlcicsIG5ld1NoYXBlLmdldCgnYW5pbWF0ZUNmZycpKTtcbiAgICBpZiAoYW5pbWF0ZUNmZyA9PT0gZmFsc2UpIHJldHVybiB0cnVlO1xuICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKGNsYXNzTmFtZSwgY29vcmQsICdlbnRlcicsIGFuaW1hdGVDZmcuYW5pbWF0aW9uKTtcblxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oYW5pbWF0ZSkpIHtcbiAgICAgIGlmIChjbGFzc05hbWUgPT09ICdpbnRlcnZhbCcgJiYgY29vcmQuaXNQb2xhciAmJiBjb29yZC50cmFuc3Bvc2VkKSB7XG4gICAgICAgIHZhciBpbmRleCA9IG5ld1NoYXBlLmdldCgnaW5kZXgnKTtcbiAgICAgICAgdmFyIGxhc3RTaGFwZSA9IHVwZGF0ZVNoYXBlc1tpbmRleCAtIDFdO1xuICAgICAgICBhbmltYXRlKG5ld1NoYXBlLCBhbmltYXRlQ2ZnLCBsYXN0U2hhcGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0ZShuZXdTaGFwZSwgYW5pbWF0ZUNmZywgY29vcmQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIF9nZXRBbmltYXRlQ2ZnQnlTaGFwZVR5cGUodHlwZSwgY2hhcnQpIHtcbiAgaWYgKCF0eXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgYW5pbWF0ZUNmZyA9IGNoYXJ0LmdldCgnYW5pbWF0ZScpO1xuXG4gIGlmICh0eXBlLmluZGV4T2YoJ2d1aWRlLXRhZycpID4gLTEpIHtcbiAgICB0eXBlID0gJ2d1aWRlLXRhZyc7XG4gIH1cblxuICBpZiAoVXRpbC5pc09iamVjdChhbmltYXRlQ2ZnKSkge1xuICAgIHJldHVybiBhbmltYXRlQ2ZnW3R5cGVdO1xuICB9XG5cbiAgaWYgKGFuaW1hdGVDZmcgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZnRlckNhbnZhc0luaXQ6IGZ1bmN0aW9uIGFmdGVyQ2FudmFzSW5pdCgpXG4gIC8qIGNoYXJ0ICovXG4gIHtcbiAgICB0aW1lbGluZSA9IG5ldyBUaW1lbGluZSgpO1xuICAgIHRpbWVsaW5lLnBsYXkoKTtcbiAgfSxcbiAgYmVmb3JlQ2FudmFzRHJhdzogZnVuY3Rpb24gYmVmb3JlQ2FudmFzRHJhdyhjaGFydCkge1xuICAgIGlmIChjaGFydC5nZXQoJ2FuaW1hdGUnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgaXNVcGRhdGUgPSBjaGFydC5nZXQoJ2lzVXBkYXRlJyk7XG4gICAgdmFyIGNhbnZhcyA9IGNoYXJ0LmdldCgnY2FudmFzJyk7XG4gICAgdmFyIGNvb3JkID0gY2hhcnQuZ2V0KCdjb29yZCcpO1xuICAgIHZhciBnZW9tcyA9IGNoYXJ0LmdldCgnZ2VvbXMnKTtcbiAgICB2YXIgY2FjaGVzID0gY2FudmFzLmdldCgnY2FjaGVzJykgfHwgW107XG5cbiAgICBpZiAoY2FjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaXNVcGRhdGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVTaGFwZXMgPSBnZXRTaGFwZXMoZ2VvbXMsIGNoYXJ0LCBjb29yZCk7XG5cbiAgICB2YXIgX2NoYXJ0JGdldCA9IGNoYXJ0LmdldCgnYXhpc0NvbnRyb2xsZXInKSxcbiAgICAgICAgZnJvbnRQbG90ID0gX2NoYXJ0JGdldC5mcm9udFBsb3QsXG4gICAgICAgIGJhY2tQbG90ID0gX2NoYXJ0JGdldC5iYWNrUGxvdDtcblxuICAgIHZhciBheGlzU2hhcGVzID0gZnJvbnRQbG90LmdldCgnY2hpbGRyZW4nKS5jb25jYXQoYmFja1Bsb3QuZ2V0KCdjaGlsZHJlbicpKTtcbiAgICB2YXIgZ3VpZGVTaGFwZXMgPSBbXTtcblxuICAgIGlmIChjaGFydC5nZXQoJ2d1aWRlQ29udHJvbGxlcicpKSB7XG4gICAgICBndWlkZVNoYXBlcyA9IGNoYXJ0LmdldCgnZ3VpZGVDb250cm9sbGVyJykuZ3VpZGVTaGFwZXM7XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFNoYXBlcyA9IFtdO1xuICAgIGF4aXNTaGFwZXMuY29uY2F0KGd1aWRlU2hhcGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChzKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gcy5nZXQoJ2NsYXNzTmFtZScpO1xuXG4gICAgICB2YXIgYW5pbWF0ZUNmZyA9IF9nZXRBbmltYXRlQ2ZnQnlTaGFwZVR5cGUoY2xhc3NOYW1lLCBjaGFydCk7XG5cbiAgICAgIHMuc2V0KCdjb29yZCcsIGNvb3JkKTtcbiAgICAgIHMuc2V0KCdhbmltYXRlQ2ZnJywgYW5pbWF0ZUNmZyk7XG4gICAgICBjb21wb25lbnRTaGFwZXMucHVzaChzKTtcbiAgICAgIGNhY2hlU2hhcGVzLnB1c2gocyk7XG4gICAgfSk7XG4gICAgY2FudmFzLnNldCgnY2FjaGVzJywgY2FjaGUoY2FjaGVTaGFwZXMpKTtcblxuICAgIGlmIChpc1VwZGF0ZSkge1xuICAgICAgYWRkQW5pbWF0ZShjYWNoZXMsIGNhY2hlU2hhcGVzLCBjYW52YXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkbyB0aGUgYXBwZWFyIGFuaW1hdGlvblxuICAgICAgdmFyIGFuaW1hdGVDZmc7XG4gICAgICB2YXIgYW5pbWF0ZTtcbiAgICAgIFV0aWwuZWFjaChnZW9tcywgZnVuY3Rpb24gKGdlb20pIHtcbiAgICAgICAgdmFyIHR5cGUgPSBnZW9tLmdldCgndHlwZScpO1xuICAgICAgICB2YXIgZ2VvbUNmZyA9IFV0aWwuaXNOaWwoZ2VvbS5nZXQoJ2FuaW1hdGVDZmcnKSkgPyBfZ2V0QW5pbWF0ZUNmZ0J5U2hhcGVUeXBlKHR5cGUsIGNoYXJ0KSA6IGdlb20uZ2V0KCdhbmltYXRlQ2ZnJyk7XG5cbiAgICAgICAgaWYgKGdlb21DZmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgYW5pbWF0ZUNmZyA9IGdldEFuaW1hdGVDZmcodHlwZSwgJ2FwcGVhcicsIGdlb21DZmcpO1xuICAgICAgICAgIGFuaW1hdGUgPSBnZXRBbmltYXRlKHR5cGUsIGNvb3JkLCAnYXBwZWFyJywgYW5pbWF0ZUNmZy5hbmltYXRpb24pO1xuXG4gICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihhbmltYXRlKSkge1xuICAgICAgICAgICAgdmFyIHNoYXBlcyA9IGdlb20uZ2V0KCdzaGFwZXMnKTtcbiAgICAgICAgICAgIFV0aWwuZWFjaChzaGFwZXMsIGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgICBhbmltYXRlKHNoYXBlLCBhbmltYXRlQ2ZnLCBjb29yZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKEdST1VQX0FOSU1BVElPTlt0eXBlXSkge1xuICAgICAgICAgICAgLy8gZG8gdGhlIGRlZmF1bHQgYW5pbWF0aW9uXG4gICAgICAgICAgICBhbmltYXRlID0gR3JvdXBBY3Rpb25bYW5pbWF0ZUNmZy5hbmltYXRpb25dIHx8IEdST1VQX0FOSU1BVElPTlt0eXBlXShjb29yZCk7XG4gICAgICAgICAgICB2YXIgeVNjYWxlID0gZ2VvbS5nZXRZU2NhbGUoKTtcbiAgICAgICAgICAgIHZhciB6ZXJvWSA9IGNvb3JkLmNvbnZlcnRQb2ludCh7XG4gICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgIHk6IHlTY2FsZS5zY2FsZShnZW9tLmdldFlNaW5WYWx1ZSgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyID0gZ2VvbS5nZXQoJ2NvbnRhaW5lcicpO1xuICAgICAgICAgICAgYW5pbWF0ZSAmJiBhbmltYXRlKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgY29vcmQsIHplcm9ZKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBkbyB0aGUgYW5pbWF0aW9uIG9mIGNvbXBvbmVudHNcblxuICAgICAgVXRpbC5lYWNoKGNvbXBvbmVudFNoYXBlcywgZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgIHZhciBhbmltYXRlQ2ZnID0gc2hhcGUuZ2V0KCdhbmltYXRlQ2ZnJyk7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBzaGFwZS5nZXQoJ2NsYXNzTmFtZScpO1xuXG4gICAgICAgIGlmIChhbmltYXRlQ2ZnICYmIGFuaW1hdGVDZmcuYXBwZWFyKSB7XG4gICAgICAgICAgLy8gaWYgdXNlciBjb25maWd1cmVcbiAgICAgICAgICB2YXIgZGVmYXVsdENmZyA9IEFuaW1hdGUuZ2V0QW5pbWF0ZUNmZyhjbGFzc05hbWUsICdhcHBlYXInKTtcbiAgICAgICAgICB2YXIgYXBwZWFyQ2ZnID0gVXRpbC5kZWVwTWl4KHt9LCBkZWZhdWx0Q2ZnLCBhbmltYXRlQ2ZnLmFwcGVhcik7XG5cbiAgICAgICAgICB2YXIgX2FuaW1hdGUgPSBnZXRBbmltYXRlKGNsYXNzTmFtZSwgY29vcmQsICdhcHBlYXInLCBhcHBlYXJDZmcuYW5pbWF0aW9uKTtcblxuICAgICAgICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oX2FuaW1hdGUpKSB7XG4gICAgICAgICAgICBfYW5pbWF0ZShzaGFwZSwgYXBwZWFyQ2ZnLCBjb29yZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG4gIGFmdGVyQ2FudmFzRGVzdHJveWVkOiBmdW5jdGlvbiBhZnRlckNhbnZhc0Rlc3Ryb3llZCgpXG4gIC8qIGNoYXJ0ICovXG4gIHtcbiAgICB0aW1lbGluZS5zdG9wKCk7XG4gIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNDApLFxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IF9yZXF1aXJlLnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblxudmFyIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiBwZXJmb3JtYW5jZS5ub3cgPyBwZXJmb3JtYW5jZSA6IERhdGU7XG5cbnZhciBUaW1lbGluZSA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpbWVsaW5lKCkge1xuICAgIHRoaXMuYW5pbXMgPSBbXTtcbiAgICB0aGlzLnRpbWUgPSBudWxsO1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FudmFzID0gW107XG4gIH1cblxuICB2YXIgX3Byb3RvID0gVGltZWxpbmUucHJvdG90eXBlO1xuXG4gIF9wcm90by5wbGF5ID0gZnVuY3Rpb24gcGxheSgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi50aW1lID0gY2xvY2subm93KCk7XG4gICAgc2VsZi5wbGF5aW5nID0gdHJ1ZTtcblxuICAgIGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgICBpZiAoc2VsZi5wbGF5aW5nKSB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShzdGVwKTtcbiAgICAgICAgc2VsZi51cGRhdGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH07XG5cbiAgX3Byb3RvLnN0b3AgPSBmdW5jdGlvbiBzdG9wKCkge1xuICAgIHRoaXMucGxheWluZyA9IGZhbHNlO1xuICAgIHRoaXMudGltZSA9IG51bGw7XG4gICAgdGhpcy5jYW52YXMgPSBbXTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKCkge1xuICAgIHZhciBjdXJyZW50VGltZSA9IGNsb2NrLm5vdygpO1xuICAgIHRoaXMuY2FudmFzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuYW5pbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwcm9wZXJ0eUFuaW0gPSB0aGlzLmFuaW1zW2ldO1xuXG4gICAgICBpZiAoY3VycmVudFRpbWUgPCBwcm9wZXJ0eUFuaW0uc3RhcnRUaW1lIHx8IHByb3BlcnR5QW5pbS5oYXNFbmRlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHNoYXBlID0gcHJvcGVydHlBbmltLnNoYXBlOyAvLyBzaGFwZVxuXG4gICAgICBpZiAoc2hhcGUuZ2V0KCdkZXN0cm95ZWQnKSkge1xuICAgICAgICB0aGlzLmFuaW1zLnNwbGljZShpLCAxKTtcbiAgICAgICAgaS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0U3RhdGUgPSBwcm9wZXJ0eUFuaW0uc3RhcnRTdGF0ZSxcbiAgICAgICAgICBlbmRTdGF0ZSA9IHByb3BlcnR5QW5pbS5lbmRTdGF0ZSxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IHByb3BlcnR5QW5pbS5pbnRlcnBvbGF0ZSxcbiAgICAgICAgICBkdXJhdGlvbiA9IHByb3BlcnR5QW5pbS5kdXJhdGlvbjtcblxuICAgICAgaWYgKGN1cnJlbnRUaW1lID49IHByb3BlcnR5QW5pbS5zdGFydFRpbWUgJiYgIXByb3BlcnR5QW5pbS5oYXNTdGFydGVkKSB7XG4gICAgICAgIHByb3BlcnR5QW5pbS5oYXNTdGFydGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAocHJvcGVydHlBbmltLm9uU3RhcnQpIHtcbiAgICAgICAgICBwcm9wZXJ0eUFuaW0ub25TdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gKGN1cnJlbnRUaW1lIC0gcHJvcGVydHlBbmltLnN0YXJ0VGltZSkgLyBkdXJhdGlvbjtcbiAgICAgIHQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih0LCAxKSk7XG4gICAgICB0ID0gcHJvcGVydHlBbmltLmVhc2luZyh0KTtcblxuICAgICAgaWYgKHByb3BlcnR5QW5pbS5vbkZyYW1lKSB7XG4gICAgICAgIHByb3BlcnR5QW5pbS5vbkZyYW1lKHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGludGVycG9sYXRlKSB7XG4gICAgICAgICAgdmFyIGRpZmYgPSBpbnRlcnBvbGF0ZVtrZXldO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGRpZmYodCk7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdm9pZCAwO1xuXG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3BvaW50cycpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gW107XG4gICAgICAgICAgICB2YXIgYUxlbiA9IE1hdGgubWF4KHN0YXJ0U3RhdGUucG9pbnRzLmxlbmd0aCwgZW5kU3RhdGUucG9pbnRzLmxlbmd0aCk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYUxlbjsgaiArPSAyKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IHZhbHVlW2pdLFxuICAgICAgICAgICAgICAgIHk6IHZhbHVlW2ogKyAxXVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzaGFwZS5fYXR0cnMuYXR0cnNba2V5XSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIHNoYXBlLl9hdHRycy5iYm94ID0gbnVsbDsgLy8gc2hvdWxkIGNsZWFyIGNhbGN1bGF0ZWQgYmJveFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjYW52YXMgPSBzaGFwZS5nZXQoJ2NhbnZhcycpO1xuXG4gICAgICBpZiAodGhpcy5jYW52YXMuaW5kZXhPZihjYW52YXMpID09PSAtMSkge1xuICAgICAgICB0aGlzLmNhbnZhcy5wdXNoKGNhbnZhcyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wZXJ0eUFuaW0ub25VcGRhdGUpIHtcbiAgICAgICAgcHJvcGVydHlBbmltLm9uVXBkYXRlKHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3VycmVudFRpbWUgPj0gcHJvcGVydHlBbmltLmVuZFRpbWUgJiYgIXByb3BlcnR5QW5pbS5oYXNFbmRlZCkge1xuICAgICAgICBwcm9wZXJ0eUFuaW0uaGFzRW5kZWQgPSB0cnVlO1xuXG4gICAgICAgIGlmIChwcm9wZXJ0eUFuaW0ub25FbmQpIHtcbiAgICAgICAgICBwcm9wZXJ0eUFuaW0ub25FbmQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodCA9PT0gMSkge1xuICAgICAgICAvLyBlbmRcbiAgICAgICAgdGhpcy5hbmltcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGktLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmNhbnZhcy5tYXAoZnVuY3Rpb24gKGMpIHtcbiAgICAgIGMuZHJhdygpO1xuICAgICAgcmV0dXJuIGM7XG4gICAgfSk7XG4gICAgdGhpcy50aW1lID0gY2xvY2subm93KCk7XG4gIH07XG5cbiAgcmV0dXJuIFRpbWVsaW5lO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRpbWVsaW5lO1xuXG4vKioqLyB9KSxcbi8qIDEzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG52YXIgRWFzaW5nID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzQpO1xuXG5mdW5jdGlvbiBwbGFpbkFycmF5KGFycikge1xuICB2YXIgcmVzdWx0ID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJbaV0pIHtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXS54KTtcbiAgICAgIHJlc3VsdC5wdXNoKGFycltpXS55KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZU51bWJlcihhLCBiKSB7XG4gIGEgPSArYTtcbiAgYiAtPSBhO1xuICByZXR1cm4gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gYSArIGIgKiB0O1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUFycmF5KGEsIGIpIHtcbiAgdmFyIG5iID0gYiA/IGIubGVuZ3RoIDogMDtcbiAgdmFyIG5hID0gYSA/IE1hdGgubWluKG5iLCBhLmxlbmd0aCkgOiAwO1xuICB2YXIgeCA9IG5ldyBBcnJheShuYSk7XG4gIHZhciBjID0gbmV3IEFycmF5KG5iKTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IG5hOyArK2kpIHtcbiAgICB4W2ldID0gaW50ZXJwb2xhdGVOdW1iZXIoYVtpXSwgYltpXSk7XG4gIH1cblxuICBmb3IgKDsgaSA8IG5iOyArK2kpIHtcbiAgICBjW2ldID0gYltpXTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuYTsgKytpKSB7XG4gICAgICBjW2ldID0geFtpXSh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfTtcbn1cblxudmFyIEFuaW1hdG9yID1cbi8qI19fUFVSRV9fKi9cbmZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQW5pbWF0b3Ioc2hhcGUsIHNvdXJjZSwgdGltZWxpbmUpIHtcbiAgICB0aGlzLmhhc1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhc0VuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICB0aGlzLmFuaW1hdGUgPSBudWxsO1xuICB9IC8vIGRlbGF5LCBhdHRycywgZHVyYXRpb24sIGVhc2luZ1xuXG5cbiAgdmFyIF9wcm90byA9IEFuaW1hdG9yLnByb3RvdHlwZTtcblxuICBfcHJvdG8udG8gPSBmdW5jdGlvbiB0byhjZmcpIHtcbiAgICBpZiAoY2ZnID09PSB2b2lkIDApIHtcbiAgICAgIGNmZyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBkZWxheSA9IGNmZy5kZWxheSB8fCAwO1xuICAgIHZhciBhdHRycyA9IGNmZy5hdHRycyB8fCB7fTtcbiAgICB2YXIgZHVyYXRpb24gPSBjZmcuZHVyYXRpb24gfHwgMTAwMDtcbiAgICB2YXIgZWFzaW5nOyAvLyDnvJPliqjlh73mlbBcblxuICAgIGlmICh0eXBlb2YgY2ZnLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZWFzaW5nID0gY2ZnLmVhc2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgZWFzaW5nID0gRWFzaW5nW2NmZy5lYXNpbmddIHx8IEVhc2luZy5saW5lYXI7XG4gICAgfVxuXG4gICAgdmFyIGFuaW1JbmZvID0ge1xuICAgICAgc2hhcGU6IHRoaXMuc2hhcGUsXG4gICAgICBzdGFydFRpbWU6IHRoaXMudGltZWxpbmUudGltZSArIGRlbGF5LFxuICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICB9O1xuICAgIHZhciBpbnRlcnBvbGF0ZSA9IHt9OyAvLyDlt67lgLzlh73mlbBcblxuICAgIGZvciAodmFyIGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuc291cmNlW2F0dHJOYW1lXTtcbiAgICAgIHZhciBlbmRWYWx1ZSA9IGF0dHJzW2F0dHJOYW1lXTtcblxuICAgICAgaWYgKGF0dHJOYW1lID09PSAncG9pbnRzJykge1xuICAgICAgICBzdGFydFZhbHVlID0gcGxhaW5BcnJheShzdGFydFZhbHVlKTtcbiAgICAgICAgZW5kVmFsdWUgPSBwbGFpbkFycmF5KGVuZFZhbHVlKTtcbiAgICAgICAgaW50ZXJwb2xhdGUucG9pbnRzID0gaW50ZXJwb2xhdGVBcnJheShzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICAgIHRoaXMuc291cmNlLnBvaW50cyA9IHN0YXJ0VmFsdWU7XG4gICAgICAgIGF0dHJzLnBvaW50cyA9IGVuZFZhbHVlO1xuICAgICAgfSBlbHNlIGlmIChhdHRyTmFtZSA9PT0gJ21hdHJpeCcpIHtcbiAgICAgICAgaW50ZXJwb2xhdGUubWF0cml4ID0gaW50ZXJwb2xhdGVBcnJheShzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcnBvbGF0ZVthdHRyTmFtZV0gPSBpbnRlcnBvbGF0ZU51bWJlcihzdGFydFZhbHVlLCBlbmRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYW5pbUluZm8uaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZTtcbiAgICBhbmltSW5mby5zdGFydFN0YXRlID0gdGhpcy5zb3VyY2U7XG4gICAgYW5pbUluZm8uZW5kU3RhdGUgPSBhdHRycztcbiAgICBhbmltSW5mby5lbmRUaW1lID0gYW5pbUluZm8uc3RhcnRUaW1lICsgZHVyYXRpb247XG4gICAgdGhpcy50aW1lbGluZS5hbmltcy5wdXNoKGFuaW1JbmZvKTtcbiAgICB0aGlzLmFuaW1hdGUgPSBhbmltSW5mbztcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ub25GcmFtZSA9IGZ1bmN0aW9uIG9uRnJhbWUoY2FsbGJhY2spIHtcbiAgICAvLyDoh6rlrprkuYnmr4/kuIDluKfliqjnlLvnmoTliqjkvZxcbiAgICBpZiAodGhpcy5hbmltYXRlKSB7XG4gICAgICB0aGlzLmFuaW1hdGUub25GcmFtZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBjYWxsYmFjayhmcmFtZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vblN0YXJ0ID0gZnVuY3Rpb24gb25TdGFydChjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZS5vblN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBfcHJvdG8ub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZShjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmFuaW1hdGUpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgICAgICBjYWxsYmFjayhmcmFtZSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIF9wcm90by5vbkVuZCA9IGZ1bmN0aW9uIG9uRW5kKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0ZSkge1xuICAgICAgdGhpcy5hbmltYXRlLm9uRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gQW5pbWF0b3I7XG59KCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQW5pbWF0b3I7XG5cbi8qKiovIH0pLFxuLyogMTM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBFYXNpbmcgPSB7XG4gIGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGspIHtcbiAgICByZXR1cm4gaztcbiAgfSxcbiAgcXVhZHJhdGljSW46IGZ1bmN0aW9uIHF1YWRyYXRpY0luKGspIHtcbiAgICByZXR1cm4gayAqIGs7XG4gIH0sXG4gIHF1YWRyYXRpY091dDogZnVuY3Rpb24gcXVhZHJhdGljT3V0KGspIHtcbiAgICByZXR1cm4gayAqICgyIC0gayk7XG4gIH0sXG4gIHF1YWRyYXRpY0luT3V0OiBmdW5jdGlvbiBxdWFkcmF0aWNJbk91dChrKSB7XG4gICAgaWYgKChrICo9IDIpIDwgMSkge1xuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbiAgfSxcbiAgY3ViaWNJbjogZnVuY3Rpb24gY3ViaWNJbihrKSB7XG4gICAgcmV0dXJuIGsgKiBrICogaztcbiAgfSxcbiAgY3ViaWNPdXQ6IGZ1bmN0aW9uIGN1YmljT3V0KGspIHtcbiAgICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xuICB9LFxuICBjdWJpY0luT3V0OiBmdW5jdGlvbiBjdWJpY0luT3V0KGspIHtcbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xuICB9LFxuICBlbGFzdGljSW46IGZ1bmN0aW9uIGVsYXN0aWNJbihrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG4gICAgaWYgKGsgPT09IDApIHJldHVybiAwO1xuICAgIGlmIChrID09PSAxKSByZXR1cm4gMTtcblxuICAgIGlmICghcCkge1xuICAgICAgcCA9IDAuMztcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuICAgIH1cblxuICAgIHJldHVybiAtKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICB9LFxuICBlbGFzdGljT3V0OiBmdW5jdGlvbiBlbGFzdGljT3V0KGspIHtcbiAgICB2YXIgcztcbiAgICB2YXIgYSA9IDAuMTtcbiAgICB2YXIgcCA9IDAuNDtcbiAgICBpZiAoayA9PT0gMCkgcmV0dXJuIDA7XG4gICAgaWYgKGsgPT09IDEpIHJldHVybiAxO1xuXG4gICAgaWYgKCFwKSB7XG4gICAgICBwID0gMC4zO1xuICAgIH1cblxuICAgIGlmICghYSB8fCBhIDwgMSkge1xuICAgICAgYSA9IDE7XG4gICAgICBzID0gcCAvIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMgPSBwIC8gKDIgKiBNYXRoLlBJKSAqIE1hdGguYXNpbigxIC8gYSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGEgKiBNYXRoLnBvdygyLCAtMTAgKiBrKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkgKyAxO1xuICB9LFxuICBlbGFzdGljSW5PdXQ6IGZ1bmN0aW9uIGVsYXN0aWNJbk91dChrKSB7XG4gICAgdmFyIHM7XG4gICAgdmFyIGEgPSAwLjE7XG4gICAgdmFyIHAgPSAwLjQ7XG4gICAgaWYgKGsgPT09IDApIHJldHVybiAwO1xuICAgIGlmIChrID09PSAxKSByZXR1cm4gMTtcblxuICAgIGlmICghcCkge1xuICAgICAgcCA9IDAuMztcbiAgICB9XG5cbiAgICBpZiAoIWEgfHwgYSA8IDEpIHtcbiAgICAgIGEgPSAxO1xuICAgICAgcyA9IHAgLyA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzID0gcCAvICgyICogTWF0aC5QSSkgKiBNYXRoLmFzaW4oMSAvIGEpO1xuICAgIH1cblxuICAgIGlmICgoayAqPSAyKSA8IDEpIHtcbiAgICAgIHJldHVybiAtMC41ICogKGEgKiBNYXRoLnBvdygyLCAxMCAqIChrIC09IDEpKSAqIE1hdGguc2luKChrIC0gcykgKiAoMiAqIE1hdGguUEkpIC8gcCkpO1xuICAgIH1cblxuICAgIHJldHVybiBhICogTWF0aC5wb3coMiwgLTEwICogKGsgLT0gMSkpICogTWF0aC5zaW4oKGsgLSBzKSAqICgyICogTWF0aC5QSSkgLyBwKSAqIDAuNSArIDE7XG4gIH0sXG4gIGJhY2tJbjogZnVuY3Rpb24gYmFja0luKGspIHtcbiAgICB2YXIgcyA9IDEuNzAxNTg7XG4gICAgcmV0dXJuIGsgKiBrICogKChzICsgMSkgKiBrIC0gcyk7XG4gIH0sXG4gIGJhY2tPdXQ6IGZ1bmN0aW9uIGJhY2tPdXQoaykge1xuICAgIHZhciBzID0gMS43MDE1ODtcbiAgICByZXR1cm4gKGsgPSBrIC0gMSkgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xuICB9LFxuICBiYWNrSW5PdXQ6IGZ1bmN0aW9uIGJhY2tJbk91dChrKSB7XG4gICAgdmFyIHMgPSAxLjcwMTU4ICogMS41MjU7XG5cbiAgICBpZiAoKGsgKj0gMikgPCAxKSB7XG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xuICAgIH1cblxuICAgIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAyKTtcbiAgfSxcbiAgYm91bmNlSW46IGZ1bmN0aW9uIGJvdW5jZUluKGspIHtcbiAgICByZXR1cm4gMSAtIEVhc2luZy5ib3VuY2VPdXQoMSAtIGspO1xuICB9LFxuICBib3VuY2VPdXQ6IGZ1bmN0aW9uIGJvdW5jZU91dChrKSB7XG4gICAgaWYgKChrIC89IDEpIDwgMSAvIDIuNzUpIHtcbiAgICAgIHJldHVybiA3LjU2MjUgKiBrICogaztcbiAgICB9IGVsc2UgaWYgKGsgPCAyIC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDEuNSAvIDIuNzUpICogayArIDAuNzU7XG4gICAgfSBlbHNlIGlmIChrIDwgMi41IC8gMi43NSkge1xuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuMjUgLyAyLjc1KSAqIGsgKyAwLjkzNzU7XG4gICAgfVxuXG4gICAgcmV0dXJuIDcuNTYyNSAqIChrIC09IDIuNjI1IC8gMi43NSkgKiBrICsgMC45ODQzNzU7XG4gIH0sXG4gIGJvdW5jZUluT3V0OiBmdW5jdGlvbiBib3VuY2VJbk91dChrKSB7XG4gICAgaWYgKGsgPCAwLjUpIHtcbiAgICAgIHJldHVybiBFYXNpbmcuYm91bmNlSW4oayAqIDIpICogMC41O1xuICAgIH1cblxuICAgIHJldHVybiBFYXNpbmcuYm91bmNlT3V0KGsgKiAyIC0gMSkgKiAwLjUgKyAwLjU7XG4gIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IEVhc2luZztcblxuLyoqKi8gfSksXG4vKiAxMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBBbmltYXRpb24gZnVuY3Rpb25zIGZvciBzaGFwZVxuICogQGF1dGhvciBzaW1hLnpoYW5nMTk5MEBnbWFpbC5jb21cbiAqL1xudmFyIFV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG52YXIgSGVscGVycyA9IF9fd2VicGFja19yZXF1aXJlX18oMTAzKTtcbi8qXG5mdW5jdGlvbiB3YXZlSW4oc2hhcGUsIGFuaW1hdGVDZmcsIGNvb3JkKSB7XG4gIGNvbnN0IGNsaXAgPSBIZWxwZXJzLmdldENsaXAoY29vcmQpO1xuICBjbGlwLnNldCgnY2FudmFzJywgc2hhcGUuZ2V0KCdjYW52YXMnKSk7XG4gIHNoYXBlLmF0dHIoJ2NsaXAnLCBjbGlwKTtcbiAgY29uc3Qgb25FbmQgPSBmdW5jdGlvbigpIHtcbiAgICBzaGFwZS5hdHRyKCdjbGlwJywgbnVsbCk7XG4gICAgY2xpcC5yZW1vdmUodHJ1ZSk7XG4gIH07XG4gIEhlbHBlcnMuZG9BbmltYXRpb24oY2xpcCwgY2xpcC5lbmRTdGF0ZSwgYW5pbWF0ZUNmZywgb25FbmQpO1xufVxuXG5mdW5jdGlvbiBzY2FsZUluWChzaGFwZSwgYW5pbWF0ZUNmZykge1xuICBjb25zdCBib3ggPSBzaGFwZS5nZXRCQm94KCk7XG4gIGNvbnN0IHBvaW50cyA9IHNoYXBlLmdldCgnb3JpZ2luJykucG9pbnRzO1xuICBsZXQgeDtcbiAgY29uc3QgeSA9IChib3gubWluWSArIGJveC5tYXhZKSAvIDI7XG5cbiAgaWYgKHBvaW50c1swXS55IC0gcG9pbnRzWzFdLnkgPiAwKSB7IC8vIOW9k+mhtueCueWcqOmbtueCueS5i+S4i1xuICAgIHggPSBib3gubWF4WDtcbiAgfSBlbHNlIHtcbiAgICB4ID0gYm94Lm1pblg7XG4gIH1cbiAgY29uc3Qgc2NhbGVkTWF0cml4ID0gSGVscGVycy5nZXRTY2FsZWRNYXRyaXgoc2hhcGUsIFsgeCwgeSBdLCAneCcpO1xuICBIZWxwZXJzLmRvQW5pbWF0aW9uKHNoYXBlLCB7IG1hdHJpeDogc2NhbGVkTWF0cml4IH0sIGFuaW1hdGVDZmcpO1xufVxuXG5mdW5jdGlvbiBzY2FsZUluWShzaGFwZSwgYW5pbWF0ZUNmZykge1xuICBjb25zdCBib3ggPSBzaGFwZS5nZXRCQm94KCk7XG4gIGNvbnN0IHBvaW50cyA9IHNoYXBlLmdldCgnb3JpZ2luJykucG9pbnRzO1xuICBjb25zdCB4ID0gKGJveC5taW5YICsgYm94Lm1heFgpIC8gMjtcbiAgbGV0IHk7XG5cbiAgaWYgKHBvaW50c1swXS55IC0gcG9pbnRzWzFdLnkgPD0gMCkgeyAvLyDlvZPpobbngrnlnKjpm7bngrnkuYvkuItcbiAgICB5ID0gYm94Lm1heFk7XG4gIH0gZWxzZSB7XG4gICAgeSA9IGJveC5taW5ZO1xuICB9XG4gIGNvbnN0IHNjYWxlZE1hdHJpeCA9IEhlbHBlcnMuZ2V0U2NhbGVkTWF0cml4KHNoYXBlLCBbIHgsIHkgXSwgJ3gnKTtcbiAgSGVscGVycy5kb0FuaW1hdGlvbihzaGFwZSwgeyBtYXRyaXg6IHNjYWxlZE1hdHJpeCB9LCBhbmltYXRlQ2ZnKTtcbn1cbiovXG5cblxuZnVuY3Rpb24gZmFkZUluKHNoYXBlLCBhbmltYXRlQ2ZnKSB7XG4gIHZhciBmaWxsT3BhY2l0eSA9IFV0aWwuaXNOaWwoc2hhcGUuYXR0cignZmlsbE9wYWNpdHknKSkgPyAxIDogc2hhcGUuYXR0cignZmlsbE9wYWNpdHknKTtcbiAgdmFyIHN0cm9rZU9wYWNpdHkgPSBVdGlsLmlzTmlsKHNoYXBlLmF0dHIoJ3N0cm9rZU9wYWNpdHknKSkgPyAxIDogc2hhcGUuYXR0cignc3Ryb2tlT3BhY2l0eScpO1xuICBzaGFwZS5hdHRyKCdmaWxsT3BhY2l0eScsIDApO1xuICBzaGFwZS5hdHRyKCdzdHJva2VPcGFjaXR5JywgMCk7XG4gIHZhciBlbmRTdGF0ZSA9IHtcbiAgICBmaWxsT3BhY2l0eTogZmlsbE9wYWNpdHksXG4gICAgc3Ryb2tlT3BhY2l0eTogc3Ryb2tlT3BhY2l0eVxuICB9O1xuICBIZWxwZXJzLmRvQW5pbWF0aW9uKHNoYXBlLCBlbmRTdGF0ZSwgYW5pbWF0ZUNmZyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyB3YXZlSW4sXG4gIC8vIHNjYWxlSW5YLFxuICAvLyBzY2FsZUluWSxcbiAgZmFkZUluOiBmYWRlSW5cbn07XG5cbi8qKiovIH0pLFxuLyogMTM2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogR3JvdXAgYW5pbWF0ZSBmdW5jdGlvbnNcbiAqIEBhdXRob3Igc2ltYS56aGFuZzE5OTBAZ21haWwuY29tXG4gKi9cbnZhciBVdGlsID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDMpO1xuXG52YXIgSGVscGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSksXG4gICAgU2hhcGUgPSBfcmVxdWlyZS5TaGFwZTtcblxuZnVuY3Rpb24gX2dyb3VwU2NhbGVJbihjb250YWluZXIsIGFuaW1hdGVDZmcsIGNvb3JkLCB6ZXJvWSwgdHlwZSkge1xuICB2YXIgX1V0aWwkZ2V0Q29vcmRJbmZvID0gVXRpbC5nZXRDb29yZEluZm8oY29vcmQpLFxuICAgICAgc3RhcnQgPSBfVXRpbCRnZXRDb29yZEluZm8uc3RhcnQsXG4gICAgICBlbmQgPSBfVXRpbCRnZXRDb29yZEluZm8uZW5kLFxuICAgICAgd2lkdGggPSBfVXRpbCRnZXRDb29yZEluZm8ud2lkdGgsXG4gICAgICBoZWlnaHQgPSBfVXRpbCRnZXRDb29yZEluZm8uaGVpZ2h0O1xuXG4gIHZhciB4O1xuICB2YXIgeTtcbiAgdmFyIGNsaXAgPSBuZXcgU2hhcGUuUmVjdCh7XG4gICAgYXR0cnM6IHtcbiAgICAgIHg6IHN0YXJ0LngsXG4gICAgICB5OiBlbmQueSxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfVxuICB9KTtcblxuICBpZiAodHlwZSA9PT0gJ3knKSB7XG4gICAgeCA9IHN0YXJ0LnggKyB3aWR0aCAvIDI7XG4gICAgeSA9IHplcm9ZLnkgPCBzdGFydC55ID8gemVyb1kueSA6IHN0YXJ0Lnk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3gnKSB7XG4gICAgeCA9IHplcm9ZLnggPiBzdGFydC54ID8gemVyb1kueCA6IHN0YXJ0Lng7XG4gICAgeSA9IHN0YXJ0LnkgKyBoZWlnaHQgLyAyO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd4eScpIHtcbiAgICBpZiAoY29vcmQuaXNQb2xhcikge1xuICAgICAgeCA9IGNvb3JkLmNlbnRlci54O1xuICAgICAgeSA9IGNvb3JkLmNlbnRlci55O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gKHN0YXJ0LnggKyBlbmQueCkgLyAyO1xuICAgICAgeSA9IChzdGFydC55ICsgZW5kLnkpIC8gMjtcbiAgICB9XG4gIH1cblxuICB2YXIgZW5kTWF0cml4ID0gVXRpbC5nZXRTY2FsZWRNYXRyaXgoY2xpcCwgW3gsIHldLCB0eXBlKTtcbiAgY2xpcC5pc0NsaXAgPSB0cnVlO1xuICBjbGlwLmVuZFN0YXRlID0ge1xuICAgIG1hdHJpeDogZW5kTWF0cml4XG4gIH07XG4gIGNsaXAuc2V0KCdjYW52YXMnLCBjb250YWluZXIuZ2V0KCdjYW52YXMnKSk7XG4gIGNvbnRhaW5lci5hdHRyKCdjbGlwJywgY2xpcCk7XG5cbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgY29udGFpbmVyLmF0dHIoJ2NsaXAnLCBudWxsKTtcbiAgICBjbGlwLnJlbW92ZSh0cnVlKTtcbiAgfTtcblxuICBVdGlsLmRvQW5pbWF0aW9uKGNsaXAsIGNsaXAuZW5kU3RhdGUsIGFuaW1hdGVDZmcsIG9uRW5kKTtcbn1cblxuZnVuY3Rpb24gX3NoYXBlU2NhbGUoY29udGFpbmVyLCBhbmltYXRlQ2ZnLCB0eXBlKSB7XG4gIHZhciBzaGFwZXMgPSBjb250YWluZXIuZ2V0KCdjaGlsZHJlbicpO1xuICB2YXIgeDtcbiAgdmFyIHk7XG4gIHZhciBlbmRNYXRyaXg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNoYXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzaGFwZSA9IHNoYXBlc1tpXTtcbiAgICB2YXIgYm94ID0gc2hhcGUuZ2V0QkJveCgpO1xuICAgIHggPSAoYm94Lm1pblggKyBib3gubWF4WCkgLyAyO1xuICAgIHkgPSAoYm94Lm1pblkgKyBib3gubWF4WSkgLyAyO1xuICAgIGVuZE1hdHJpeCA9IFV0aWwuZ2V0U2NhbGVkTWF0cml4KHNoYXBlLCBbeCwgeV0sIHR5cGUpO1xuICAgIFV0aWwuZG9BbmltYXRpb24oc2hhcGUsIHtcbiAgICAgIG1hdHJpeDogZW5kTWF0cml4XG4gICAgfSwgYW5pbWF0ZUNmZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ3JvdXBTY2FsZUluWChjb250YWluZXIsIGFuaW1hdGVDZmcsIGNvb3JkLCB6ZXJvWSkge1xuICBfZ3JvdXBTY2FsZUluKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgY29vcmQsIHplcm9ZLCAneCcpO1xufVxuXG5mdW5jdGlvbiBncm91cFNjYWxlSW5ZKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgY29vcmQsIHplcm9ZKSB7XG4gIF9ncm91cFNjYWxlSW4oY29udGFpbmVyLCBhbmltYXRlQ2ZnLCBjb29yZCwgemVyb1ksICd5Jyk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwU2NhbGVJblhZKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgY29vcmQsIHplcm9ZKSB7XG4gIF9ncm91cFNjYWxlSW4oY29udGFpbmVyLCBhbmltYXRlQ2ZnLCBjb29yZCwgemVyb1ksICd4eScpO1xufVxuXG5mdW5jdGlvbiBzaGFwZXNTY2FsZUluWChjb250YWluZXIsIGFuaW1hdGVDZmcpIHtcbiAgX3NoYXBlU2NhbGUoY29udGFpbmVyLCBhbmltYXRlQ2ZnLCAneCcpO1xufVxuXG5mdW5jdGlvbiBzaGFwZXNTY2FsZUluWShjb250YWluZXIsIGFuaW1hdGVDZmcpIHtcbiAgX3NoYXBlU2NhbGUoY29udGFpbmVyLCBhbmltYXRlQ2ZnLCAneScpO1xufVxuXG5mdW5jdGlvbiBzaGFwZXNTY2FsZUluWFkoY29udGFpbmVyLCBhbmltYXRlQ2ZnKSB7XG4gIF9zaGFwZVNjYWxlKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgJ3h5Jyk7XG59XG5cbmZ1bmN0aW9uIGdyb3VwV2F2ZUluKGNvbnRhaW5lciwgYW5pbWF0ZUNmZywgY29vcmQpIHtcbiAgdmFyIGNsaXAgPSBIZWxwZXIuZ2V0Q2xpcChjb29yZCk7XG4gIGNsaXAuc2V0KCdjYW52YXMnLCBjb250YWluZXIuZ2V0KCdjYW52YXMnKSk7XG4gIGNvbnRhaW5lci5hdHRyKCdjbGlwJywgY2xpcCk7XG5cbiAgdmFyIG9uRW5kID0gZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgY29udGFpbmVyLmF0dHIoJ2NsaXAnLCBudWxsKTtcbiAgICBjbGlwLnJlbW92ZSh0cnVlKTtcbiAgfTtcblxuICB2YXIgZW5kU3RhdGUgPSB7fTtcblxuICBpZiAoY29vcmQuaXNQb2xhcikge1xuICAgIHZhciBzdGFydEFuZ2xlID0gY29vcmQuc3RhcnRBbmdsZSxcbiAgICAgICAgZW5kQW5nbGUgPSBjb29yZC5lbmRBbmdsZTtcbiAgICBlbmRTdGF0ZS5lbmRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgIGNsaXAuYXR0cignZW5kQW5nbGUnLCBzdGFydEFuZ2xlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhcnQgPSBjb29yZC5zdGFydCxcbiAgICAgICAgZW5kID0gY29vcmQuZW5kO1xuICAgIHZhciB3aWR0aCA9IE1hdGguYWJzKHN0YXJ0LnggLSBlbmQueCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguYWJzKHN0YXJ0LnkgLSBlbmQueSk7XG5cbiAgICBpZiAoY29vcmQuaXNUcmFuc3Bvc2VkKSB7XG4gICAgICBjbGlwLmF0dHIoJ2hlaWdodCcsIDApO1xuICAgICAgZW5kU3RhdGUuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwLmF0dHIoJ3dpZHRoJywgMCk7XG4gICAgICBlbmRTdGF0ZS53aWR0aCA9IHdpZHRoO1xuICAgIH1cbiAgfVxuXG4gIFV0aWwuZG9BbmltYXRpb24oY2xpcCwgZW5kU3RhdGUsIGFuaW1hdGVDZmcsIG9uRW5kKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdyb3VwV2F2ZUluOiBncm91cFdhdmVJbixcbiAgZ3JvdXBTY2FsZUluWDogZ3JvdXBTY2FsZUluWCxcbiAgZ3JvdXBTY2FsZUluWTogZ3JvdXBTY2FsZUluWSxcbiAgZ3JvdXBTY2FsZUluWFk6IGdyb3VwU2NhbGVJblhZLFxuICBzaGFwZXNTY2FsZUluWDogc2hhcGVzU2NhbGVJblgsXG4gIHNoYXBlc1NjYWxlSW5ZOiBzaGFwZXNTY2FsZUluWSxcbiAgc2hhcGVzU2NhbGVJblhZOiBzaGFwZXNTY2FsZUluWFlcbn07XG5cbi8qKiovIH0pLFxuLyogMTM3ICovLFxuLyogMTM4ICovLFxuLyogMTM5ICovLFxuLyogMTQwICovLFxuLyogMTQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogRGVmYXVsdCwgd2l0aG91dCBpbnRlcmFjdGluc1xuICovXG52YXIgRjIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMDUpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDkzKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXyg5OCk7IC8vIHBvbGFyIGNvb3JkaW5hdGVcblxuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDExNCk7IC8vIHRoZSBheGlzIGZvciBwb2xhciBjb29yZGluYXRlXG5cblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMTUpOyAvLyB0aW1lQ2F0IHNjYWxlXG5cblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMTkpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyMCk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTIxKTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMjIpO1xuXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDEyMyk7XG5cbl9fd2VicGFja19yZXF1aXJlX18oMTI0KTtcblxuX193ZWJwYWNrX3JlcXVpcmVfXygxMjUpO1xuXG52YXIgVG9vbHRpcCA9IF9fd2VicGFja19yZXF1aXJlX18oMTI2KTtcblxudmFyIEd1aWRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMjkpO1xuXG52YXIgTGVnZW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzApO1xuXG52YXIgQW5pbWF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMzEpO1xuXG5GMi5BbmltYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMDIpOyAvLyByZWdpc3RlciBwbHVnaW5zXG5cbkYyLkNoYXJ0LnBsdWdpbnMucmVnaXN0ZXIoW1Rvb2x0aXAsIExlZ2VuZCwgR3VpZGUsIEFuaW1hdGlvbl0pO1xubW9kdWxlLmV4cG9ydHMgPSBGMjtcblxuLyoqKi8gfSlcbi8qKioqKiovIF0pO1xufSk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxRQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///399\n")}}]);